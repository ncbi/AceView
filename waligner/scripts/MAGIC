#!bin/tcsh -f
#######!/bin/env tcsh
#$ -S /bin/tcsh
#$ -P $project
#$ -j y
#$ -m e
#$ -v SGE_SUMMARY="stderr"
#$ -v SGE_NOMAIL

# Check farm usage
# qstat -u '*' | gawk '{n[$4]++}END{for(k in n) printf ("%d\t%s\n",n[k],k);}' | $tab_sort -k 1n

# cat scripts/MAGIC | gawk -f scripts/csh.beautifier.awk >! scripts/MAGIC.beau
############################################################################################
# Master script for short sequence alignments
#  Author: mieg@ncbi.nlm.nih.gov
############################################################################################

set phaseSet="$*"
  
############################################################################################
#### utilities
## configure sort
setenv LANG C
unset noclobber

if (0 && -e /var/lib/envs/facilities/bin/fac-switch.csh) then
  source /var/lib/envs/facilities/bin/fac-switch.csh python 2.7
endif
# set the UGE (normally already done by .ncbi_hints, option sge
if (-e  /netmnt/gridengine/current/settings.csh) source /netmnt/gridengine/current/settings.csh
if (1 && -e  /netmnt/gridengine/test/settings.csh) source /netmnt/gridengine/test/settings.csh

# export current UGE version
qsub -help | head -1

# locale settings can break sort, clear LC_ALL
setenv LC_ALL C
# disable acedb banner, it clutters the logs
setenv ACEDB_NO_BANNER 1

if (! -x bin/time  && ! -x /usr/bin/time) then
  echo FATAL ERROR cannot find /usr/bin/time
  echo Sorry i cannot proceed
  exit 1
endif

if ( ! -x bin/rsync && ! -x `which rsync`) then
  echo FATAL ERROR cannot find rsync
  echo Sorry i cannot proceed
  exit 1
endif

if ( ! -x bin/tcsh && ! -x `which tcsh`) then
  echo FATAL ERROR cannot find tcsh
  echo Sorry i cannot proceed
  exit 1
endif

############################################################################################

setenv CaliRootDir `pwd`
setenv MagicRootDir `pwd`
setenv metaData `pwd`/metaData
setenv bin `pwd`/bin
setenv tacembly $bin/tacembly
setenv Verbose 0
setenv tab_sort `pwd`/scripts/tab_sort

if ($1 == ii5) goto phaseii5
if ($1 == ii5A) goto phaseii5A

setenv targets ""
if ("$1" == "verbose_help" || "$1" == "-verbose_help" || "$1" == "-vhelp") then
  setenv Verbose 1
  goto usage
endif

if ("$phaseSet" == "" || "$phaseSet" == "help"  || "$phaseSet" == "-h" || "$phaseSet" == "--h" || "$phaseSet" == "-help" || "$phaseSet" == "--help") goto usage
if ("$phaseSet" == clean) goto phaseClean
if ($1 == cleanRunList) goto phaseCleanRunList

if ($1 == wait) scripts/submit wait


if (! -e ZZZZZ || ! -e ZZZZZ.gz)  then
   echo 'ZZZZZ' > ZZZZZ
   gzip -c ZZZZZ > ZZZZZ.gz
endif

if ("$1" == init) then
  if (! $?MAGIC_SRC) then
    echo "The environment variable MAGIC_SRC, currently undefined, should point to the directory where you compiled the magic source code"
    exit 1
  endif
  if (! -d $MAGIC_SRC || ! -e $MAGIC_SRC/waligner) then
    echo 'The directory $MAGIC_SRC/waligner does not exist'
    echo "The environment variable MAGIC_SRC should point to the directory where you compiled the magic source code"
    echo '  currently $MAGIC_SRC='$MAGIC_SRC
    exit 1
  endif
  pushd  $MAGIC_SRC ; setenv MAGIC_SRC `pwd` ; popd
  if ($?ACEDB_MACHINE) then
    set MAGIC_BIN=$MAGIC_SRC/bin.$ACEDB_MACHINE
  else
    # infer from the bin.* in MAGIC_SRC if there is a single compilation directory
    setenv ici `pwd`
    pushd $MAGIC_SRC
      ls -d bin.* > $ici/_b
    popd
    set n=`cat $ici/_b | wc -l`
    if ($n == 1) then
      set MAGIC_BIN="$MAGIC_SRC/"`cat $ici/_b`
      \rm $ici/_b
    endif 
    if ($n > 1) then
      echo "FATAL ERROR: While installing MAGIC in directory $MAGIC_SRC "
      echo "You compiled for several machines"
      cat  $ici/_b | sed -e 's/bin\.//'
      echo "Please select the correct compilation by using: setenv ACEDB_MACHINE"
      echo -n  "For example: setenv ACEDB_MACHINE "
      cat  $ici/_b | gawk '{n++;if(n==1)print substr($1,5);}'
      \rm $ici/_b
      exit 1
    endif
    if ($n == 0) then
      echo "FATAL ERROR: While installing MAGIC in directory $MAGIC_SRC "
      echo "You have not yet compiled the program"
      echo "Please cd $MAGIC_SRC ; setenv ACEDB_MACHINE ... ; make -k all"
      \rm $ici/_b
      exit 1
    endif
  endif

  if ( -x scripts/MAGIC && -d MetaDB) then
    echo "The MetaDB and MAGIC already exist, run   'MAGIC clean' if you want to re-initialise"
    exit 1
  endif

  if ($2 == DNA || $2 == RNA) then
    # echo "#\!bin/tcsh -f " >! ./LIMIT
    echo >> ./LIMITS
    echo "##############################################################" >> ./LIMITS
    echo -n "## MAGIC Project created ">>  ./LIMITS
    date >> ./LIMITS
    echo "##############################################################" >> ./LIMITS
    echo "## Please edit the self documented files scripts/submit and scripts/LIMITS for optional choices of configuration"
    echo >> ./LIMITS

    echo "setenv MOLECULE_TYPE $2" >> ./LIMITS
    echo 'source scripts/LIMITS   # this will define basic default parameters' >> ./LIMITS
    echo 'source TARGET/LIMITS    # this will override the default in a species dependant way' >> ./LIMITS
     echo >> ./LIMITS

    if ($2 == RNA) echo "setenv Strategy RNA_seq" >>  ./LIMITS
    echo >> ./LIMITS
  else
    echo "missing DNA/RNA parameter: usage MAGIC init [DNA | RNA]"
    exit 1
  endif

    if (! -d tmp) mkdir tmp
    if (! -d tmp/LOGS) mkdir tmp/LOGS
    if (! -e ZZZZZ || ! -e ZZZZZ.gz)  then
      echo 'ZZZZZ' > ZZZZZ
      gzip -c ZZZZZ > ZZZZZ.gz
    endif

    ln -s $MAGIC_SRC/waligner/scripts
    ln -s $MAGIC_SRC/waligner/metaData
    ln -s $MAGIC_BIN bin
    ln -s scripts/MAGIC
    ln -s bin/tacembly tbly
    ln -s bin/xacembly bly
    if (! -d RESULTS) mkdir RESULTS
    if (! -d MetaDB) then
      mkdir MetaDB
      pushd MetaDB
        ln -s ../metaData/tables
        mkdir database
        mkdir wspec
        cd wspec
        foreach ff (`ls ../../metaData/wspec/*.wrm`)
          ln -s $ff
        end
        cd ..
        \rm wspec/passwd.wrm
        cp ../metaData/wspec/passwd.wrm wspec
        set mynam=`whoami`
        set n=`cat wspec/passwd.wrm | gawk '{if($1==mynam)n++}END{printf("%d", 0+n)}' mynam=$mynam`
        if ($n == 0) whoami >> wspec/passwd.wrm
        echo y | ../bin/tacembly . > /dev/null
      popd
    endif

  exit 0
endif

# Centromere_telomeres was downlaoded from UCSC web site in 2012
# gap database table, table browser species gap, filter-create button, type field: "centromere telomere"

############################################################################################
## Verify that we are inside an initialized project directory

if (! $?MAGIC) then
  echo 'MAGIC should be set to the project name'
  exit 0
endif

# CALI was a previous name for the variable MAGIC
# by defining CALI all legacy codes still work
setenv CALI $MAGIC > /dev/null

if (! -x bin/clipalign) then
    echo 'The executable bin/clipalign does not exist'
    echo 'You may be in the wrong directory, our you should run the command'
    echo '$MAGIC_SRC/waligner/scritps/MAGIC init [DNA | RNA]'
    exit 1
endif

if (! -e scripts/MAGIC) then
    echo 'The directory scripts does not exist'
    echo 'You may be in the wrong directory, our you should run the command'
    echo '$MAGIC_SRC/waligner/scritps/MAGIC init [DNA | RNA]'
    exit 1
endif

if (! -e TARGET/LIMITS || ! -d TARGET/Targets || ! -d TARGET/CHROMS) then
    echo "The TARGET directory, which should contains at least LIMITS, CHROMS and Targets is missing or incomplete"
    echo 'You may be in the wrong directory, our you should run the command'
    echo '$MAGIC_SRC/waligner/scritps/MAGIC init [DNA | RNA]'
  exit 1
endif

if (! -d tmp) then
  echo "The directory ./tmp where all alignments will be stored does not exist"
    echo 'You may be in the wrong directory, our you should run the command'
    echo '$MAGIC_SRC/waligner/scritps/MAGIC init [DNA | RNA]'
  exit 1
endif
if (! -d RESULTS) then
  echo "The directory RESULTS where the main results will be reported does not exist"
    echo 'You may be in the wrong directory, our you should run the command'
    echo '$MAGIC_SRC/waligner/scritps/MAGIC init [DNA | RNA]'
  exit 1
endif

setenv MetaDB `pwd`/MetaDB

if (! -d MetaDB/database) then
  echo "MetaDB does not point to the acedb MetaDataBase"
  exit 1
endif

if (! -d MetaDB/tables) then
  if (-e metaData/tables && -d MetaDB) then
    pushd MetaDB
      ln -s $CaliRootDir/metaData/tables
    popd
  endif
endif

if (! -d MetaDB/tables) then
  echo "MetaDB/tables does not exists"
  exit 1
endif

if (-e MetaDB/database/lock.wrm) then
  echo "The database MetaDB is locked"
  echo " either another version of the pipeline is writing into MetaDB, just wait and retry"
  echo " or the graphic interface to MetaDB is locking the database, please save and exit from the graphic interface"
  echo " or something went wrong and left a lock, if you are sure this is the case, then remove the file 'MetaDB/database/lock.wrm"
  exit 1
endif

if (! -e ZZZZZ || ! -e ZZZZZ.gz)  then
  echo 'ZZZZZ' > ZZZZZ
  gzip -c ZZZZZ > ZZZZZ.gz
endif

############################################################################################
## verify that we have write access

echo hello > ./.hello_world
if (! -e ./.hello_world) then
  echo "Sorry, the program does not have write access in the current directory (pwd)"
  pwd
  exit 1
endif
\rm  ./.hello_world

echo hello > tmp/.hello_world
if (! -e tmp/.hello_world) then
  echo "Sorry, the program does not have write access in the tmp directory"
  exit 1
endif
\rm  tmp/.hello_world

############################################################################################
## verify that the submit script has been configured


if (! -e scripts/submit) then
  echo "The file scripts/submit is missing, sorry"
  exit 1
endif
if (! -x scripts/submit) then
  echo "The file scripts/submit is not executable, sorry"
  exit 1
endif
set ok=`head -30 scripts/submit | gawk '/ZERO/{next}/^set/{if(index($2,"farm=")>0)n=1;}END{printf("%d",0+n);}'`
if (ok == 0) then
  if ($?MAGIC_FARM_CONFIG) then
    echo " "
  else
    # generate the scripts self diagnostic message
    scripts/submit wait
    exit 1
  endif
endif

############################################################################################
## copy the major tcsh commands to tmp 
## because on some farms /bin/tcsh is not accessible from the nodes
## we cannot copy to bin, because bin belongs to MAGIC admin which may not be writable

if (! -x bin/tcsh) cp `which tcsh` bin
if (! -x bin/rsync) cp `which rsync` bin
if (! -x bin/time) cp /usr/bin/time bin

if (! -e tables && -e metaData/tables) ln -s metaData/tables

############################################################################################
## back-compatibility

if (-d tmp/GENE_INDEX/RUNS && ! -d tmp/GENERUNS) mv tmp/GENE_INDEX/RUNS tmp/GENERUNS
if (-d tmp/GENE_INDEX/LANES && ! -d tmp/GENELANES) mv tmp/GENE_INDEX/LANES tmp/GENELANES

if (! -d tmp/GENELANES) mkdir tmp/GENELANES
if (! -d tmp/GENERUNS) mkdir tmp/GENERUNS
if (! -d tmp/GENEINDEX) mkdir tmp/GENEINDEX
if (! -d tmp/GENEINDEX/Results) mkdir tmp/GENEINDEX/Results

if (-d tmp/INTRON_INDEX/RUNS && ! -d tmp/INTRONRUNS) mv tmp/INTRON_INDEX/RUNS tmp/INTRONRUNS
if (-d tmp/INTRON_INDEX/LANES && ! -d tmp/INTRONLANES) mv tmp/INTRON_INDEX/LANES tmp/INTRONLANES

if (! -d tmp/INTRONLANES) mkdir tmp/INTRONLANES
if (! -d tmp/INTRONRUNS) mkdir tmp/INTRONRUNS
if (! -d tmp/INTRON_INDEX) mkdir tmp/INTRON_INDEX

############################################################################################
## general definitions are in scripts/LIMITS
## definition particular to the species are in TARGET/LIMITS
## but may be overridden by a local file LIMITS

echo -n "--- MAGIC start "
date
echo "=== Project $MAGIC"

setenv Strategy ZERO

source scripts/LIMITS   # this will define basic default parameters
source TARGET/LIMITS    # this will override the default in a species dependant way
echo "..... Standard configuration parameters were read in scripts/LIMITS and TARGET/LIMITS"

if (-e ./LIMITS) then
  echo "..... User specified parameters were read in  ./LIMITS"
  source ./LIMITS   # this will override the defaults in a user-project specific way
endif

if (! $?MAGIC_COUNT_DIR) setenv MAGIC_COUNT_DIR COUNT
if ($USEMAGICBLAST == 1)  setenv MAGIC_COUNT_DIR MAGICBLAST

setenv Strategy ZERO
if ($MOLECULE_TYPE == RNA) then
  setenv Strategy RNA_seq
endif
if ($MOLECULE_TYPE == DNA) then
  setenv Strategy Exome
endif
if ($Strategy == ZERO) then
  echo "The MOLECULE_TYPE is not defined as it should in ./LIMITS"
  echo "Please run 'MAGIC init [DNA | RNA]'"
  exit 1
endif

# Override  the Strategy dependent targets
if ($Strategy != RNA_seq) then
  setenv targets "$DNAtargets"
else
  setenv targets "$DNAtargets $RNAtargets"
endif
# override again the targets if they are specified in ./LIMITS
if (-e ./LIMITS) then
  source ./LIMITS   # this will override the defaults in a user-project specific way
endif
if ($MOLECULE_TYPE == DNA) then
  setenv Strategy Exome
endif
if ($MOLECULE_TYPE == RNA) then
  setenv Strategy RNA_seq
endif
setenv targets "$DNAtargets $RNAtargets"
# we renamed tweek to decoy, but some existing LIMITS file may still contain tweek
setenv targets `echo $targets | sed -e 's/tweek/decoy/'`
echo "= Strategy\n=== Species=$species\n=== MOLECULE_TYPE=$MOLECULE_TYPE\n=== Strategy=$Strategy \n=== targets=$targets \n=== RNAtargets=$RNAtargets\n=== DNAtargets=$DNAtargets\n=== Etargets=$Etargets"

# verify that rrna is among the targets
if (-e TARGET/Targets/$species.rrna.fasta.gz) then
  set ok=0
  foreach target2 ($targets)
    if (rrna == $target2) set ok=1
  end
  if ($ok == 0) then
    setenv targets "rrna $targets"
  endif
endif

# verify that all Etargets are inside RNAtargets
foreach target ($Etargets)
  set ok=0
  foreach target2 ($RNAtargets)
    if ($target == $target2) set ok=1
  end
    if ($ok == 0) then
      echo "####### CONFIGURATION ERROR ########"
      echo "        Target $target declared in Etargets is not part of RNAtargets"
      echo "        The code aligns the reads on all RNAtargets"   
      echo "        Then a higher level analysis is performed for all Etargets"
      echo "        But it would of course be impossible to analyse an Etarget on which we did not align"
      echo "        Please check and edit ./LIMITS and/or TARGET/LIMITS"
      exit 1
    endif
end

############################################################################################
## verify hat the TMPDIR has been configured in scripts/LIMITS or ~/.MAGICrc

if (! $?TMPDIR) then
  echo "FATAL CONFIGURATION ERROR"
  echo "the variable TMPDIR has not been set, please edit praragraph 4 of scripts/LIMITS"
  exit 1 
endif

if (! -d $TMPDIR) then
  echo "FATAL CONFIGURATION ERROR"
  echo "The directory TMPDIR = $TMPDIR does not exist,  please edit praragraph 4 of scripts/LIMITS"
  exit 1 
endif

touch $TMPDIR/toto.$$
if (! -e $TMPDIR/toto.$$) then
  echo "FATAL CONFIGURATION ERROR"
  echo "The directory TMPDIR = $TMPDIR is not writable"
  echo "The command touch $TMPDIR/toto.$$ failed"
  echo "Please edit praragraph 4 of scripts/LIMITS"
  exit 1 
endif
\rm $TMPDIR/toto.$$

set n=`df -P -m $TMPDIR | gawk '{z=$4}END{print z+0;}'`
if ($n < 50000) then
  echo "FATAL CONFIGURATION ERROR"
  echo "The directory TMPDIR = $TMPDIR doeas not have 50Gb free space"
  df -m $TMPDIR
  echo "Please edit praragraph 4 of scripts/LIMITS"
  exit 1 
endif
echo "..... TMPDIR = $TMPDIR is writable with $n free Mb"

############################################################################################
## Interpret the WEBSERVER paramater

if ("$1" == WEBMASTER) then
  if ($2 < 8000) then
    echo "To start a web server choose a port above 8000"
    exit 1
  endif
  if (! -e MetaDB/database/ACEDB.wrm) then
    echo "Sorry the./MetaDB directory does not exist, you must be in the wrong directory"
    exit 1
  endif
    bin/tgifacemblyserver MetaDB $2 -http &
    exit 0
endif

############################################################################################
## Interpret the parameters


cat <<EOF > _x.awk
{ z = \$0 ;

  if (Strategy == "RNA_seq") R = 1 ;    
  if (Strategy == "EXOME") X = 1 ;    
  if (Strategy == "GENOME") G = 1 ;    
  if (Strategy == "ChIP") C = 1 ;    

  qc = index(z, "QC") ;
  a0  = index(z, "MAKEFASTC") ;
  a  = index(z, "ALIGN") ;
  w  = index(z, "WIGGLE") ;
  gx = index(z, "GENE") ;
  mx = index(z, "MRNA") ;
  ix = index(z, "INTRON") ;
  # iv = index(z, "INTRON_VALIDATION") ;
  cnv = index(z, "CNV") ;
  snp  = index(z, "SNV") ;
  pA = index(z, "polyA") ;
  rr = index(z, "REARRANGEMENTS") ;
  small = index(z, "SMALL_RNA") ;
  tsnp = index(z, "TSNP") ;

  verbose = index(z, "Verbose") ;
  ph = " " ;
  if (a0 > 0) ph = ph " a0 " ;
  if (a0 > 0 && a > 0)  ph = ph " wait " ;
  if (small + a > 0) ph = ph " a0C wait a0D wait "
  if (a > 0) ph = ph " a0W wait a1W wait a123 a0P a0Ba mi3 wait a0Br a0Bua c1 c2 wsig1 vir1 mi4 wait c3 c4 c5 wsig2 vir2 wait a0Bur c6 wsig3  " ;
  if (a + small > 0) ph = ph " c7 wait "
  if (ix + gx + mx > 0) ph = ph " g1 "
  if (gx + mx > 0) ph = ph " g2a m2aH vir1 wait g2b m2bH wait g3a m3aH vir2 wait g3b m3bH wait 8kb_histo wait " ;

  if (tsnp > 0) ph = ph "tsnp0 tsnp1a " ;
  if (ix > 0) ph = ph " d1 t1 tgf1  SLpA1 wait d2 t2 tgf2 SLpA2" ;
  if (ix > 0) ph = ph " ii2a wait ii2b wait ii2c wait ii2d" ;
# d3 is obsolete
# d4 must run after ii2d twice, once per run in parallel, once to cumulate the results
  if (ix > 0) ph = ph " wait  SLpA3 d4 wait d4 " ;
  if (w > 0) ph = ph " wg1 wait wg2a wait wg2ba wait wg2bb wait wg2bb wait wg2bb wait wg2bb wait wg3a wait wg3b  wait wg4 wg4b wait  wg4c wg5 wait wg6 wg4d sponge1 wait sponge2 wait sponge3 wait " ;
# s2c (extend, must come after s3a (detect) and would influence the BRS, so we would do s1 s2a s2b s3a,  extend which would create a modified BRS file, then s3b:count
  if (cnv > 0)  ph = ph " cnv wait cnv "
  if (snp > 0) ph = ph " snp0 wait s1 wait s1A2G wait s2a wait s2b wait s2A2G wait s3a wait s3b  wait snp2a wait s10 wait s11  wait s12 wait s20 wait s21 s22 wait gsnp4 wait s13 wait s14 "   
  if (ix > 0) ph = ph " wait d5  "
  if (tsnp > 0) ph = ph "wait tsnp1b wait tsnp2a wait tsnp2b wait tsnp2c " ;
  if (iv > 0) ph = ph " wait d6 wait d7 wait d8 " ;
  if (w > 1000)       ph = ph "  g4sp " ;
  if (gx + mx > 0) ph = ph "  wait  c7 g4 " ;
  if (mx > 1000)       ph = ph "  wait  c7 m4H " ;
  if (tsnp > 0) ph = ph "wait  tsnp3" ;
  if (gx + mx > 1  )  ph = ph " g10 g11 g12a wait g12b FDR1 wait FDR2 " ;
  if (a + small + qc +gx + mx + ix + snp + w > 0) ph = ph " wait c7 "

  printf ("#!bin/tcsh -f\n") ;
  printf ("# command line was %s\n", z) ;
  if (ph != " ") printf ("set phaseSet=\"%s\"\n", ph) ;
} 
EOF

echo  "$*" > _x.param
cat _x.param  | gawk -f _x.awk Strategy=$Strategy > _x.tcsh
source _x.tcsh
\rm _x.tcsh _x.param _x.awk

if ($Strategy == "none") then
  echo "please select a strategy EXOME GENOME or RNA_seq"
  echo "Either by including one of these words on the command line"
  echo "or by including a command 'setenv Strategy xxx' in the file ./LIMITS"
  exit 1
endif

# a technicality
  ps -ux $uid |& grep bad > toto.bad
  setenv MAGIC_SUBMIT_USE_DASH `cat toto.bad | gawk '/^[Ww]arning/{n=-1}END{print n+1}'`
  \rm toto.bad

echo "..... requested phases : $phaseSet"
echo -n  "..... current directory : "
pwd
############################################################################################
## refresh the lists of Runs from the meta database

if (! -d MetaDB/$MAGIC) mkdir  MetaDB/$MAGIC
setenv MetaDB `pwd`/MetaDB

# wait before refreshing the lists if the first phase is wait
set phase=`echo $phaseSet | gawk '{print $1}'`
if ($phase == wait) then
  echo "waiting for the completion of previous tasks"
  scripts/submit wait
endif

############################################################################################
## verify that the tmp directory is available

bin/tacembly MetaDB << EOF > MetaDB/makelists.log
   query find project IS $MAGIC ; tmp_directory
  bql -o MetaDB/$MAGIC/project2tmp_directory select p,t from p in  @, t in p->tmp_directory
  quit
EOF

setenv projectDir tmp
  if (-e MetaDB/$MAGIC/project2tmp_directory) then
    setenv projectDir `cat MetaDB/$MAGIC/project2tmp_directory | gawk -F '\t' 'BEGIN{t="tmp";}{if($1 == p) t=$2;}END{print t}' p=$MAGIC`
  endif

setenv mkDir "source scripts/mkDir"
echo "-- Verify the existence of the tmp directory $projectDir"

  if (! -d $projectDir) then
     echo "..........................................................................................................."
     echo "FATAL CONFIGURATION ERROR"
     echo ".... Missing directory $projectDir declared in MetaDB as the tmp_directory of the active project $MAGIC"
     echo ".... Please cosntruct this directory on some disk"
     echo ".... You can either use an absolute disk address or establish loocally a symbolic link"
     echo ".... the recommended name pattern is tmp.$MAGIC"
     echo ".... Runs already analyzed stay where they are"
     echo ".... Runs first encountered in the project will be stored in that directory"
     echo ".... This enables to use additional distant storage and to limit the number of runs per directory to < 200"
     echo "..........................................................................................................."
     exit 1
  endif

## note on tcsh arrays
## however and array  t = run2tmp[$run] can be mimicked as follows
##     setenv run2tmp_$run xxx
##     set t=`eval echo \$run2tmp_$run`
##     echo $t   --> recovers xxx

############################################################################################


if ($?MAGIC_jump) then
  if ($MAGIC_jump == 1) goto plusbas
endif


touch MetaDB/$MAGIC/_t
\rm  MetaDB/$MAGIC/*

echo "-- Scan the meta-database "
echo "--- update the schema"
bin/tacembly MetaDB << EOF > MetaDB/makelists.log
  read-models
  query find project IS  $MAGIC 
  bql  -a -o MetaDB/$MAGIC/compare_runs.txt select c,x,r from p in @, c in p->compare, r in c->runs, x in r[1]
  save
  quit
EOF

if (-e MetaDB/$MAGIC/compare_runs.txt) then
  cat MetaDB/$MAGIC/compare_runs.txt | gawk -F '\t' '{if ($1 != old) printf ("\nCompare %s\n-D Runs\n", $1);old=$1;printf("Runs %s %d\n",$3,$2);}END{printf("\n");}' > MetaDB/$MAGIC/compare_runs.ace
  echo "pparse MetaDB/$MAGIC/compare_runs.ace" |  bin/tacembly MetaDB -noprompt
endif

echo "--- check the group hierarchy"
if (-e tmp/COUNT) then
  bin/bestali -checkGroupHierarchy -project $MAGIC -db MetaDB
  if ($status > 0) exit 1
endif
echo "--- export lists of runs and groups in the MetaDB/$MAGIC directory"
## create the lists summarizing the properties of the runs
## do this each time to be certain to be in synch with the MetaDB
##   we construct a bunch of lists, including but not limited to: 
##   RunForwardList  RunNonStrandedList RunReverseList RunSolidList  RunRnaList
bin/tacembly MetaDB << EOF > MetaDB/makelists.log
  comment magic_list 1
  query find project IS $MAGIC ; >run ;  sublibrary_of
  spush
  query find project IS $MAGIC ; > run ; sublibraries ; >sublibraries 
  kstore ks1
  sminus
  spop
  comment magic_list 2
  edit -D project $MAGIC
  query find project IS  $MAGIC ; >run ; >sublibraries ; ! project ==   $MAGIC
  edit project $MAGIC
  comment magic_list 3
  save
  comment magic_list 4
  query find project IS $MAGIC ; > run ; Union_of
  show -a -f MetaDB/$MAGIC/groups.ace
  query find project IS $MAGIC ; > run ; CLASS run
  show -a -f MetaDB/$MAGIC/runs.ace
  follow sample
  show -a -f MetaDB/$MAGIC/samples.ace
  query find project IS  $MAGIC ; >run ; >ali
  kstore ksAli
  comment magic_list 5
  show -a -f MetaDB/$MAGIC/ali.ace
  comment magic_list 5b
  query Counts && Length_distribution_1_5_50_91_99_mode_av  ; > run ; Is_run 
  spush
  query find project IS $MAGIC ; > run ; Is_run 
  comment magic_list 6
  swap
  sminus
  spop
  list -a -f MetaDB/$MAGIC/RunNoCount.list
  comment magic_list 6b
  kget ksAli
  spush
  query find projec IS $MAGIC ; > run ; Private ; > ali
  sminus
  spop
  comment magic_list 7
  table -active -o  MetaDB/$MAGIC/Error_type.txt -f tables/Error_type.def

  query find  project IS $MAGIC ; >compare
  show -a -f MetaDB/$MAGIC/compares.ace
  query find project IS $MAGIC ; >run
  // bql -o MetaDB/$MAGIC/_q1 select run,format,file,group,apply,machine,title,typ,sample from run in @, format in run->File, file in format[1], group in run->group where !group  || group->project=="$MAGIC", typ in run->type, apply in run->Apply, machine in run->machine, title in run->title, sample in run->sample 
  bql -a -o MetaDB/$MAGIC/_q1 select run,format,file,group,apply,machine,title,typ,sample from run in @, format in run->File, file in format[1], group in run->group, typ in run->type, apply in run->Apply, machine in run->machine, title in run->title, sample in run->sample
  query find project IS $MAGIC ; > run ; tmp_directory
  bql -o MetaDB/$MAGIC/run2tmp_directory select run,t from run in  @, t in run->tmp_directory
  comment magic_list 8
  query find project IS $MAGIC ; > Run  Is_run
  list -a -f MetaDB/$MAGIC/Run.list
  query find project IS $MAGIC ; > Run  ; CLASS runs
  list -a -f MetaDB/$MAGIC/Runs.list
  query find project IS $MAGIC ; > Run  ; Private
  list -a -f MetaDB/$MAGIC/RunPrivate.list
  query find project IS $MAGIC ; > Run  ; RNA_Spiked_In == "Sequin*"
  list -a -f MetaDB/$MAGIC/RunSequin.list
  query find project IS $MAGIC ; > run ;  Adaptor1 || Adaptor2
  list -a -f MetaDB/$MAGIC/RunWithKnownAdaptors.list
  query find project IS $MAGIC ; > Run  ; Sublibraries
  list -a -f MetaDB/$MAGIC/RunHasSubLib.list
  query find project IS $MAGIC ; > Run  ; Is_run && Sublibrary_of
  list -a -f MetaDB/$MAGIC/RunSublibrary_of.list
  query find project IS $MAGIC ; > Run  ; NOT Private 
  list -a -f MetaDB/$MAGIC/RunPublic.list
  query find project IS $MAGIC ; > Run  ; Is_group
  list -a -f MetaDB/$MAGIC/Group.list
  comment magic_list 9
  query find project IS $MAGIC ; > Run  ; de_duo  // Is_run  OR Is_group
  list -a -f MetaDB/$MAGIC/GroupDeDuo.list
  query find project IS $MAGIC ; > Run  ; Gene_element_index
  list -a -f MetaDB/$MAGIC/GroupGene_element_index.list
  query find project IS $MAGIC ; > Run ; UCSC
  list -a -f MetaDB/$MAGIC/UcscWiggle.list
  comment magic_list 10 
  query find project IS $MAGIC ; > Run  ; UCSC && ! Wiggle
  edit Wiggle
  query find project IS $MAGIC ; > Run  ;Wiggle && (Is_group || sublibraries)
  list -a -f MetaDB/$MAGIC/GroupWiggle.list
  query find project IS $MAGIC ; > Run  ;Wiggle && Is_run
  list -a -f MetaDB/$MAGIC/RunWiggle.list
  query find project IS $MAGIC ; > Run  ;W_stranded  // Is_run  OR Is_group
  list -a -f MetaDB/$MAGIC/GroupW_stranded.list
  comment magic_list 11
  query find project IS $MAGIC ; > Run  ;W_new_exon  // Is_run  OR Is_group
  list -a -f MetaDB/$MAGIC/GroupW_new_exon.list
  query find project IS $MAGIC ; > Run  ;SNP && Is_group   //
  list -a -f MetaDB/$MAGIC/GroupSnp.list
  query find project IS $MAGIC ; > Run  ;Is_group  && Add_counts //
  list -a -f MetaDB/$MAGIC/GroupAdditive.list
  query find project IS $MAGIC ; > Run  ;Is_group ; (Add_counts && SNP) OR SNP_add_counts //
  list -a -f MetaDB/$MAGIC/GroupSnpAdditive.list
  query find project IS $MAGIC ; > Run  ; ! Private && ! Sublibrary && Is_run     //
  list -a -f MetaDB/$MAGIC/RunSnp.list
  query find project IS $MAGIC ; > Run  ;RunId
  show -a -f  MetaDB/$MAGIC/Run2RunId.ace RunId
  query find project IS $MAGIC ; > Run  ; RNA && Is_run
  list -a -f MetaDB/$MAGIC/RunRna.list
  query find project IS $MAGIC ; > Run  ; Variance && Is_group
  list -a -f MetaDB/$MAGIC/GroupVariance.list
  query find project IS $MAGIC ; > Run  ; Intron && Is_group
  list -a -f MetaDB/$MAGIC/GroupIntron.list
  query find project IS $MAGIC ; > Run  ; Intron ; CLASS runs
  list -a -f MetaDB/$MAGIC/RunsIntron.list
  query find project IS $MAGIC ; > Run  ; Transloc && Is_group
  list -a -f MetaDB/$MAGIC/GroupTransloc.list

  query find project IS $MAGIC ; > Run  ; is_Run // always computed for runs
  bql -a -o MetaDB/$MAGIC/run2machine2adaptors.txt select r,m,a1,a2,aa1,aa2,e1 from r in @, m in r->machine, a1 in r->adaptor1, a2 in r->adaptor2, ali in r->ali, aa1 in ali->adaptor1, aa2 in ali->adaptor2, e1 in r->Entry_adaptor
 
  query find project IS $MAGIC ; > Run  ;Is_run && (nonStranded OR NOT (Forward OR Reverse)) 
  list -a -f MetaDB/$MAGIC/RunNonStranded.list
  query find project IS $MAGIC ; > Run  ;Is_run && Forward 
  list -a -f MetaDB/$MAGIC/RunForward.list
  query find project IS $MAGIC ; > Run  ; Is_run && Reverse
  list -a -f MetaDB/$MAGIC/RunReverse.list
  query find project IS $MAGIC ; > Run  ; small_RNA   // we need to refine this query
  list -a -f MetaDB/$MAGIC/RunSmallRna.list
  comment magic_list 12

  query find project IS $MAGIC ; > Run  ;COUNT Sample == 1 && COUNT {>sample single_individual} == 1  
  list -a -f MetaDB/$MAGIC/RunSingleIndividual.list
  query find run Union_of AND Solid AND COUNT {>Union_of ; NOT Solid} > 0
  edit -D Solid
  query find run Sublibraries AND Solid AND COUNT {>Sublibraries ; NOT Solid} > 0
  edit -D Solid
  query find project IS $MAGIC ; > Run  ;Is_run AND NOT Solid AND (File == csfasta* OR File == csfastq*) 
  edit Solid
  comment magic_list 13
  query find project IS $MAGIC ; > Run  ;Is_run AND NOT Solid AND COUNT {>Union_of ; Solid} > 0 && COUNT {>Union_of ; NOT Solid} == 0 
  edit Solid 
  query find project IS $MAGIC ; > Run  ;sublibraries AND NOT Solid AND COUNT {>Sublibraries ; Solid} > 0 && COUNT {>Sublibraries ; NOT Solid} == 0 
  edit Solid 
  query find run Union_of AND COUNT {>Union_of ; Solid} > 0 && COUNT {>Union_of ; NOT Solid} == 0 AND  project == $MAGIC 
  edit Solid  // do it 3 times to catch the higher up additive groups
  query find project IS $MAGIC ; > Run  ; Union_of AND COUNT {>Union_of ; Solid} > 0 && COUNT {>Union_of ; NOT Solid} == 0 
  edit Solid
  query find project IS $MAGIC ; > Run  ;  Union_of AND COUNT {>Union_of ; Solid} > 0 && COUNT {>Union_of ; NOT Solid} == 0 
  edit Solid
  query find project IS $MAGIC ; > Run  ;SOLiD  
  list -a -f MetaDB/$MAGIC/RunSolid.list
  query find project IS $MAGIC ; > Run  ; Nanopore ||  Oxford_nanopore
  list -a -f MetaDB/$MAGIC/RunNanopore.list
  query find project IS $MAGIC ; > Run  ; PacBio
  list -a -f MetaDB/$MAGIC/RunPacBio.list
  // query find run ! paired_end && file:1 == "*/1" && file:1 == "*/2"
  // edit paired_end 
  query find run Is_run AND  NOT single_end AND NOT paired_end AND project == $MAGIC && (file:1 == "*/1" && file:1 == "*/2")
  edit paired_end
  query find run paired_end AND project == $MAGIC
  list -a -f MetaDB/$MAGIC/RunPaired.list
  comment magic_list 14
  query find run Is_run AND  NOT single_end AND NOT paired_end AND project == $MAGIC && COUNT file < 2
  edit Single_end
  query find project IS $MAGIC ; > Run  ; Is_run && SRR
  bql -o MetaDB/$MAGIC/Run2Srr.txt select r,srr from r in @, srr in r->SRR
  query find project IS $MAGIC ; > Run  ; 
  bql   -a -o MetaDB/$MAGIC/gtitle.pretxt  select r,m,sa,sy,ti,tt,sy2,rid,m2,stt_again,stt,stt2,ott from r in @, tt in r->title, stt in r->sorting_title,stt2 in r->sorting_title_2, ott in r->other_title, sa in r->sample, ti in sa->tissue, m in r->machine, sy in sa->systm, sy2 in sy[1], rid in r->runid,m2 in m[1],stt_again in r->sorting_title
  kget ksAli
  bql -a -o MetaDB/$MAGIC/runAligned.txt  select a,n,kb   from a in @,  h in a->h_ali where h == "any", n in h[3],kb in h[5]
  comment magic_list 15
  query find project IS $MAGIC ; > Run  ; IS_run && IS_group 
  list -a -f MetaDB/$MAGIC/RunGroupError.list
  query find Compare project == $MAGIC AND COUNT Runs == 2
  bql -a -o MetaDB/$MAGIC/ccc.txt  select e,x,r from e in @, r in e->runs, x in r[1]
  query find Compare project == $MAGIC AND COUNT Runs == 2
  bql -o MetaDB/$MAGIC/ccc_pair.txt select e,x,r from e in @, r in e->runs, x in r[1] 

  // table -o MetaDB/$MAGIC/g2r.pre -f tables/s3.group2runs.def $MAGIC
  bql -o MetaDB/$MAGIC/g2r select g,r,d from p in class project where p == $MAGIC, g in p->run, r in g->union_of where r->project == $MAGIC, d in g->group_level
  bql -o MetaDB/$MAGIC/r2sublib select r,s from p in class project where p == $MAGIC, r in p->run, s in r->sublibraries where s

  comment magic_list 16
  query find project IS $MAGIC ; > Run  ; CLASS Runs && sorting_title
  bql -a -o MetaDB/$MAGIC/RunListSorted1 select r,s from r in @, s in r->sorting_title order_by 2
  query find project IS $MAGIC ; > Run  ; CLASS Runs && NOT sorting_title
  bql -a -o MetaDB/$MAGIC/RunListSorted2 select r from r in @ 
  query find project IS $MAGIC ; > Run  ; Union_of && sorting_title
  bql -a -o MetaDB/$MAGIC/GroupListSorted1 select r,s from r in @, s in r->sorting_title order_by 2
  query find project IS $MAGIC ; > Run  ; Union_of && ! sorting_title
  bql -a -o MetaDB/$MAGIC/GroupListSorted2 select r from r in @
  query find project IS $MAGIC ; > Run
  bql -a -o MetaDB/$MAGIC/Run2Title.txt select r,s,t from r in @, t in r->title, s in r->sorting_title order_by s
  query find project IS $MAGIC ; > Run  ; file
  select -o  MetaDB/$MAGIC/run2file_name.txt r,f1,f2 from r in @, f1 in r->file, f2 in f1[1]
  comment magic_list 18
  save
  quit
EOF

## clean up the bql output
cat   MetaDB/$MAGIC/RunListSorted[12] | gawk '{gsub(/\"/,"",$0);print $1;}' > MetaDB/$MAGIC/RunListSorted
cat   MetaDB/$MAGIC/GroupListSorted[12] | gawk '{gsub(/\"/,"",$0);print $1;}' > MetaDB/$MAGIC/GroupListSorted

cat  MetaDB/$MAGIC/gtitle.pretxt | gawk -F '\t' '{printf("%s",$1);for (i=2;i<=NF;i++){j = index($i,"\"");printf("\t%s",substr($i,j));}printf("\n");}' >    MetaDB/$MAGIC/gtitle.txt

# touch  MetaDB/$MAGIC/g2r.pre 
# create the run<->sublibrary correspondance 
# cat  MetaDB/$MAGIC/g2r.pre | gawk '/^"/{gsub (/\"/,"",$0);printf ("%s\t%s\n",$1,$3);}' | grep -v NULL | $tab_sort -u | gawk '/^\//{next;}{if($2!="")print;}' > MetaDB/$MAGIC/r2sublib
# create the group<->runs correspondance 
# cat  MetaDB/$MAGIC/g2r.pre | gawk '/^"/{gsub (/\"/,"",$0);printf ("%s\t%s\t%s\n",$1,$2,$4);}' | grep -v NULL | $tab_sort -u | gawk '/^\//{next;}{if($2!="")print;}' > MetaDB/$MAGIC/g2r
touch MetaDB/$MAGIC/g2r MetaDB/$MAGIC/r2sublib 

## clean up the lists (acedb exports "" around the names)
foreach ff (Run Runs RunNoCount Group GroupDeDuo GroupSnp  GroupAdditive GroupSnpAdditive GroupWiggle GroupW_stranded  GroupW_new_exon GroupGene_element_index RunRna RunNonStranded RunForward RunReverse RunSolid RunNanopore RunPacBio RunSingleIndividual RunPaired RunSnp RunSmallRna RunPrivate RunPublic RunSequin RunWiggle GroupVariance GroupIntron RunsIntron GroupTransloc UcscWiggle RunHasSubLib RunSublibrary_of RunWithKnownAdaptors)
# create even the empty lists, because most scrits/* use constructs like
# cat XxxList, is XxxList is missing, there would be an error and since we execute  tcsh -e, the whole script would fail
  touch  MetaDB/$MAGIC/$ff.list 
  cat MetaDB/$MAGIC/$ff.list | gawk '/^Run/{gsub (/\\\//,"/",$2); gsub (/\"/,"",$2); print $2 ; }'  > MetaDB/$MAGIC/$ff'List' 
  touch MetaDB/$MAGIC/$ff'List'
  \rm MetaDB/$MAGIC/$ff.list
end 

if (-e  MetaDB/$MAGIC/run2file_name.txt) then
  set toto=RESULTS/$MAGIC.run2file_name.txt
  echo -n "# " > $toto
  date >> $toto
  echo "# Table of correspondance between the group identifiers used in magic and the original fastq file names" >> $toto 
  echo "# Group\tOriginal file names" >> $toto 
  cat  MetaDB/$MAGIC/run2file_name.txt >> $toto
endif

  foreach run (`cat MetaDB/$MAGIC/RunList`)
    if (! -d Fastc/$run) then
      set n=`ls -d Fastc.*/$run | gawk '{n++}END{print n}'`
      if ($n == 1) then
        set f=`ls -d Fastc.*/$run`
        ln -s ../$f Fastc/$run
      endif
    endif
  end

echo -n "\n-- Construct the lists of Runs and Groups "

# create the group runid correspondance
cat MetaDB/$MAGIC/gtitle.txt ZZZZZ  MetaDB/$MAGIC/g2r ZZZZZ MetaDB/$MAGIC/RunList | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{gsub(/\"/,"",$0);gsub(/\\/,"",$0);if(zz<1){r=$1;rid[r]=$8;next;}g=$1;r=$2;isg[g]=2;if(zz==2){r=g;isg[g]=1;}u=r;if(rid[r])u=rid[r];gid[g] = gid[g] "," u ;}END{for(g in gid)print isg[g] "\t" g "\t" substr(gid[g],2);}' | $tab_sort | cut -f 2,3 > MetaDB/$MAGIC/runs2runid.txt
cat MetaDB/$MAGIC/gtitle.txt ZZZZZ  MetaDB/$MAGIC/g2r | gawk -F '\t' '/^#/{next;}/^\//{next;}/^ZZZZZ/{zz++;next;}{gsub(/\"/,"",$0);gsub(/\\/,"",$0);if(zz<1){r=$1;rid[r]=$8;next;}g=$1;r=$2;isg[g]=2;if(zz==2){r=g;isg[g]=1;}u=r;if(rid[r])u=rid[r];gid[g] = gid[g] "," u ;}END{for(g in gid)if(length(g)>0)printf("Run %s\nRunId \"%s\"\n\n",g, substr(gid[g],2));}' > MetaDB/$MAGIC/groups2runid.ace

cat   MetaDB/$MAGIC/RunsList ZZZZZ MetaDB/$MAGIC/RunListSorted | gawk '/^ZZZZZ/{zz++;}{if(zz<1){ok[$1]=1;next;}if(ok[$1]==1)print;}' >  MetaDB/$MAGIC/RunsListSorted 
cat  MetaDB/$MAGIC/RunsListSorted  MetaDB/$MAGIC/GroupListSorted  > MetaDB/$MAGIC/GroupsRunsListSorted 

if (-e MetaDB/$MAGIC/RunGroupError.list) then
   echo "FATAL ERROR: the following runs are at the same time Is_run and Is_group, this is an error in the manual edition of the database, please fix the following runs"
   cat MetaDB/$MAGIC/RunGroupError.list
endif

# verify the the Compare class always gives the ordering of the runs
if (-e  MetaDB/$MAGIC/compares.ace) then
  mv MetaDB/$MAGIC/compares.ace MetaDB/$MAGIC/compares.preace
  cat MetaDB/$MAGIC/compares.preace | gawk '/^Compare/{nn=0;}/^Runs/{nn++;if ($3 + 0 == 0)$3=nn;}{print}' > MetaDB/$MAGIC/compares.ace
  echo "ok" >  MetaDB/$MAGIC/compares.err
  cat MetaDB/$MAGIC/compares.ace | gawk '/^Compare/{cc=$2;}/^Runs/{n++;run=$2;x=$3;baddy=0;if(NF < 3)baddy="missing";else if(0+$3==0)baddy="null";if(0+$3<0)baddy="negative";if(ccc[cc,x]==1)baddy="repeated";if(baddy!=0){bad=1;printf ("\nFATAL ERROR \n    Compare %s\n    Runs %s <%s integer>\n----In Compare objects, you must specify the order by giving for each run a distinct positive integer\n",cc,run,baddy);}ccc[cc,x]=1;}' >> MetaDB/$MAGIC/compares.err
  set n=`cat MetaDB/$MAGIC/compares.err | grep FATAL | wc -l`
  if ($n > 0) then
    cat  MetaDB/$MAGIC/compares.err
    exit 1 
  endif
endif

# cleanup the list of pair comparisons used in phase g10 g11
cat  MetaDB/$MAGIC/ccc.txt      | gawk '{gsub(/\"/,"",$0);n++;if(n%2==0 && $1==oldcc)printf("%s,%s,%s\n",$1,old,$3);old=$3;oldcc=$1;}' > MetaDB/$MAGIC/ccc.list
\rm  MetaDB/$MAGIC/ccc.txt
cat  MetaDB/$MAGIC/ccc_pair.txt | gawk '{gsub(/\"/,"",$0);n++;if(n%2==0 && $1==oldcc)printf("%s,%s,%s\n",$1,old,$3);old=$3;oldcc=$1;}' > MetaDB/$MAGIC/ccc_pair.list
\rm  MetaDB/$MAGIC/ccc_pair.txt

# adaptators
mv MetaDB/$MAGIC/run2machine2adaptors.txt MetaDB/$MAGIC/run2machine2adaptors.txt.$$
cat MetaDB/$MAGIC/run2machine2adaptors.txt.$$ | sed -e 's/\"//g' > MetaDB/$MAGIC/run2machine2adaptors.txt
\rm  MetaDB/$MAGIC/run2machine2adaptors.txt.$$

echo -n "---- Project $MAGIC "
cat MetaDB/$MAGIC/RunList ZZZZZ MetaDB/$MAGIC/GroupList | gawk '/^ZZZZZ/{zz=1;next;}{n[0+zz]++}END{printf("   %d runs, %d groups of runs\n", n[0],n[1]) ; }'

# MetaDB/$MAGIC/_q1 MetaDB/$MAGIC/_q2 are presumed obsolete but still used in pieces of the code
# clean up the names
cat MetaDB/$MAGIC/_q1 | gawk '/^\"/{gsub (/\\\//,"/",$0); gsub (/\"/,"",$0); gsub (/\?/,"",$0); print}'  > MetaDB/$MAGIC/_q2
# construct the list of runs and lanes
# cat MetaDB/$MAGIC/Run2Title.txt | gawk -F '\t' '{gsub(/\"/,"",$0);printf("%s#@#%s\n", $1,$3)}'  > MetaDB/$MAGIC/RunTitleList


plusbas:

############################################################################################
## Loop on all phases

set nMakeLaneList=0
set firstPhase=1
foreach  phase ($phaseSet)

echo -n "=== phase $phase start "
date
cd $CaliRootDir

if ($phase == init) goto phaseinit

if ($phase == wait) goto phaseWait

if ($phase == SRR) goto phaseSRR
if ($phase == a0) goto phasea0

### verify once the metadata

if ($firstPhase == 1) scripts/metadata.tcsh

set firstPhase=0
if (! -e  tmp/METADATA/metadata.ok) then
  echo "FATAL ERROR scripts/metadata.tcsh reported an error. the TARGET data are incomplete"
  echo
  exit 1
endif
### metadata verified

if ($nMakeLaneList == 0) then
  set nMakeLaneList=1
## create the list of Lanes, 
## because Runs may contain very large number of reads, they are split into
## lanes of maneageable size (we recommend 250Mbases per lane for an 8Gbytes machine)
## The lanes are processed in parallel. Results are then merged back in runs
## before the Reports except for the job-statistics reports which deals with
## individial processes exit codes, CPU and RAM requirements

#  cat MetaDB/$MAGIC/RunList ZZZZZ MetaDB/$MAGIC/GroupList | gawk '/^ZZZZZ/{zz=1;next;}{n[0+zz]++}END{printf("   done   %d runs, %d groups of runs\n", n[0],n[1]) ; }'

if (! -e AliArchived) then
  echo "-- Construct the list of jobs, ordered by decreasing size"

  if (-e MetaDB/$MAGIC/RunLaneCount) \rm MetaDB/$MAGIC/RunLaneCount
  foreach run (`cat MetaDB/$MAGIC/RunList`)
    if (-e Fastc/$run/f2.1.fastc.gz && ! -e Fastc/$run/LaneList) then
      ls Fastc/$run/*.fastc.gz | sed -e 's/\.fastc\.gz//' -e 's/Fastc\///' >  Fastc/$run/LaneList
    endif
    if (-e Fastc/$run/LaneList) then
       wc Fastc/$run/LaneList | gawk '{if (0+$1 > 0)printf("%s\t%d\n",run,$1);}' run=$run >> MetaDB/$MAGIC/RunLaneCount
    endif
  end
  touch  MetaDB/$MAGIC/RunList
  if (-e MetaDB/$MAGIC/RunLaneCount) then 
    sort -k 2nr MetaDB/$MAGIC/RunLaneCount | cut -f 1 >  MetaDB/$MAGIC/RunList
  endif

  echo -n "" > MetaDB/$MAGIC/LaneList
  foreach run (`cat MetaDB/$MAGIC/RunList`)
    cat Fastc/$run/LaneList >> MetaDB/$MAGIC/LaneList
  end
  set nRun=`cat MetaDB/$MAGIC/RunList | wc | gawk '{print $1}'`
  cat MetaDB/$MAGIC/LaneList | gawk '{n++}END{printf("--- the %d runs or sublibraries are split in %d blobs of at most %d Mb or %dM reads\n", nRun, n, splitMb, splitMs/1000000) ; }' nRun=$nRun splitMb=$splitMb  splitMs=$splitMs

endif

endif # nMakeLaneList == 0

\cp MetaDB/$MAGIC/RunList MetaDB/RunList
\cp MetaDB/$MAGIC/LaneList MetaDB/LaneList

if ($phase == createMitoTestSet) goto phasecreateMitoTestSet
if ($phase == createRNATestSet) goto phasecreateRNATestSet
if ($phase == createGenomicTestSet) goto phasecreateGenomicTestSet

set n=`cat MetaDB/$MAGIC/RunList MetaDB/$MAGIC/GroupList | wc | gawk '{print $1}'`
if ($n < 1) then 
  echo "\nERROR: No run in MetaDB has the tag: project $MAGIC"
  echo "       Please edit the MetaDB database and/or setenv MAGIC to a correct value"
  exit 1
endif
if ($phase == a0C) goto phasea0C
if ($phase == a0D) goto phasea0D
if ($phase == a0P) goto phasea0P
if ($phase == a0W) goto phasea0W
if ($phase == a1W) goto phasea1W

if ($phase == a0Ba) goto phasea0Ba
if ($phase == a0Br) goto phasea0Br
if ($phase == a0Bm) goto phasea0Bm
if ($phase == a0Bua) goto phasea0Bua
if ($phase == a0Bur) goto phasea0Bur
if ($phase == a0S) goto phasea0S
if ($phase == a123) goto phasea123

if ($phase == ali_clean_up) goto phaseali_clean_up

# NTM 25/03/2013: phasea4 is obsolete, goto stays as a place holder
if ($phase == a3) goto phasea3
if ($phase == a5) goto phasea5
if ($phase == a6) goto phasea6

if ($phase == p1) goto phasep1
if ($phase == p2) goto phasep2
if ($phase == p3) goto phasep3
if ($phase == p4) goto phasep4
if ($phase == p5) goto phasep5

if ($phase == r2g1) goto phaser2g1
if ($phase == r2g4) goto phaser2g4

if ($phase == c1) goto phasec1
if ($phase == c2) goto phasec2
if ($phase == c2hack) goto phasec2hack
if ($phase == c3) goto phasec3
if ($phase == c4) goto phasec4
if ($phase == c5) goto phasec5
if ($phase == c6) goto phasec6
if ($phase == c5v) goto phasec5v
if ($phase == c7) goto phaseqc
if ($phase == qc) goto phaseqc

if ($phase == ma1) goto phasema1
if ($phase == ma2) goto phasema2
if ($phase == ma3) goto phasema3


if ($phase == wg1) goto phasewg1
if ($phase == wg2a) goto phasewg2a
if ($phase == wg2ba) goto phasewg2ba
if ($phase == wg2bb) goto phasewg2bb
if ($phase == wg2bm) goto phasewg2bm
if ($phase == wg3a) goto phasewg3a
if ($phase == wg3b) goto phasewg3b
if ($phase == wg4) goto phasewg4
if ($phase == wg4b) goto phasewg4b
if ($phase == wg4c) goto phasewg4c
if ($phase == wg4d) goto phasewg4d
if ($phase == wg5) goto phasewg5
if ($phase == wg6) goto phasewg6
if ($phase == wg7) goto phasewg7
if ($phase == wgh) goto phasewgh
if ($phase == cnv) goto phasecnv
if ($phase == sponge1) goto phasesponge1
if ($phase == sponge2) goto phasesponge2
if ($phase == sponge3) goto phasesponge3
if ($phase == wsig1) goto phasewsig1
if ($phase == wsig2) goto phasewsig2
if ($phase == wsig3) goto phasewsig3
if ($phase == wm1) goto phasewm1
if ($phase == wm2) goto phasewm2
if ($phase == wm3) goto phasewm3
if ($phase == wm1H) goto phasewm1H
if ($phase == wm2H) goto phasewm2H
if ($phase == wm3H) goto phasewm3H
if ($phase == wpA) goto phasewpA
if ($phase == wmito1) goto phasewmito1
if ($phase == wmito2) goto phasewmito2
if ($phase == wmitopA1) goto phasewmitopA1
if ($phase == wmitopA2) goto phasewmitopA2

if ($phase == SLpA1) goto phaseSLpA1
if ($phase == SLpA2) goto phaseSLpA2
if ($phase == SLpA3) goto phaseSLpA3

if ($phase == d0) goto phased0
if ($phase == d1) goto phased1
if ($phase == d2) goto phased2
if ($phase == d3) goto phased3
if ($phase == d4) goto phased4
if ($phase == d4SL) goto phased4SL
if ($phase == d4SLs) goto phased4SLs 
if ($phase == d4SLc) goto phased4SLc
if ($phase == d5) goto phased5
if ($phase == d6) goto phased6
if ($phase == d7) goto phased7
if ($phase == d8) goto phased8

if ($phase == f0) goto phasef0
if ($phase == f1) goto phasef1
if ($phase == f2) goto phasef2
if ($phase == f3) goto phasef3
if ($phase == f4) goto phasef4
if ($phase == f5) goto phasef5
if ($phase == f6) goto phasef6

if ($phase == k1) goto phasek1
if ($phase == k2) goto phasek2
if ($phase == k9) goto phasek9

if ($phase == ff1) goto phaseff1
if ($phase == ff5) goto phaseff5

if ($phase == g1) goto phaseg1
if ($phase == m2a) goto phasem2a
if ($phase == m2b) goto phasem2b
if ($phase == m2aH) goto phasem2aH
if ($phase == m2bH) goto phasem2bH
if ($phase == g2a) goto phaseg2a
if ($phase == g2b) goto phaseg2b
if ($phase == g3a) goto phaseg3a
if ($phase == g3b) goto phaseg3b
if ($phase == m3a) goto phasem3a
if ($phase == m3aH) goto phasem3aH
if ($phase == m3b) goto phasem3b
if ($phase == m3bH) goto phasem3bH
if ($phase == g4) goto phaseg4
if ($phase == g4sp) goto phaseg4sp
if ($phase == g4spx) goto phaseg4spx
if ($phase == ma4) goto phasema4
if ($phase == m4) goto phasem4
if ($phase == 8kb_histo) goto phase8kb_histo
if ($phase == m4H) goto phasem4H
if ($phase == snp4) goto phasesnp4
if ($phase == gsnp4) goto phasegsnp4
if ($phase == g5) goto phaseg5
if ($phase == g6) goto phaseg6
if ($phase == g7) goto phaseg7
if ($phase == g8) goto phaseg8

if ($phase == g10) goto phaseg10
if ($phase == g11) goto phaseg11
if ($phase == g12a) goto phaseg12a
if ($phase == g12b) goto phaseg12b

if ($phase == klst0) goto phaseklst0
if ($phase == klst1) goto phaseklst1
if ($phase == klst2) goto phaseklst2
if ($phase == klst4) goto phaseklst4


if ($phase == SF1) goto phaseSF1
if ($phase == SF2) goto phaseSF2
if ($phase == SF24A) goto phaseSF4
if ($phase == SF24B) goto phaseSF4
if ($phase == SF31A) goto phaseSF4
if ($phase == SF31B) goto phaseSF4

if ($phase == FDR1) goto phaseFDR1
if ($phase == FDR2) goto phaseFDR2

if ($phase == ii2a) goto phaseii2a
if ($phase == ii2b) goto phaseii2b
if ($phase == ii2c) goto phaseii2c
if ($phase == ii2d) goto phaseii2d
if ($phase == ii3a) goto phaseii3a
if ($phase == ii3b) goto phaseii3b
if ($phase == ii4) goto phaseii4
if ($phase == ii5) goto phaseii5
if ($phase == ii6) goto phaseii6

# snp system with construction of the group wiggles
if ($phase == snp0) goto phaseSnp0
if ($phase == tsnp0) goto phaseTSnp0
if ($phase == tsnp1a) goto phaseTSnp1a
if ($phase == tsnp1b) goto phaseTSnp1b
if ($phase == tsnp1M) goto phaseTSnp1M
if ($phase == tsnp2a) goto phaseTSnp2a
if ($phase == tsnp2b) goto phaseTSnp2b
if ($phase == tsnp2c) goto phaseTSnp2c
if ($phase == tsnp3) goto phaseTSnp3

if ($phase == t1) goto phaset1
if ($phase == t2) goto phaset2

if ($phase == tgf1) goto phasetgf1
if ($phase == tgf2) goto phasetgf2

if ($phase == s1) goto phases1
if ($phase == s1A2G) goto phases1A2G
if ($phase == s2A2G) goto phases2A2G
if ($phase == s1c) goto phases1c
if ($phase == s2a) goto phases2a
if ($phase == s2b) goto phases2b
if ($phase == s2am) goto phases2a
if ($phase == s2bm) goto phases2b
if ($phase == s3a) goto phases3a
if ($phase == s3b) goto phases3b
if ($phase == s3am) goto phases3a
if ($phase == s3bm) goto phases3b

if ($phase == s2c) goto phases2c
if ($phase == snp2a) goto phasesnp2a
if ($phase == s10) goto phases10
if ($phase == s11) goto phases11
if ($phase == s12) goto phases12
if ($phase == s13) goto phases13
if ($phase == s14) goto phases14
if ($phase == s15) goto phases15

if ($phase == s20) goto phases20
if ($phase == s21) goto phases21
if ($phase == s22) goto phases22

if ($phase == vir1) goto phaseVir1
if ($phase == vir2) goto phaseVir2
if ($phase == vir3) goto phaseVir3

# old snp system
if ($phase == s3) goto phases3
if ($phase == s4) goto phases4
if ($phase == s4a) goto phases4a
if ($phase == s5) goto phases5
if ($phase == s6) goto phases6

if ($phase == est1) goto phaseest1

if ($phase == Vec1) goto phaseVec1

if ($phase == mi1) goto phasemi1
if ($phase == mi2) goto phasemi2
if ($phase == mi3) goto phasemi3
if ($phase == mi4) goto phasemi4
if ($phase == mi5) goto phasemi5
if ($phase == mi6) goto phasemi6
if ($phase == mi7) goto phasemi7


if ($phase == L1) goto phaseL1
if ($phase == L2) goto phaseL2
if ($phase == LA) goto phaseLA

if ($phase == truc) goto phaseTruc
if ($phase == timer) goto phaseTimer

if ($phase == 99) goto phase99

# other value of $phase : fall through, print usage and die
echo "Sorry unknown phase=#$phase# "
echo "Try MAGIC -help"
if ($Verbose == 0) exit 1 

goto usage

############################################################################################
## Usage 
usage:

echo 'MAGIC options'
echo 'First the system should be initialized as explained in the user manual.'
echo '      You must run "$MAGIC_SRC/waligner/scripts/MAGIC init [DNA | RNA]",'
echo '      and create a local link to the TARGET directory of the correct species.'
echo '      Then you must declare your runs in the MetaDB database created by "init".'
echo '      We recommend very simple chronological names like Ghs1, Ghs2 for human genome runs'
echo '      or Rhs1, Rhs2 for human RNA runs. This ensures name unicity in your database.'
echo '      Then carefully document the nature of the experiment.  in the Title, Sample,'
echo '      tissue and other biological fields in the Run object. About the sequencing'
echo '      indicate in particular the platform or machine type, if you used paired end,'
echo '      and for RNA_seq, if the starting material was polyA selected or Total RNA'
echo '      and if the protocol was strand-specific. The later is critical for gene expression'
echo '      and exon discovery. '
echo '      Finally, you can declare Groups of Runs to obtain more synthetic views.'
echo ' '
echo '      MAGIC createRNATestSet (or createGenomicTestSet or createMitoTestSet)'
echo '      will create a set of 48M reads as a benchmark for the code'
echo ' '
echo '      Then, run "MAGIC a0" to create the Fastc files for the Runs declared in MetaDB. '
echo '      Please verify that, for each run, files Fastc/$run/*.fastc.gz have been created.'
echo '      Note that MAGIC is accretive, new runs can be integrated later in the same groups,'
echo '      allowing comparative studies and handling of Peta-bases projects with thousands of runs.'
echo ' '
echo 'The type of molecule: DNA or RNA indicated in the initialisation is stored in the file ./LIMITS'
echo ' '
echo 'Synthetic reports, quality controls and result tables will appear in the RESULTS/* directories'
echo 'The desired analyses should be specified by the following options'
echo '    ALIGN: align all Runs in parallel to multiple selected targets.'
if ($targets != "") echo "       currently:  $targets"
echo '           You can modify the target list with a command  setenv targets in ./LIMITS'
echo '           matching the files TARGET/Targets/*.fasta.gz'
echo '      see the results in the directories RESULTS/Mapping, Mismatches and ATGC_sequence_profiles'
echo '      The (huge) tables of best alignments, in the rich MAGIC format, may be found in tmp/COUNT*/*/*.hits.gz'
echo '      The alignment statistics per run and group are queriable in the MetaDB acedb database.'
echo '    WIGGLE: construct the density plots per run or group along the chromosomes.'
echo '      The coverage density plots in Bed Fixed format, are constructed in tmp/WIGGLEGROUP/*/*.BF.gz'
echo '    CNV: Copy Number Variations. Construct the CNV plot for Compare objects with tags CNV AND Profile.'
echo '      WIGGLE must be computed first'
echo '      the program estimates the chromosomal number is each "coveron", defined as a small highly covered region'
echo '       search highly expressed genomic loci, even if not previously annotated.'
echo '      Much better results will be obtained by using a strictly strand specific protocol'
echo '      such as SOLiD or Illunina ligation protocols.'
echo '      See the results in RESULTS/Coverage_and_exons.'
echo ' '
echo '    GENE: counts the aligned reads, kb and sequences supporting the previously annotated Genes.'
echo '      Expression indexes and raw counts will appear in RESULTS/Gene_expression.'
echo '    MRNA: counts the aligned reads, kb and sequences supporting the previously annotated transcripts.'
echo '    INTRON: counts the reads supporting gene elements, exons and introns, in the selected gene annotations.'
echo '      Expression indexes and raw counts will appear in  RESULTS/Introns_exons_polyA'
# echo '    INTRON_VALIDATION: search for new introns supported by MAGIC spliced alignments, see RESULTS/Introns_exons_polyA'
echo '    polyA: search and report polyA addition sites, see RESULTS/Introns_exons_polyA.'
echo '      Additional gene expression, polyA and intron details are accessible in the GeneIndexDB acedb database.'
echo ' '
echo '    SNP: identify candidate sequence variations, quantify their support, and the distribution of genotypes'
echo '      across all tested individuals. see the in RESULTS/SNV' 
echo '    REARRANGEMENTS:  search and report rearrangements (in development)'
echo ' '
echo 'Examples'
echo '  MAGIC ALIGN GENE WIGGLE INTRON SNV'
echo '  '    
echo ' '
echo '      Some analyses imply others, for example ALIGN is implied in all cases'
echo '      The system will select the needed options automatically'
echo '      and the order of the options on the command line is immaterial.'
echo 'Verbose : adding Verbose on the command line will produce much more detailed messages, but the the same results'

if ($Verbose == 1) then

echo '    SRR: Download SRR fastq files, this implementation is NCBI specific '
echo '    a0C: Count the sequence'
echo '    a0D: Report the counts in MetaDB'
echo '    a0W: Detect adaptors and bar codes'
echo '    a1W: Centralize the adaptors in the database'
echo '    a0Ba: Compute the prevalence of the telomere and poly-A motifs in all reads'
echo '    a0Br: Collate the prevalence table  in all reads and report in RESULTS/Mapping'
echo '    a0Bm: Map the telomere sequences on the genome'
echo '    a0Bua: Compute the prevalence of the telomere and poly-A motifs in umaligned reads'
echo '    a0Bur: Collate the prevalence table  in umaligned reads and report in RESULTS/Mapping'
echo '    a0P: Letter profiles before alignments'
echo '    a0S: Stitch inserts smaller than read-length'
echo '    createRNATestSet: Make a test set of 10M 50mers, matching the RefSeq, with artificial SNPs at position 50,100,150,200,...'
echo '    createMitoTestSet: Make a test set of 10M 50mers, matching the mito, with artificial SNPs at position 50,100,150,200,...'
echo '    createGenomicTestSet: Make a test set of 10M 50mers, matching a section of the genome, with artificial SNPs at position 50,100,150,200,...'

echo '    a1: Align on mito, SpikeIn, rrna, rnaGene tRNA (as enumerated in LIMITS.$species) with clipalign'
echo '    a2: Align on the transcriptomes (as enumerated in LIMITS.$species) with clipalign'
echo '    a3: Count the best alignments of tmp/COUNT/*/*.hits.gz into *.count'
echo '    a123: Do a1, a2, a3 at once'
echo '          set USEMAGICBLAST 1 in ./LIMITS to  do a123 using magicblast'
# echo '    a123MH: Do a1, a2, a3 using matchhits'
echo '    ali_clean_up: remove all alignment files if an error is reported in tmp/COUNT/$lane.a123.err'
echo '    a5: evaluate the bar code statistics'
echo '    a6: evaluate the fastq quality coefficients'
# echo "CleanBowtie: rm the HITS_../bowtie hits that have been transferred to PHITS_off0"

echo "c1:    export job CPU and statistics"
echo "c2:    export the alignment statistics to the acedb deep MetaDB database"
echo "c3:    export the alignment quality per target and error types off the acedb MetaDB database"
echo "c4:    export the report on the stranding, unicity, mismatches"
echo "c5:    export the report on the read-fate, hierarchic mapping, pair fate, insert length"
echo "c6:    prefix/suffix letter profiles"

echo "c5v:    export the venn mapping report"

echo "qc    export projectwide quality control metrics"
echo "PARASITES"
echo "p1:    export fasta of not yet aligned reads"
echo "p2:    run blast against nr (NCBI specific)"
echo "p3:    recover the best targets in other species, count in RESULTS/Missing_genome_and_Metabiome/"
echo "p4:    align all unaligned reads againts Patric bacteria and the p3 additional targets"
echo "p5:    statistics of the p4 alignments"

echo "RNA editing"
echo "r2g1:    realign the analigned pairs and the orphans in RNA-editing mode"
echo "r2g4:   Run gene predictions using  RNA-editing counts"

echo "WIGGLES"
echo '   wg1: Export the genomic Wiggle per run and per chromosome, or mito, rrna, SpikeIn'
echo '   wg2a: Combine the lane wiggles per run'
echo '   wg2ba: Combine the sublib wiggles into run wiggles (for groups with tag Wiggle in MetaDB)'
echo '   wg2bb: Combine the run wiggles into group wiggles (for groups with tag Wiggle in MetaDB)'
echo '   wg2bm: Just do the ERCC per groups, requires phases s1m, s2am and s2bm'
echo '   wg3a: Construct the coverome used for exon discovery'
echo '   wg3b: Combine and report the coverome used for exon discovery'
echo '   wg4: report the coverome coverage'
echo '   wg4b: compute the ETargets capture genebox coverage'
echo '   wg4c: cumulate the ETargets capture genebox coverage'
echo '   wg4d: parse the ETargets capture genebox coverage'
echo '   wg5: Convert the group wiggles to TABIX format'  
echo '   wg6: Create the tmp.tabix.ace files'
echo '   wg7: Create a wiggle on the UCSC browser'
echo '   cnv: Differential CNV analysis, using class compare: tag CNV'

echo '   wgh: Export the histo of  genomic Wiggle '
echo '   sponge1: manual only, analyze which new exons touch which gene, construct a heat-map'
echo '   sponge2: count the tags in the shadow of the genes/CDS/transcripts '
echo '   sponge3: sponge statistics, construct RESULTS/Coverage_and_exons/sea_level.ace'

echo '   wsig1: export pre run the signature wiggles (tissues and 3prime bias)'
echo '   wsig2: group the signature wiggles (tissues and 3prime bias)'
echo '   wsig3: export the summarized profiles'

echo '   wm1: Export the mRNA  Wiggle per lane for the stable mrna list'
echo '   wm2: Consolidate the mRNA wiggles per run'
echo '   wm3: Consolidate the mRNA wiggles per group'

echo '   wm1H: Export the hierarchic mRNA  Wiggle per lane for the stable mrna list'
echo '   wm2H: Consolidate the hierarchic mRNA wiggles per run'
echo '   wm3H: Consolidate the hierarchic mRNA wiggles per group'

echo '   wpA: Export the polyA wiggle'

echo '   wmito1: Export the mito/ERCC  Wiggle per lane'
echo '   wmito2: Consolidate the mito wiggles per manip'
echo '   wmitopA1: Export the mito polyA Wiggle '
echo '   wmitopA2: Centralize the mito polyA Wiggle '

echo '   mi1: small RNA, identify the adaptors (alias of a0W)'
echo '   mi2: small RNA, collate the adaptors (alias of a1W)'
echo '   mi3: small RNA, construct the clipped tc file'
echo '   mi4: small RNA, consolidate the tag counts'
echo '   mi5: small RNA, map the clipped reads on the genome'
echo '   mi6: small RNA, covariance analysis'
echo '   mi7: small RNA, assemble the unaligned short reads'
echo '   mi8: small RNA, blast the assembled reads'



echo '   L1: measure the size of the double ended reads'
echo '   L2: align just the paired reads on the mito'
echo '   LA: measure the autocorrelation of the polyA sites'

echo "SLpA1:   Collect the SLs and polyA, detected by  alignment"
echo "SLpA2:   Cluster the polyA of the groups"
echo "SLpA3:   Export the polyA statistics and features"

echo "d0:    collect known introns from the ZH databases (NCBI specific)"
echo "d1:    collect the de_uno introns, detected by genome alignemnt"
echo "d2:    collect the alignment overhangs"
echo "d4:    compare new and known introns"
echo "d4SLs: obsolete parse SL counts in MetaDB"
echo "d5:    Importation of intron support in GeneIndexDB"
echo "d6:    obsolete align on the intron candidates"
echo "d7:    obsolete recover the U_introns confirmations"
echo "d8:    obsolete collate the U_introns confirmations"

echo "t1:    collect the translocations in each run"
echo "t2:    cumul the translocations per runs per group and per project"

echo "tgf1:    collect the gene fusions in each run"
echo "tgf2:    report the gene fusions per group and per project"

echo "f0:    Ventilate the genome alignments"
echo "f1:    Construct the yellow quasi EST from the ali->INTRONS"
echo "f2:    Collate the double introns"
echo "f3:    Parse the yellow/green pseudo est in the XH database"
echo "f4:    Assemble the yellow/green pseudo est in the XH databases"
echo "f5:    Export the new transcriptome mrna.dna and structure"
echo "f6:    Collate the new mrna structure and fasta sequence"


echo "k1:    shops for kantors in Kantor"
echo "k2:    integrate kantor results"
echo "k9:    linear launch megaRun all on a chromosome"


echo "g1:    Prepare the GeneIndexDB database"
echo "g2a:   Gene index collect the unique gene expression data for each lane"
echo "m2a:   mRNA index collect the unique mRNA expression data for each lane"
echo "m2aH:  Hierarchic mRNA index collect the unique mRNA expression data for each lane"
echo "g2b:   Gene consolidate per run in .u.ace.gz"
echo "m2b:   mRNA consolidate per run in .u.ace.gz"
echo "m2bH:   Hierarchic mRNA consolidate per run in .u.ace.gz"
echo "g3a:   Gene index collect the quasi-unique gene expression data for each lane"
echo "m3a:   mRNA index collect the quasi-unique gene expression data for each lane"
echo "m3aH:   Hierarchic mRNA index collect the quasi-unique gene expression data for each lane"
echo "g3b:   Gene consolidate per run in .nu.ace.gz"
echo "m3b:   mRNA Consolidate per run in .nu.ace.gz"
echo "m3bH:    Hierarchic mRNA Consolidate per run in .nu.ace.gz"

echo "g4:    Export gene expression tables  in RESULTS/Expression and analyse differential expression according to the Compare class"
echo "g4sp:  Export gene_sponge genebox expression tables  in RESULTS/Expression and analyse differential expression according to the Compare class"
echo "g4spx:  Export gene_sponge exon/mrna expression tables  in RESULTS/Expression and analyse differential expression according to the Compare class"
echo "m4:    Export mRNA expression tables  in RESULTS/Expression and analyse differential expression according to the Compare class"
echo "m4H:   Export hierarchic mRNA expression tables  in RESULTS/Expression and analyse differential expression according to the Compare class"
echo "ma4:    Analyse the micro-array data declared in OTHER_PIPELINES as another RESULTS/Expression"
echo "snp4:   Analyse differential SNPs according to the Compare class"
echo "gsnp4:  Analyse genes containing a differential number of protein coding SNPs according to the Compare class"

echo "g5:    Recalcul des index, par run et par groupe"
echo "g6:    Exportation a partir de GeneIndexDB des tables d'index par genes annotes"
echo "g7:    Export best 1000 genes in each run->Gene_element_index and run->compare_to"
echo "g8:    Compare gene expression for runs with tag compare_to"


echo "g10:   Prevalence : number of runs expressing genes and DEGs per gene type"
echo "g11:   Chromosomal density : Density of DEGS along the chromosomes"
echo "g12a:  Obsolete Prepare the histogram of all measured non-NA indexes in the different targets"
echo "g12b:  Obsolete Export the histogram of all measured non-NA indexes in the different targets"

echo "klst0: Prepare Kallisto index"
echo "klst1: Run Kallisto on transcripts"
echo "klst2: Centralize in MetaDB the Kalliso CPU and memory usage"
echo "klst4: Run gene predictions using as index log2(1000* kallisto.tpm)"

echo "FDR1:  For all Experiment objects with DEG tag, export False Discovery in RESULTS/Expression/DEG.*"
echo "FDR2:  Export in RESULTS/Expression a DEG ace file with optimal FDR"

echo "SF1:   sailfish, compute gene expression using k-mers"
echo "SF2:   sailfish, collate gene expression support"
echo "SF24A:     sailfish, sailfish gene counts and predictions"
echo "SF24B:   sailfish, bias corrected saifish gene expression support"
echo "SF31A:   sailfish, sailfish gene counts and predictions"
echo "SF31B:   sailfish, bias corrected saifish gene expression support"

echo "ii2a:   Known_intron counts per lane"
echo "ii2b:   Known_intron counts per run"
echo "ii2c:   Known_intron counts per run with sublibraries"
echo "ii2d:   Histogram of the Cumulated support of annotated exon junctions"
echo "ii3a:   Known_intron counts per lane in non unique alignments"
echo "ii3b:   Known_intron counts per run in non unique alignments"

echo "ii4:   Recalcul des index, par run et par groupe"
echo "ii6:    Exportation a partir de GeneIndexDB des tables d'index par genes annotes"

echo "ma1:   Micro-Array align all probes in MicroArray directory to the genome"
echo "ma2:   Micro-Array sponge the support for each probe in each run, per chrom and per strand"
echo "ma3:   Micro-Array compute the probe and probe-set index genome wide"

echo "tsnp1a:   Collate per  Run snps and indels using tricoteur"
echo "tsnp1b:   Collate the previous table per run and group using tsf"
echo "tsnp2a:   Centralize the tsf files in TSNP_DB for each zone"
echo "tsnp2b:   Create a word file in each zone to allow validation of the SNPs"
echo "tsnp2c:   Count in the original fastc files the snp and reference words using tricoteur"
echo "tsnp3:    Collate the previous table per run and group using tsf"
echo "tsnp3xxx:    Report in RESULTS/SNV"

echo "s1:   Collate cover and missmatch per run in coverons/transcripts in tmp/SNP_BRS"
echo "s1A2G:   Collate A>G in tmp/SNP_BRS"
echo "s1c:    job stats of snp data collect,  (Note in Exome, SNP search requires wg1-4)"
echo "s2a:  Collate the BRS files of run with sublibraries  in tmp/SNP_BRS"
echo "s2b:  Collate the BRS files of groups SNP AND add_counts  in tmp/SNP_BRS"
echo 's3a:   Detect  the candidate SNPs per run or group filtered on cover/frequency, export in tmp/SNP'
echo 's3b:   Count the candidate SNPs per run or group filtered on cover/frequency, export in tmp/SNP'
# echo 's3c:   Locally reextend the alignments of the corresponding SNPs using the COUNT/..hits.gz files'


echo "snp2a:  Centralize the tsf files in TSNP_DB for each zone"
echo "s10:   Report the per run and type the mismatches in RESULTS/SNV"

echo "s11:   Collate in tmp/SNPH all SNPs, filter, and look for differential"
echo "s12:   Report the per run and type the quality filtered and differential SNPs, and the rejected and the A2G  in RESULTS/SNV"

echo "s20:   Collate and translate the SNPs in tmp/SNP_DB"
echo "s21:   Report the SNP into RESULTS/SNV/, including the run metadata and the translations"
echo "s22:   Count SNPs per gene"

echo "s13:   Find the SNP differential between runs"
echo "s14:   Prediction analysis via selected SNPs"
echo "s3:    Prepare an edited reference sequence for SNP confirmation"
echo "s4:    Confirm the SNPs by realigning on the edited target"
echo "s5:    Collate the confirmed counts in s590"
echo "s6:    Analyse the confirmed counts in tmp/KL.$MAGIC (draft see scripts/MAGIC at s6:"
echo "s2old:  fingerprinting at say 80/20"
echo "s2old:    Report seq error types"
echo "s3old:    Report seq-errors per quality score"
echo "s4old:    old code"

echo "vir1:   Construct the virus and bacteria counts"
echo "vir2:   Report the virus bacteria count"
echo "vir3:   void"
echo '   est1: EST count stranded hits'

echo "Vec1:  Search the entry and exit vextor, then by hand select the first few bp and iterate"

echo "v1:    construct the counts in given region"

echo "truc:  phase truc to run a one time code"

echo "99:   clean up the junk files left over in various ways"
# 2009_01_28
# CF README.introns for the construction of the intron summary

endif

echo ' In case of problem, email mieg@ncbi.nlm.nih.gov'

exit 1
 
#######################################################################################
# Number of tags according to Helicos
gawk '{nu+=$3;nall+=$4;nc+=$5;}END{printf("Unique %d All %d Corrected %d\n",nu,nall,nc);}' Brain.count.txt
Unique 12013910 All 21994823 Corrected 13833293
mieg@ace:~/MAC/SEQC/Helicos/counts> gawk '{nu+=$3;nall+=$4;nc+=$5;}END{printf("Unique %d All %d Corrected %d\n",nu,nall,nc);}' UHRR.count.txt 
Unique 5200219 All 8922484 Corrected 6121961

# data are available from georeviewer1:passwd@ftp-private.ncbi.nih.gov/SEQC_In-house_SamplesAB
# ls -ls /am/ftp-geo_reviewers/georeviewer1/SEQC_In-house_SamplesAB/
# data for the rat are in 
# ls -ls /am/ftp-geo_reviewers/georeviewer1/TGx_*

###################################################################################
###################################################################################
# count the types in RefSeq
# rat 2013_05_27
# /am/ftp-genomes/Rattus_norvegicus/RNA/rna.fa.gz  rna.gbk.gz
set f=rn5.NCBI_ftp_site.genomes.Rattus_norvegicus.RNA.2012_06_23.downloaded_2013_05_27
gunzip -c $f.rna.gbk.gz | gawk '/^ACCESSION/{print;a=$2;}/^VERSION/{print;v=$2;}/\/gene=/{print;g=substr($1,7);}/\/db_xref=\"GeneID/{print;gid=substr($1,18);printf("###\t%s\t%s\t%s\t%s\n",a,v,gid,g);}' | gawk '/^###/{gsub(/\"/,"",$0);print ;}' |  cut -f 2,3,4,5 > $f.RefSeq2GeneId2Gene.txt
cat $f.RefSeq2GeneId2Gene.txt | gawk '{print substr($1,1,3);}' | tags

gunzip -c  /am/ftp-genomes/Rattus_norvegicus/RNA/rna.fa.gz
gunzip -c rn5.NCBI_ftp_site.genomes.Rattus_norvegicus.RNA.2012_06_23.downloaded_2013_05_27.RefSeq2GeneId2Gene.txt.gz ZZZZZ.gz /am/ftp-genomes/Rattus_norvegicus/RNA/rna.fa.gz | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){g[$2]=$4;gid[$2]=$3;next;}}/^>/{split($1,aa,"|");nm=aa[4];printf(">%s|Gene|X__%s|GeneId|%s\n",nm,g[nm],gid[nm]);next;}{print}' | gzip > $f.clean.fasta.gz

#########################################
######### TARGET_CONSTRUCTION Human Rat and Mouse 2016_09_15, using NCBI gff3 file and genome CHROMS
#########  Rat rn6.0 2019_03
if ($species == hs) then
  set ref=ref_GRCh38.p7
  set refG=hs_ref_GRCh38.p7
  set refS=H_sapiens
endif
if ($species == hs) then
  set ref=ref_GRCh37.105
  set refG=hs_ref_GRCh37.p13
  set refS=H_sapiens
endif

if ($species == rn) then
  set ref=ref_Rnor_6.0
  set refG=rn_ref_Rnor_6.0
  set refS=R_norvegicus
endif

if ($species == mm) then
  set ref=ref_GRCm38.p4
  set refG=mm_ref_GRCm38.p4
  set refS=M_musculus
endif

if ($species == dog) then
  set ref=ref_CanFam3.1
  set refG=cfa_ref_CanFam3.1
  set refS=Canis_lupus_familiaris
endif

# grab the whole genome, then only keep the accession in the title line, since it matches the gff3 file
if (! -d TARGET) mkdir TARGET
if (! -d TARGET/CHROMS) mkdir TARGET/CHROMS
if (! -d TARGET/GTF) mkdir TARGET/GTF
# we use to get the internally
# gunzip -c /am/ftp-genomes/$refS/Assembled_chromosomes/seq/$refG'_'*.fa.gz > TARGET/CHROMS/$refG.fa
# it is preferable to download it via the web page Genome Rat download officiel->fasta et gff
# mv ~/ACEVIEWHELP/Rat_DATA/2019Feb27_GCF_000001895.5_Rnor_6.0_genomic.fna.gz TARGET/CHROMS
# and the corresponding gff
# mv Rat_DATA/2019_02.GCF_000001895.5_Rnor_6.0_genomic.gff.gz TARGET/GTF

############ Rat GENOME 2019 
## The genome fasta file from the NCBI genome page is nearly ok
## The file is called GCF_000001895.5_Rnor_6.0_genomic.fna.gz
## the NW_ entries all contain a nice nickname with the chrom at the end
## the NC_ entries, one per chrom, represent the bulk of the chromosome

if ($species == rn) then
  pushd TARGET/CHROMS
  #### grab the mito and remove it from the genome
  set fa=2019_02.GCF_000001895.5_Rnor_6.0_genomic.fna.gz
  zcat $fa | gawk '/^>/{ok=0;}/mitochondrion/{ok=1}{if(ok == 1) print > "mito" ; else print > "genome";}'
  mv mito $species.mito.fasta ; gzip $species.mito.fasta
  #### grab the chomosomes off the genome file
  # to fan out, the correct chrom is recovered in each sequence title
  cat genome | gawk '/^>NW/{chrom=$NF;split(chrom,aa,"."); chrom=aa[1];ff="rn.chrom_" chrom ".fasta" ;gsub("_random","",ff);}/>NC/{split($0,aa,",");n=split(aa[1],bb," ");ff="rn.chrom_chr" bb[n] ".fasta"; }{print >  ff}'
  # move the cleaned (mito removed) genome to Targets
  mv genome rn.genome.fasta
  gzip rn.*.fasta

###########
  #  old method where we insisted on renaming the sequences
  #  cat _t | grep -v mito | grep -v NW_ | gawk '{split($1,aa,"|");printf("%s\tchr%s\n",aa[4],$(NF-1));}' | sed -e 's/,//' > NC2chr.rename.txt
  #  cat _t | grep mito | gawk '{split($1,aa,"|");printf("%s\tmito\n",aa[4]);}' >> NC2chr.rename.txt
  #  cat _t | grep -v mito | grep NW_ | gawk '{split($1,aa,"|");printf("%s\t%s\n",aa[4],$NF);}' >> NC2chr.rename.txt
endif

### in human renaming, the genome fasta file is nearly ok , the NW_ entries all contain a nice nickname 
if ($species == hs) then
  # grab the title lines excluding the patch and the alternate
  cat $refG.fa | gawk '/^>/{print}' > _t
  cat _t | grep -v alternate | grep -v patch > _t1
  cat _t1 | grep mito | gawk '{split($1,aa,"|");printf("%s\tmito\n",aa[4]);}'  > NC2chr.rename.txt
  cat _t1 | grep -v UN | grep -v RANDOM | grep -v mito | gawk '{split($1,aa,"|");printf("%s\tchr%s\n",aa[4],$5);}' | sed -e 's/,//' >> NC2chr.rename.txt
  cat _t1 | grep RANDOM | grep -v unplaced | gawk '{split($1,aa,"|");printf("%s\tchr%s\n",aa[4],substr($12,6));}' >> NC2chr.rename.txt
  cat _t1 | grep RANDOM | grep -v unlocalized |  gawk '{split($1,aa,"|");printf("%s\tchr%s\n",aa[4],substr($10,6));}' >> NC2chr.rename.txt
  cat _t1 | grep -v RANDOM | grep UN | grep -v unplaced | gawk '{split($1,aa,"|");printf("%s\tchr%s\n",aa[4],substr($12,6));}' >> NC2chr.rename.txt
  cat _t1 | grep -v RANDOM | grep UN | grep -v unlocalized |  gawk '{split($1,aa,"|");printf("%s\tchr%s\n",aa[4],substr($10,6));}' >> NC2chr.rename.txt

endif

### in human 2020 hg37v105 renaming, the genome fasta file is nearly ok , we add chr..| in from of the NC/NT names: e.g: chr22|NC_000022.10,  chr8|NT_113907.1, chrUn|NT_167240.1
if ($species == hs) then
  # grab the title lines excluding the patch and the alternate
  cat $refG.fa | gawk '/^>/{print}' > _t
  cat _t | grep -v alternate | grep -v patch > _t1
  cat _t1 | grep mito | gawk '{printf("%s\tmito|%s\n",substr($1,2),substr($1,2));}'  > NC2chr.rename.txt
  cat _t1 | grep -v unlocalized | grep -v unplaced | grep -v mito | gawk '{split($1,aa,">");split($5,bb,",");printf("%s\tchr%s|%s\n",aa[2],bb[1],aa[2]);}'  >> NC2chr.rename.txt
  cat _t1 | grep unlocalized | gawk '{split($1,aa,">");printf("%s\tchr%s|%s\n",aa[2],$5,aa[2]);}' >> NC2chr.rename.txt
  cat _t1 | grep unplaced | gawk '{split($1,aa,">");printf("%s\tchrUn|%s\n",aa[2],aa[2]);}' >> NC2chr.rename.txt
endif

### in mouse we must select the strain and remove the patches and the names are horrible
if ($species == mm) then
  # grab the title lines excluding the pathcehs and excluding the Venter other strain
  cat $refG.fa | gawk '/^>/{print}' | grep -v PATCH | grep C57BL/6J > _t
  cat $refG.fa | gawk '/^>/{print}' | grep -v PATCH | grep mito >> _t

  cat _t | grep -v mito | grep NC_ | gawk '{split($1,aa,"|");printf("%s\tchr%s\n",aa[4],$(NF-2));}' | sed -e 's/,//' > NC2chr.rename.txt
  cat _t | grep mito | gawk '{split($1,aa,"|");printf("%s\tmito\n",aa[4]);}' >> NC2chr.rename.txt
  cat _t | grep -v mito | grep NT_ | gawk '{split($1,aa,"|");printf("%s\tchr%s\n",aa[4],substr($NF,6));}' >> NC2chr.rename.txt
endif

### in dog
if ($species == dog) then
  # grab the title lines excluding the pathcehs and excluding the Venter other strain
  cat $refG.fa | gawk '/^>/{print}' > nams
  cat nams | grep chromosome > _t
  cat nams | grep mitochondrion >> _t

  cat _t | grep -v mito | grep NC_ | gawk '{split($1,aa,"|");printf("%s\tchr%s\n",aa[4],$8);}' | sed -e 's/,//' > NC2chr.rename.txt
  cat _t | grep mito | gawk '{split($1,aa,"|");printf("%s\tmito\n",aa[4]);}' >> NC2chr.rename.txt
endif

## rename all the elements of the genome fasta file as chr*  
# simplified for ghs37.105 where we keep  chr7|NC007.7  
echo ZZZZZ > ZZZZZ
#cat  NC2chr.rename.txt ZZZZZ $refG.fa | gawk '/^ZZZZZ/{zz=1;next;}{if(zz<1){nam[$1]=$2;next;}}/^>/{split($1,aa,"|");x=nam[aa[4]];ok=0;if(length(x)>1)ok=1;if(ok==1)printf(">%s %s\n",x,substr($0,2));next;}{if(ok==1)print}' > $species.genome.$ref.fasta
#cat  NC2chr.rename.txt ZZZZZ $refG.fa | gawk '/^ZZZZZ/{zz=1;next;}{if(zz<1){nam[$1]=$2;next;}}/^>/{split($1,aa,"|");x=nam[aa[4]];ok=1;if(length(x)>1)ok=0;x=aa[4];if(ok==1)printf(">%s %s\n",x,substr($0,2));next;}{if(ok==1)print}' > $species.genome.$ref.unc.fasta
cat  NC2chr.rename.txt ZZZZZ $refG.fa | gawk '/^ZZZZZ/{zz=1;next;}{if(zz<1){nam[$1]=$2;next;}}/^>/{split($1,aa,">");x=nam[aa[2]];ok=0;if(length(x)>1)ok=1;if(ok==1){$1=">"x; print;}next;}{if(ok==1)print}' > $species.genome.$ref.fasta

## rename the source sequences in the gff files as chr*
#gunzip -c  /am/ftp-genomes/$refS/GFF/$ref'_'top_level.gff3.gz > _t.gff3
gunzip -c $species.RefSeq.pre_gff3.gz > _t.gff3
cat  NC2chr.rename.txt ZZZZZ _t.gff3  | gawk -F '\t' '/^ZZZZZ/{zz=1;next;}{if(zz<1){nam[$1]=$2;next;}}{if(length(nam[$1]) < 1)next;printf("%s",nam[$1]);for(i=2;i<=NF;i++)printf("\t%s",$i);printf("\n");}' > $species.RefSeq.$ref.gff3
#cat _t.gff3 | gawk '/^#/{next}/^NC_/{next;}{print;}' >  $species.RefSeq.$ref.unc.gff3
\rm _t.gff3
# use the gff3 file to export the .ace annotation, done again in metadata.tcsh and the fasta of the transcripts
dna2dna -gff3  $species.RefSeq.$ref.gff3 -o $species.RefSeq.$ref -O fasta -gzo -gtfGenome  $species.genome.$ref.fasta  -gtfRemap KT_RefSeq
dna2dna -gff3  $species.RefSeq.$ref.unc.gff3 -o $species.RefSeq.$ref.unc  -O fasta -gzo -gtfGenome  $species.genome.$ref.unc.fasta  -gtfRemap KT_RefSeq

cat $species.genome.$ref.fasta | gawk '/^>/{ok=0;}/^>mito/{ok=1;}{if(ok==1)print}' > $species.mito.$ref.fasta
cat $species.genome.$ref.fasta | gawk '/^>/{ok=1;}/^>mito/{ok=0;}{if(ok==1)print}' > $species.chroms.$ref.fasta


## sort the fasta files for mRNAH and desambiguate the gene names
## av mrna, use bql to sort by genes then by mrna
if ($species == worm) then
  bin/tace ~/yk <<EOF 
    bql -o toto.bql.dna select g,tg,m,dna from g in ?gene, tg in g->transcribed_gene, m in tg->mrna, dna in DNA(m) where dna
EOF
  cat  toto.bql.dna | gawk '{printf (">%s|GENE|%s\n%s\n",$3,$1,$4);}' | gzip > worm.av.fasta.gz
endif

set ff = $species.RefSeq.$ref.fasta
mv $ff.gz $ff.unsorted.gz
dna2dna -i $ff.unsorted.gz -O raw -keepName  | grep -v pseudogene | gawk '{split($2,aa,"|") ;split(aa[1],bb,"_");printf("%s\t%s\t%s\t%s\t",aa[3],aa[5],bb[1],bb[2]);print;}' | sort -V  > toto
echo ZZZZZ > ZZZZZ
cat toto ZZZZZ toto  | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){if ($2 != gid[$1])ngid[$1]++;gid[$1]=$2;next;}}{g=$1;if(ngid[$1]>1)g=$1 "." $2; split($6,aa,"|");printf("%s\t%s|Gene|%s|geneId|%s\n",$5,aa[1],g,$2);}' > toto2

cat toto2 | dna2dna -I raw -O fasta -keepName -maxLineLn 60 | gzip > $ff.gz
\rm  $ff.unsorted.gz

# create an acedb to verify graphically
if (! -e database) then
  mkdir database
  ln -s ~/ace/waligner/metaData/wspec.aceview_web_site wspec
  echo y | tbly .
endif
tbly . <<EOF
  parse /home/mieg/ace/waligner/metaData/methods.ace
  parse $species.genome.$ref.fasta
  parse $species.RefSeq.$ref.transcripts.ace.gz
  acembly
    cluster_pg
    quit
  save
  quit
EOF

mkdir TARGET.$refG
mkdir TARGET.$refG/Targets
mkdir TARGET.$refG/GTF
mkdir TARGET.$refG/CHROMS
gzip $species.RefSeq.$ref.gff3  
mv  $species.RefSeq.$ref.gff3.gz  TARGET.$refG/GTF
mv  $species.RefSeq.$ref.fasta.gz TARGET.$refG/Targets

pushd  TARGET.$refG/GTF ; ln -s  $species.RefSeq.$ref.gff3.gz  $species.RefSeq.gff.gz ; popd
pushd TARGET.$refG/Targets ; ln -s  $species.RefSeq.$ref.fasta.gz  $species.RefSeq.fasta.gz ; popd
cat   $species.genome.$ref.fasta | gawk '/^>/{x=substr($1,2);split(x,aa,".");x=aa[1];split(x,aa,"_");out= species ".chrom_" aa[1] ".fasta";}{print > out}' species=$species
mv $species.chrom_mito.fasta $species.mito.fasta ; gzip $species.mito.fasta ; mv $species.mito.fasta.gz TARGET.$refG/Targets 
if (-e $species.genome.fasta) \rm $species.genome.fasta
foreach chrom ($chromSetAll)
  cat  $species.chrom_chr$chrom.fasta >> $species.genome.fasta
end
gzip  $species.genome.fasta
\rm  TARGET.$refG/Targets/$species.genome.fasta.gz
mv  $species.genome.fasta.gz TARGET.$refG/Targets/$species.genome.fasta.gz
mv $species.chrom_*.fasta TARGET.$refG/CHROMS
gzip TARGET.$refG/CHROMS/*.fasta
pushd TARGET.$refG/Targets ; ln -s  $species.genome.$ref.fasta.gz  $species.genome.fasta.gz ; popd


gunzip -c $species.RefSeq.$ref.?.sponge.gz | cut -f 1 | sort -u | gawk '{print substr($1,1,3);}' | tags
#######  rn.6_0 2016_08_02
NM_	17538
NR_	650
XM_	38560
XR_	12692

# used to be
NM_ 27467
NR_ 2267
XM_ 9911
XR_ 3088

######  mouse ref_GRCm38.p4 2016_08
NM_	29903
NR_	4975
XM_	46173
XR_	25455
 
gunzip -c TARGET/Targets/$species.$target.fasta.gz | bin/dna2dna -I fasta -O raw -keepName | gawk -F '\t' '{split($2,aa,"|");printf("Transcript %s\nLength %d\n",aa[1],length($1));if(aa[2]=="Gene")printf("From_gene %s\n",aa[3]); if(substr(aa[4],1,6)=="GeneId")printf("GeneId  %s\n",aa[5]);printf("\n");}' | gzip > TARGET/MRNAS/$species.$target.tr2len2gene.ace.gz

cat MRNAS/$species.RefSeq.fasta | gawk '/^>/{n[substr($1,2,3)]++;}END{for (k in n)print k,n[k]}'

# ensembl encode download  introns count CF EBI

BJ/HINV download
ftp://ftp.ddbj.nig.ac.jp/mirror_database/hinv/nuc_all.fa.gz
mv nuc_all.fa.gz hs.HINV.2010_03_30.nuc_all.fa.gz
# clean up, and create transcript2gene

############################################################################
## 2016 droso
## sort the fasta files for mRNAH
############################################################################
set ff = TARGET/Targets/$species.$target.fasta.gz
mv $ff $ff.unsorted.gz
dna2dna -i $ff.unsorted.gz -O raw -keepName  | gawk '{split($2,aa,"|") ;printf("%s\t%s\t",aa[3],aa[1]);print;}' | scripts/tab_sort | cut -f 3,4 | dna2dna -I raw -O fasta -keepName | gzip > $ff

############################################################################
## 2016 Mouse genome download
## things completely changed agin in decembre 2015
## see mouse38/TARGET/CHROMS/README
############################################################################
#EBI Homo_sapiens.GRCh37.61.cdna.all.fa downloaded 2011_01_19
#    Homo_sapiens.GRCh37.61.ncrna.fa 
#EBI Homo_sapiens.GRCh37.62.cdna.all.fa downloaded 2011_06_07
#EBI  ~/ftp-SEQC/SEQC_Reference_Targets/human.Ensembl.2011_09_12.Homo_sapiens.GRCh37.64.cdna.all.fa.gz 
#EBI Homo_sapiens.GRCh37.67.cdna.all.fa.gz dated 2012_04_30 downloaded 2012_11_24
#EBI Homo_sapiens.GRCh37.70.cdna.all.fa.gz downloaded 2013_02_03
#EBI  Homo_sapiens.GRCh37.75.cdna.all.fa.gz downloaded 2014_10_15  in ~/37_6/TARGET/MRNAS/

set ff=human.Ensembl_encode.2013_01.Homo_sapiens.GRCh37.70
set ff=Homo_sapiens.GRCh37.75
# this awk script reorganizes the gene name according to MAGIC conventions and selects the main chromosomes 1,2,,,,X,Y
gunzip -c $ff.cdna.all.fa.gz | gawk '/^>/{ok=0;split ($3,aa,":");c=aa[3];if(index(c,"GL")>0)next;if(index(c,"MHC_")>0)next;if(index(c,"LRC_")>0)next;if(index(c,"PATCH")>0)next;ok=1;}{if(ok>0)print;}'  |   gawk '/^>/{gsub(/gene:/,"|Gene|",$4);gsub(/:/,"|",$5);gsub(/chromosome:/,"Chromosome|",$3);printf("%s%s|%s|%s\n", $1,$4,$5,$3);next;}{print}' | gzip >   $ff.cdna.all.clean.fa.gz

gunzip -c $ff.cdna.all.fa.gz | gawk '/^>/{gsub(/gene:/,"|Gene|",$4);printf("Gene %s\nTitle \"%s %s\"\nTranscript %s\n\n", substr($4,7),$2,$3,substr($1,2));next;}' | gzip > $ff.cdna.all.ace_possible_bad_schema.gz
gunzip -c  $ff.cdna.all.clean.fa.gz | gawk -F '|' '/^>/{n[$5]++}END{nn=0;for (k in n){print  n[k] "\t" k ;nn+=n[k];}print nn,"\ttotal",nn;}' | $tab_sort -k 1n 
######### EBI ncRNA
# grep the rnaGene miRNA snRNA snoRNA miscRNA mapped to the main chromosomes (aa[3]), IMPORTANT exclude the rRNA
\rm toto.fasta
foreach typ (miRNA snRNA snoRNA misc_RNA )
  gunzip -c $ff.ncrna.fa.gz | gawk '/^>/{ok=0;split ($3,aa,":");c=aa[3];if(index(c,"GL")>0)next;if(index(c,"_MHC_")>0)next;if(index(c,"LRC_")>0)next;if(index(c,"PATCH")>0)next;split($5,bb,":");if(bb[2]==typ)ok=1;}{if(ok>0)print;}' typ=$typ >> toto.fasta
end
# sort the gene name according to MAGIC conventions
cat toto.fasta | gawk '/^>/{gsub(/gene:/,"|Gene|",$4);gsub(/:/,"|",$2);gsub(/chromosome:/,"Chromosome|",$3);printf("%s%s|%s|%s\n", $1,$4,$2,$3);next;}{print}' | gzip >   $ff.smallRNA.clean.fa.gz  
gunzip -c  $ff.smallRNA.clean.fa.gz   | gawk -F '|' '/^>/{n[$5]++}END{nn=0;for (k in n){print  n[k] "\t" k ;nn+=n[k];}print nn,"\ttotal",nn;}' | $tab_sort -k 1n 

\rm toto2.fasta

gunzip -c $ff.ncrna.fa.gz | gawk '/^>/{ok=0;split ($3,aa,":");c=aa[3];if(index(c,"GL")>0)next;if(index(c,"_MHC_")>0)next;if(index(c,"LRC_")>0)next;if(index(c,"PATCH")>0)next;split($5,bb,":");if(bb[2]=="Mt_rRNA")next;if(bb[2]=="Mt_tRNA")next;if(bb[2]=="rRNA")next;}{print;}' typ=$typ >> toto2.fasta
cat toto2.fasta | gawk '/^>/{n[$5]++}END{nn=0;for (k in n){print k, n[k];nn+=n[k];}print "total",nn;}' | $tab_sort
# the gene name according to MAGIC conventions
cat toto2.fasta | gawk '/^>/{gsub(/gene:/,"|Gene|",$4);gsub(/:/,"|",$2);gsub(/chromosome:/,"Chromosome|",$3);printf("%s%s|%s|%s\n", $1,$4,$2,$3);next;}{print}' | gzip >  $ff.encode_ncRNA.clean.fa.gz  

  

gunzip -c  $ff.encode_ncRNA.clean.fa.gz | gawk -F '|' '/^>/{n[$5]++}END{nn=0;for (k in n){print  n[k] "\t" k ;nn+=n[k];}print nn,"\ttotal",nn;}' | $tab_sort -k 1n 

gunzip -c $ff.cdna.all.clean.fa.gz  $ff.encode_ncRNA.clean.fa.gz   | gzip >  $ff.encode_all_AND_nc_MINUS_rrna.clean.fa.unsorted.gz

dna2dna -i $ff.encode_all_AND_nc_MINUS_rrna.clean.fa.unsorted.gz -O raw -keepName  | gawk '{split($2,aa,"|") ;printf("%s\t%s\t",aa[3],aa[1]);print;}' | $tab_sort | cut -f 3,4 | dna2dna -I raw -O fasta -o Homo_sapiens.GRCh37.75.encode_all_AND_nc_MINUS_rrna.clean -gzo  -keepName
\rm  $ff.encode_all_AND_nc_MINUS_rrna.clean.fa.unsorted.gz
ln -s  $ff.encode_all_AND_nc_MINUS_rrna.clean.fasta.gz hs.EBI.fasta.gz


\rm toto.fasta toto2.fasta

mkdir GTF
gunzip -c $ff.gtf.gz | gawk -F '\t' '{c=$1;if(index(c,"GL")>0)next;if(index(c,"_MHC_")>0)next;if(index(c,"LRC_")>0)next;if(index(c,"PATCH")>0)next;split($9,aa,"gene_biotype");split(aa[2],bb,"\"");if(bb[2]=="rRNA")next;if(bb[2]=="Mt_tRNA")next;if(bb[2]=="Mt_rRNA")next;print}' | gzip > GTF/$ff.clean.gtf.gz
gunzip -c $ff.gtf.gz | gawk -F '\t' '{c=$1;if(index(c,"GL")>0)next;if(index(c,"_MHC_")>0)next;if(index(c,"LRC_")>0)next;if(index(c,"PATCH")>0)next;split($9,aa,"gene_biotype");split(aa[2],bb,"\"");if(bb[2]=="rRNA")next;if(bb[2]=="Mt_tRNA")next;if(bb[2]=="Mt_rRNA")next;ok=0;;if(bb[2]=="miRNA")ok=1;if(bb[2]=="snRNA")ok=1;if(bb[2]=="snoRNA")ok=1;if(bb[2]=="misc_RNA")ok=1;if(ok==1)print}' | gzip > GTF/$ff.smallRNA.gtf.gz

ln -s  GTF/$ff.clean.gtf.gz hs.EBI.gtf.gz

set toto=$ff.stats.txt
echo -n "# $ff.ncrna.fa.gz  +  $ff.ncrna.fa.gz : " > $toto
date >> $toto
echo "\n $ff.cdna.all.fa.gz +  $ff.ncrna.fa.gz "  >> $toto
gunzip -c  $ff.cdna.all.fa.gz  $ff.ncrna.fa.gz  | gawk  '/^>/{ng[$4,$5]++;if(ng[$4,$5]==1)nng[$5]++;n[$5]++;gg[$4]++;if(gg[$4]==1)ggu++;}END{nn=0;for (k in n){print  nng[k] "\t" n[k] "\t" k ;nnng+=nng[k];nn+=n[k];}print nnng "\t" nn "\ttotal";print ggu "\t" nn "\tunion";}' | $tab_sort -k 1n  >> $toto

echo "\n # $ff.encode_all_AND_nc_MINUS_rrna.clean.fa.gz" >> $toto
gunzip -c  $ff.encode_all_AND_nc_MINUS_rrna.clean.fa.gz  | gawk -F '|' '/^>/{ng[$3,$5]++;if(ng[$3,$5]==1)nng[$5]++;n[$5]++;gg[$3]++;if(gg[$3]==1)ggu++;}END{nn=0;for (k in n){print  nng[k] "\t" n[k] "\t" k ;nnng+=nng[k];nn+=n[k];}print nnng "\t" nn "\ttotal";print ggu "\t" nn "\tunion";}' | $tab_sort -k 1n  >> $toto

cat $toto
\cp $toto ~/ACEVIEWHELP/Ensembl/

echo "Number of transcripts per type of target in  $ff.cdna.all.fa.gz  $ff.ncrna.fa.gz" >  ~/ACEVIEWHELP/Ensembl/Map_types.txt
gunzip -c    $ff.cdna.all.fa.gz  $ff.ncrna.fa.gz  | gawk '/^>/{ok=0;split ($3,aa,":");print aa[3];}' | tags | $tab_sort >>  ~/ACEVIEWHELP/Ensembl/Map_types.txt

# chrom types kept
gunzip -c $ff.encode_all_AND_nc_MINUS_rrna.clean.fa.gz | gawk '/^>/{split($1,aa,"Chromosome");split(aa[2],bb,":");print bb[2];}' | tags | $tab_sort

## EBI 2013_01 summary:
## cdna.all.clean == 40,168 genes, 174,107 transcripts
## small          ==  8,611          8,611
## linc           ==  6,453         11,072
## various        ==    839            913
## EBI final      == 56,071        194,703

## EBI 2014_10 GRCh37.75 summary
## cdna.all.clean == 40,168 genes, 174,107 transcripts
## small          ==  8,611          8,611
## linc           ==  6,453         11,317
## various        ==    839          1,154
## Homo_sapiens.GRCh37.75.encode_all_AND_nc_MINUS_rrna.clean.fa.gz
21	25	3prime_overlapping_ncrna
202	316	sense_overlapping
741	813	sense_intronic
1457	1457	snoRNA
1916	1916	snRNA
2033	2033	misc_RNA
3049	3049	miRNA
5891	10219	novel
7109	11317	lincRNA
9342	21715	putative
14150	15272	pseudogene
20910	116262	known
66821	184394	total 184394

######
# EBI Ensembl gene box : parse the gff file in awk
# this code is superseded by dna2dna gtf parsing in metadata.tcsh

######
# EBI Ensembl introns: parse the gff file please do it in C using dna2dna -> .remap and .introns and .transcripts.ace
# intron list: 345433 introns on main chrom , 376786 introns including the patches and variants
ls -ls $ff.gtf.gz
$bin/dna2dna -gtf $ff.gtf.gz -gtfRemap MT_EBI -o GRCh37.70
cat GRCh37.70.introns  | cut -f 6,7,8,9 | $tab_sort -u | grep -v H | grep -v GL > $ff.intron.main_chrom.txt
cat GRCh37.70.mrnaRemap | gawk -F '\t' '{if(length($5)<3)print;}' > ../WIGGLEREMAP/mrnaRemap.EBI.txt
cat GRCh37.70.cdsRemap | gawk -F '\t' '{if(length($5)<3)print;}' > ../WIGGLEREMAP/cdsRemap.EBI.txt

cat GRCh37.70.introns  | gawk -F '\t' '{chrom=$6;if(length(chrom)>2)next;s=$9;a1=0+$7;a2=0+$8;printf("Intron %s__%d_%d\nGene %s\nFrom_genefinder %s\nEBI_2013\n\n",chrom,a1,a2,$2,$3);}' > GRCh37.70.introns.ace

cat GRCh37.70.introns  | gawk -F '\t' '{chrom=$6;if(length(chrom)>2)next;s=$9;a1=0+$7;a2=0+$8;printf("Gene %s\tGenefinder %s\n",$2,$3);}' | $tab_sort -u | gawk -F '\t' '{printf("%s\n%s\n\n",$1,$2);}' > GRCh37.70.gene2genefinder.ace

###### 2014_04_14
# RefSeq: parse the gff file please do it in C using dna2dna -> .remap and .introns
# cd ~/37_5__104/XmInfo/GFF_processing
set gff3=/am/ftp-genomes/H_sapiens/ARCHIVE/ANNOTATION_RELEASE.104/GFF/ref_GRCh37.p10_top_level.gff3

# the code crashes. maybe gff3 and gtf are not using the same columns ?
$bin/dna2dna -gtf $gff3.gz -gtfRemap KT_RefSeq -o RefSeq_v104


############## tRNA imported from UCSC_Feb12_2012_Lowe_tRNAs.txt.gz 
gunzip -c UCSC_Feb12_2012_Lowe_tRNAs.txt.gz | gawk -F '\t' '{gsub(/\?\?\?/,"xxx",$0);chrom=substr($2,4);a1=$3;a2=$4;ln=a2-a1;a1=a1+1;a2-$3;g=$5;if($7=="-"){u=a1;a1=a2;a2=u;}printf("%s\t%d\t%d\t%s\t%d\t%d\n",g,1,ln,chrom,a1,a2);}' > UCSC_Feb12_2012_Lowe_tRNAs.shadow

foreach chrom ($chromSetAll)
  $bin/dna2dna -i ../CHROMS/hs.chrom_$chrom.fasta.gz -shadow UCSC_Feb12_2012_Lowe_tRNAs.shadow -O fasta -o UCSC_Feb12_2012_Lowe_tRNAs.chr$chrom
end

cat UCSC_Feb12_2012_Lowe_tRNAs.chr*.fasta | gawk '{gsub(/\?\?\?/,"xxx",$0);}' | gzip >  UCSC_Feb12_2012_Lowe_tRNAs.fasta.gz

# /home/mieg/RESULTS/UCSCtRNAhg19/tRNAs.txt
# bin/chrom/a1/a2/name/score/strand/aa/anticodon/junk/score_sean_eddy/genome_url/tRNA_url@gtrnadb/
# the name in col 5 is unique

reference pm9023104
reference pm18984615

Properties "[Lowe, Eddy and Chan, 2010] tRNA gene predicted by using tRNAscan-SE v.1.23. tRNAscan-SE is an integrated program that uses tRNAscan (Fichant) and an A/B box motif detection algorithm (Pavesi) as pre-filters to obtain an initial list of tRNA candidates. The program then filters these candidates with a covariance model-based search program COVE (Eddy) to obtain a highly specific set of primary sequence and secondary structure predictions that represent 99-100% of true tRNAs with a false positive rate of fewer than 1 per 15 gigabases"

if score > 60:
Properties "This tRNA has a tRNAscan-SE score of NNN, and is likely to encode a functional tRNA gene"

if score between 45 and 60
Properties "The tRNAscan-SE score is NNN, in the grey zone: this tRNA may or may not have all the required features to be functional. It should be inspected carefully for loss of specific primary or secondary structure features (usually in alignments with other genes of the same isotype), in order to make a better educated guess. Please follow the pointer to GtRNAdb in the Link section"

if score between 20 and 45
Properties "tRNAscan-SE score is NNN. Anything with a score above 20 and below 45 bits is likely to be derived from a tRNA, although this does not indicate whether the tRNA gene still encodes a functional tRNA molecule (i.e. tRNA-derived SINES probably do not function in the ribosome in translation)."


# cat  /home/mieg/RESULTS/UCSCtRNAhg19/tRNAs.txt

gunzip -c UCSC_Feb12_2012_Lowe_tRNAs.txt.gz | gawk -F '\t' '/random/{next}{gsub(/\?\?\?/,"xxx",$0);chrom=substr($2,4);da=$4-$3+1;if($7=="+"){a1=$3;a2=$4;}else{a1=$4;a2=$3;}AA=$8;anticodon=$9;score=int($11);url=$13;printf("Gene %s\nGenefinder %s\nNon_protein_coding\nDescriptor \"tRNA %s %s\"\nIntMap %s %d %d\nReference pm9023104\nReference pm18984615\n", $5, $5, anticodon, AA,chrom, a1, a2);printf("Summary  \"[Lowe, Eddy and Chan, 2010] tRNA gene predicted by using tRNAscan-SE v.1.23. tRNAscan-SE is an integrated program that uses tRNAscan (Fichant) and an A/B box motif detection algorithm (Pavesi) as pre-filters to obtain an initial list of tRNA candidates. The program then filters these candidates with a covariance model-based search program COVE (Eddy) to obtain a highly specific set of primary sequence and secondary structure predictions that represent 99-100%% of true tRNAs with a false positive rate of fewer than 1 per 15 gigabases");if(score>60)printf(". This tRNA has a tRNAscan-SE score of %s, and is likely to encode a functional tRNA gene\"\n", score);else if(score>45)printf(". The tRNAscan-SE score is %s, in the grey zone: this tRNA may or may not have all the required features to be functional. It should be inspected carefully for loss of specific primary or secondary structure features (usually in alignments with other genes of the same isotype), in order to make a better educated guess. Please follow the pointer to GtRNAdb in the Link section\"\n",score);else printf(". tRNAscan-SE score is %s. Anything with a score above 20 and below 45 bits is likely to be derived from a tRNA, although this does not indicate whether the tRNA gene still encodes a functional tRNA molecule (i.e. tRNA-derived SINES probably do not function in the ribosome in translation).\"\n",score);printf("\n\n");}' >  UCSC_Feb12_2012_Lowe_tRNAs.txt.ace


gunzip -c  UCSC_Feb12_2012_Lowe_tRNAs.txt.gz | gawk -F '\t' '/random/{next}{chrom=substr($2,4);da=$4-$3+1;if($7=="+"){a1=$3;a2=$4;}else{a1=$4;a2=$3;}AA=$8;anticodon=$9;score=int($11);url=$13;printf("Sequence %s\nSource %s\nSource_Exons 1 %d\nIntMap %s %d %d\nIs_predicted_gene\nBrief_identification \"tRNA %s\"\nMethod tRNAscan-SE-1.23\ntRNA %s\nAnticodon %s\nScore %s\nDatabase gtrnadb \"%s\"\n\n",$5,chrom,da,chrom,a1,a2,AA,AA,anticodon,score,url);}' >>  UCSC_Feb12_2012_Lowe_tRNAs.txt.ace 
gunzip -c  UCSC_Feb12_2012_Lowe_tRNAs.txt.gz | gawk -F '\t' '/random/{next}{chrom=substr($2,4);if($7=="+"){a1=$3;a2=$4;}else{a1=$4;a2=$3;}printf("Sequence %s\nSubsequence %s %d %d\nGenes %s %d %d\n\n",chrom,$5,a1,a2,$5,a1,a2);}' >>  UCSC_Feb12_2012_Lowe_tRNAs.txt.ace


#############################################
## generic metadata file

  set toto=TARGET/GENES/av.metadata.txt

  gunzip -c TARGET/Targets/hs.av.fasta.gz | gawk '/^>/{split($1,aa,"|");print aa[3];}' | $tab_sort -u > $toto.1
  cat ZZZZZ TARGET/GENES/av.gene2intMap.txt >> $toto.1
  cat ZZZZZ TARGET/GENES/av.gene2geneid.txt >> $toto.1
  cat ZZZZZ TARGET/GENES/av.geneTypesAntiSense.txt >> $toto.1
  cat ZZZZZ TARGET/GENES/av.gene2title.txt | grep -v 'cloud gene' >> $toto.1
  cat ZZZZZ   >> $toto.1
  gunzip -c TARGET/MRNAS/hs.av.transcript2gene.txt.gz  | sed -e 's/\"//g' >> $toto.1
  cat ZZZZZ MicroArray/Hits/AGLuK.av.probe2gene.unique.txt   >> $toto.1
  
  echo -n "# " > $toto
  date >> $toto
  echo "# Metadada for the 55836 AceView-2011 genes (a subset of the AceView 2010 genes) used in the SEQC project." >> $toto
  printf "# The corresponding fasta file is at ftp-SEQC/SEQC_Reference_Targets/human.AceView.2010.selected.v4.fasta.gz\n" >> $toto
  printf "# Gene\tChromosome\tGeneId\tType\tTitle\tTranscripts\tUniquely mapped Agilent probes\n" >> $toto
  cat $toto.1 |  gawk -F '\t'  '/^ZZZZZ/{zz++;next;}/^#/{next;}{if(zz<1){gg[$1]=1;next;}}{if(zz<2){g2chrom[$1]="chr" $2 ":" $3 "-" $4;next;}}{if(zz<3){g2gid[$1]=g2gid[$1] ";" $2;next;}}{if(zz<4){g2typ[$1]=$2;next;}}{if(zz<5){g2title[$1]=$2;next;}}{if(zz<6){g2mrna[$2]=g2mrna[$2] ";" $1;next;}}{if(zz<7){g2probe[$2]=g2probe[$2] ";" $1;next;}}END{for(g in gg){typ=g2typ[g];if(typ=="")typ="single_exon";printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\n",g,g2chrom[g],substr(g2gid[g],2),typ,g2title[g],substr(g2mrna[g],2),substr(g2probe[g],2));}}' | $tab_sort >> $toto


###################################################################################
###################################################################################
## phase SRR: Download the SRR and create paired end fasta files for the Runs declared in the MetaDataBase

phaseSRR: 
echo -n "phaseSRR : Create the fastc files for the Runs declared in the MetaDataBase "
date

echo "OBSOLETE see scripts/SRX_import.tcsh, 2015_10_02"

goto phaseLoop

###################################################################################
###################################################################################
## phase a0: Create the fastc files for the Runs declared in the MetaDataBase

phasea0: 
echo -n "phasea0 : Create the fastc files for the Runs declared in the MetaDataBase "
date

set nMakeFastc=0
# construct the Fastc directory tree
if (! -d Fastc) mkdir Fastc
  
# construct the Fastc files

bin/tacembly MetaDB << EOF 
  comment magic_list 1
  select -s  r from p in ?project where p == $MAGIC , r in p->run
  spush
  select -s @->sublibraries
  sor
  spop
  select -s r from r in @ where r#File and COUNT {select a in r->ali where a#Counts} == 0
  select -o MetaDB/$MAGIC/Run2File r,f1,f2 from r in @, f1 in r->file, f2 in  f1[1]
EOF

wc  MetaDB/$MAGIC/Run2File

foreach run (`cat MetaDB/$MAGIC/Run2File | cut -f 1 | sort -u`)
  if (-e Fastc/$run/tmp) continue
  if (-e Fastc/$run/LaneList) continue
  if (-e Fastc/$run/first_line.txt) continue
  if (-e Fastc/$run/f2.1.fastc.gz || -e Fastc/$run/f.1.fastc.gz) then
    if (! $?MAGIC_KILL_FASTQ) continue
  endif  

  # Find the format
  set format=0
  set format=`cat MetaDB/$MAGIC/Run2File | gawk -F '\t' '{if($1 == run && $2 != "NULL") {f=tolower($2); if(index($3,"csfasta")>0)f="csfasta";print f;}}' run=$run | gawk '{split($1,aa,"/");print aa[1];}' | sort -u | head -1`
  if ($format == 0 || $format == "") continue
  echo "$run $format"

  if ($format != raw && $format != fasta && $format != csfasta  && $format != csfastq && $format != fastq && $format != tc && $format != fastc) then
    echo "ERROR: bad format parameter: $format"
    echo "ERROR: try $0 -help for more info"
    exit 1
  endif

  # Verify the existence of the file or files
  set nn=0
  set files=""
  set filesQ=""
  foreach file (`cat MetaDB/$MAGIC/Run2File | gawk '{if($1==run && $3 != "NULL")print $3}' run=$run  | sort -u`)
    echo "run $format $file"
    if (! -e $file) then
      echo "ERROR 3: In MetaDB Run $run points to file $file, this file is not accessible"
      set nn=0
      break 
    endif
    set files=$files$file"_____"
    @ nn = $nn + 1
  end
 echo hello3
  if ($nn == 0) continue
  if ($nn > 2) then
    echo "ERROR more than 2 files declared in Run $run : $files"
    continue
  endif
  set UMI=""
  set umi=`cat MetaDB/$MAGIC/runs.ace | gawk '/^Run/{ok=0;gsub(/\"/,"",$2);if($2==run)ok=1;}/^UMI/{if(ok==1)umi=$2+0;}END{print umi+0;}' run=$run`
  if ($umi > 0) set UMI=UMI$umi
  if ($nn > 0) then
    if (-e fastc_count.ace) \rm fastc_count.ace
    if (-e Fastc/$run/f2.1.fastc.gz || -e Fastc/$run/f.1.fastc.gz) then
      if ($?MAGIC_KILL_FASTQ) then
        set nFiles=`echo $files | gawk '{n=split($1,aa,"_____");if(aa[n]=="")n-=1;print n}'`
        \rm $filesQ
      endif
    else
      if (! -d  Fastc/$run) mkdir Fastc/$run
      scripts/submit Fastc/$run/a0 "scripts/makeFastc $run $format $files Fastc $UMI" 32G 
      echo                         "scripts/makeFastc $run $format $files Fastc $UMI"
      @ nMakeFastc = $nMakeFastc  + 1
    endif
  endif

end

if ($nMakeFastc > 0) then
  echo "Fastc conversion launched, waiting for completion"
  scripts/submit wait5
endif

goto phaseLoop

# Note sugano
1: machine HWUSI-EAS476
2: run number
3: lane          1,2,3 are unique for the whole file
4/5/6: tile,x,y
7: index string: blank for not indexed run
8: 1/2 for paired end 
9: dna
10: quality
11-15: mapping
22: quality passed: Y/N
 count column 22: gunzip -c testis_s_7_export.txt.gz | gawk -F '\t' '{n[$22]++;}END{for (k in n)print k,n[k]}'


###################################################################################
###################################################################################
## phase a0C: counts

phasea0C: 
echo -n "phasea0C:count the sequences in each run "
date

set ok=1
foreach run (`cat MetaDB/$MAGIC/RunList`)
   if (! -e Fastc/$run/fastc.count) then
     scripts/submit scripts/a0C.lengthDistrib.tcsh $run
   endif
   foreach lane (`gawk '{i=index($1,"/");if(run == substr($1,1,i-1))print $1;}' run=$run MetaDB/$MAGIC/LaneList`)

     if (! -e Fastc/$lane.count) then
       set ok=0

# do not clip the no insert here, this will be done in clipalign with a nicer report
       set fastctype=fastc
       foreach run2 (`cat MetaDB/$MAGIC/RunSolidList`)
         if ($run == $run2) set fastctype=csfastc
       end

# echo "$run $v2"
       scripts/submit Fastc/$lane.count "bin/dna2dna -i Fastc/$lane.$fastctype.gz -I $fastctype -gzi -O count -minEntropy $minEntropy  -minLength $minLength  -clipN $clipN  -o Fastc/$lane" 
     endif
   end
end

if ($ok == 1) then
  echo "All runs have been counted, please proceed to phase a0D"
else
  echo "Counting the sequences in the runs, please synchronize"
endif

goto phaseLoop

###################################################################################
## phase a0D: report the counts

phasea0D: 
echo -n "phasea0D: report the counts in MetaDB "
date

foreach lane (`cat MetaDB/$MAGIC/LaneList`)
  if (! -e Fastc/$lane.count) then
    echo "Missing Fastc/$lane.count, please run phase a0C"
    goto phaseLoop
  endif
end

if (! -e TARGET/Targets/$species.genome_length.txt && -e  tmp/METADATA/$species.genome.TM.txt.gz ) then
  gunzip -c tmp/METADATA/$species.genome.TM.txt.gz | gawk '/^>/{next;}{n+=$2;}END{printf ("Genome_length\t%d\n",n);}' > TARGET/Targets/$species.genome_length.txt
endif

foreach run (`cat MetaDB/$MAGIC/RunList`)
  # echo "... decompression errors $run"
  # report decompression errors
  if (-e Fastc/$run/a0.out) grep expected Fastc/$run/a0.out
  if (! -e Fastc/$run/original_counts.ace) then
    echo "........ 1 $run"
    cat Fastc/$run/original.count | gawk '/^Processed/{if($3=="sequences"){nt+=$2;ns+=$2;nb+=$4;}}/^Sequence_processed/{ns+=$2}/Exit_adaptor/{nvxt+=$3;nvxbp+=$4}/Entry_adaptor/{nvet+=$3;nvebp+=$4}/Tags_kept/{nt+=$2}/Bases_tags_kept/{nb+=$2}/Tissue/{ts[$2]+=$3;tt[$2]+=$5;tb[$2]+=$7;tvet[$2]+=$9;tvxt[$2]+=$11;tvebp[$2]+=$13;tvxbp[$2]+=$15;}END{if (ns>0){printf("Ali %s\nRun %s\n",run,run) ; printf("Raw_data %d Id %d Accepted %.3f kb\n\n", ns, nt, nb/1000);}}'  run=$run > Fastc/$run/original_counts.ace
  endif
end

set ok=0
foreach run (`cat MetaDB/$MAGIC/RunNoCountList`)
    # force recount but not one new runs never processed before
    if (-e Fastc/$run/fastc_counts.ace && -e Fastc/$run/fastc.count) \rm Fastc/$run/fastc.count
    if (-e Fastc/$run/fastc_counts.ace) \rm  Fastc/$run/fastc_counts.ace
    if (! -e Fastc/$run/fastc.count) then
      scripts/submit Fastc/$run/a0C.length_distrib    "scripts/a0C.lengthDistrib.tcsh $run"
      set ok=1    
    endif 
end
if ($ok == 1) scripts/submit wait


foreach run (`cat MetaDB/$MAGIC/RunList`)
  ls -ls Fastc/$run/fastc.count.ace
  if (! -e Fastc/$run/fastc.count.ace) then
    cat Fastc/$run/fastc.count | gawk 'BEGIN{minLn=100000000;}/Sequence_kept/{ns+=$2}/Sequence_rejected/{srej+=$2;}/Tags_rejected/{trej+=$2;}/Bases_tags_rejected/{bprej+=$2;}/Exit_adaptor/{nvxt+=$3;nvxbp+=$4}/Entry_adaptor/{nvet+=$3;nvebp+=$4}/Tags_kept/{nt+=$2}/Bases_tags_kept/{nb+=$2}/^Min_probe_length/{if($2<minLn)minLn=$2;}/^Max_probe_length/{if($2>maxLn)maxLn=$2;}/^Max_count/{if($2>maxCnt)maxCnt=$2;}/^Length_distribution/{distrib=$0;}END{if (ns>0){printf("Ali %s\nRun %s\n",run,run) ; printf("Accepted %d Seq %d Tags %.3f kb %.2f bp\n", ns, nt, nb/1000, nb/nt);if(bprej>0)printf("Rejected 0 NA %d Tags %.3f kb\n", trej, bprej/1000);if(nvet>0)printf("Entry_Adaptor_clipping  %d tags %.3f  kb\n",nvet,nvebp/1000);if(nvxt>0)printf("Exit_Adaptor_clipping  %d tags %.3f  kb\n",nvxt,nvxbp/1000);printf("Min_probe_length %d\nMax_probe_length %d\n%s\nMaximal_read_multiplicity %d\n\n",minLn,maxLn,distrib,maxCnt);}}'  run=$run >  Fastc/$run/fastc.count.ace
  endif
  ls -ls Fastc/$run/fastc.count.ace
  # the older version was called  Fastc/$run/fastc_counts.ace, it did not include the max-multiplicity
  if (-e Fastc/$run/fastc_counts.ace) \rm  Fastc/$run/fastc_counts.ace


  if (! -e  Fastc/$run/first_line.txt) then
    foreach lane (`head -1 Fastc/$run/LaneList`)
      if (-e Fastc/$lane.fastc.gz) then
        gunzip -c Fastc/$lane.fastc.gz | head -1 > Fastc/$run/first_line.txt
       endif
     end
  endif
end


echo ' ' >  toto.ace
if (-e  Fastc/$MAGIC.first_line.ace) cat Fastc/$MAGIC.first_line.ace >> toto.ace
foreach run (`cat MetaDB/$MAGIC/RunNoCountList`)
  echo "Run $run" >>  toto.ace
  echo "Ali $run" >>  toto.ace
  echo >> toto.ace
  cat Fastc/$run/original_counts.ace >> toto.ace
  # cat Fastc/$run/fastc_count.ace >> toto.ace
  cat Fastc/$run/fastc.count.ace >> toto.ace
  if (-e Fastc/$run/first_line.txt) then
    cat  Fastc/$run/first_line.txt | gawk '{printf ("Run %s\nFirst_line \"%s\"\n\n",run,$0);}' run=$run >>  toto.ace
  endif
end

# tace -noprompt options implies a save
echo "pparse toto.ace" | bin/tacembly MetaDB -noprompt
#\rm toto.ace

goto phaseLoop

###################################################################################
## phase a0W : detect adaptors and bar codes
phasea0W: 
phasemi1:
echo -n "phasea0W detect bar codes and adaptors start : "
date

if (! -d tmp/Adaptors) mkdir tmp/Adaptors
foreach run (`cat MetaDB/$MAGIC/RunList`)
  set ok=0
  if (-e MetaDB/$MAGIC/RunWithKnownAdaptorsList) then
    foreach run2 (`cat MetaDB/$MAGIC/RunWithKnownAdaptorsList`)
      if ($run == $run2) set ok=1
    end
  endif
  echo "mi1::$run $ok"
  if ($ok == 1) continue
  if (! -d tmp/Adaptors/$run) $mkDir Adaptors $run
  if (-e  tmp/Adaptors/$run/$run.1.walk) mv  tmp/Adaptors/$run/$run.1.walk  tmp/Adaptors/$run/r.1.walk
  if (-e  tmp/Adaptors/$run/$run.2.walk) mv  tmp/Adaptors/$run/$run.2.walk  tmp/Adaptors/$run/r.2.walk
  if (-e  tmp/Adaptors/$run/r.1.walk) continue 

  scripts/submit  tmp/Adaptors/$run/a0W.1 "scripts/dnawalk.findAdaptors.tcsh $run 1"
  if (-e  tmp/Adaptors/$MAGIC.adaptors.ace) \rm tmp/Adaptors/$MAGIC.adaptors.ace
  foreach run2 (`cat MetaDB/$MAGIC/RunPairedList`)
    if ($run == $run2) then
     scripts/submit  tmp/Adaptors/$run/a0W.2 "scripts/dnawalk.findAdaptors.tcsh $run 2"
    endif
  end
end

echo -n "phasea0W done : "
goto phaseLoop

###################################################################################
## phase a1W : collate adaptors and bar codes
phasea1W: 
phasemi2:
echo -n "phasea1W collate adaptors and report them in the database : "
date

if (! -e tmp/Adaptors/$MAGIC.adaptors.ace) then

  echo -n "# " >  tmp/Adaptors/$MAGIC.adaptors.txt
  date >> tmp/Adaptors/$MAGIC.adaptors.txt 
  echo ' ' >  tmp/Adaptors/$MAGIC.adaptors.ace
  foreach run ( `cat MetaDB/$MAGIC/RunList ` )
    if (! -e  tmp/Adaptors/$run/r.1.walk) continue 
    echo $run | gawk '{printf("Ali %s\n-D Adaptor1\n-D Adaptor2\n\n",$1);}'  >>  tmp/Adaptors/$MAGIC.adaptors.ace
    if (-e tmp/Adaptors/$run/r.1.walk) then
      cat tmp/Adaptors/$run/r.1.walk | gawk '/^#/{next;}{split($6,aa,":");if(aa[1]+aa[2]==-1 || aa[2]*1000 < $3)next;split($5,aa,":");print aa[2],$1,$2,$3,$4,$5,$6,$7,$8,$9,$10;}' | sort -k 1nr | head -1 >> tmp/Adaptors/$MAGIC.adaptors.txt
    endif
    if (-e tmp/Adaptors/$run/r.2.walk) then
      cat tmp/Adaptors/$run/r.2.walk | gawk '/^#/{next;}{split($6,aa,":");if(aa[1]+aa[2]==-1 || aa[2]*1000 < $3)next;split($5,aa,":");print aa[2],$1,$2,$3,$4,$5,$6,$7,$8,$9,$10;}' | sort -k 1nr | head -1 >> tmp/Adaptors/$MAGIC.adaptors.txt
    endif

  end
  cat tmp/Adaptors/$MAGIC.adaptors.txt | gawk '/^#/{next;}{split($7,aa,":");if(100*aa[2]<aa[1] || 100*aa[2]<$4);printf("Ali %s\nAdaptor%d %s\n\n",$2,$3,toupper($10));}'  >>  tmp/Adaptors/$MAGIC.adaptors.ace
endif

bin/tacembly MetaDB <<EOF
  read-models
  pparse  tmp/Adaptors/$MAGIC.adaptors.ace  
  query find project IS $MAGIC ; >run is_Run // always computed for runs
  bql -a -o MetaDB/$MAGIC/run2machine2adaptors.txt select r,m,a1,a2,aa1,aa2 from r in @, m in r->machine, a1 in r->adaptor1, a2 in r->adaptor2, ali in r->ali, aa1 in ali->adaptor1, aa2 in ali->adaptor2
  save
  quit
EOF


echo -n "phasea1W done : "
goto phaseLoop

###################################################################################
## mi3: small RNA, construct the clipped tc file
phasemi3:
echo -n "phase mi3: small RNA, construct the clipped tc file "
date

if (! -d tmp/ClippedFastc) mkdir tmp/ClippedFastc
set ok=0

foreach run ( `cat MetaDB/$MAGIC/RunSmallRnaList ` ) 
  if (! -d tmp/ClippedFastc/$run) mkDir ClippedFastc/$run
  scripts/submit tmp/ClippedFastc/$run/mi3a "bin/mir -m TARGET/GENES/known_micro_18_35.tc -i Fastc/$run/f2.1.fastc.gz -I fastc -o tmp/ClippedFastc/$run/mi3a --run $run "
end

foreach run ( `cat MetaDB/$MAGIC/RunSmallRnaList ` ) 
  # echo "mi3 $run"
  if (0 && ! -e tmp/Adaptors/$run/r.1.walk) continue
  if (! -d tmp/ClippedFastc/$run) $mkDir ClippedFastc $run
  if (-e tmp/ClippedFastc/$run/f.stats.ace) continue
  
  # export only once, 
  if ($ok == 0) then
    set ok=1
    bin/tacembly MetaDB <<EOF
      query find project IS  $MAGIC ; > run ; >ali ; counts && adaptors
      bql -o tmp/ClippedFastc/$MAGIC.adaptors.txt select ali, v1, v2, w1, w2 from ali in @, v1 in ali->adaptor1, v2 in ali->adaptor2, run in ali->run, w1 in run->adaptor1, w2 in run->adaptor2
      quit      
EOF
  endif

  set v1=`cat tmp/ClippedFastc/$MAGIC.adaptors.txt | gawk -F '\t' 'BEGIN {v = "X";}{if($1 == run){if($2 != "NULL")v = $2;if($4 != "NULL")v = $4}}END {print v;}' run=$run`
  set v2=`cat tmp/ClippedFastc/$MAGIC.adaptors.txt | gawk -F '\t' 'BEGIN {v = "X";}{if($1 == run){if($3 != "NULL")v = $3;if($5 != "NULL")v = $5}}END {print v;}' run=$run`

  # echo "run $run $v1 $v2"
  
  set paired = 0
  foreach run2 (`cat MetaDB/$MAGIC/RunPairedList`)
    if ($run == $run2) set paired = 1
  end

  if ($v1 != "X" && ! -e tmp/ClippedFastc/$run/f.stats.ace) then
    scripts/submit  tmp/ClippedFastc/$run/mi3 "scripts/miRNA.tcsh clip $run $v1 $v2"
  endif
end
 
echo -n "phasemi3 done : "
goto phaseLoop

###################################################################################
## mi4: small RNA,  consolidate the tag counts
phasemi4:
echo -n "phase mi4: small RNA, consolidate the tag counts "
date

if (! -d tmp/ClippedFastc) goto phaseLoop
if (-e tmp/GENEINDEX/mi4.$MAGIC.small.GENE.u.aceZZZZZ)  goto phaseLoop

# collate the stats
if (! -e tmp/ClippedFastc/mi4.$MAGIC.stats.ace) then
  echo > tmp/ClippedFastc/mi4.$MAGIC.stats.ace
  foreach run ( `cat MetaDB/$MAGIC/RunSmallRnaList ` ) 
    if (-e  tmp/ClippedFastc/$run/f.stats.ace) then
      cat tmp/ClippedFastc/$run/f.stats.ace >> tmp/ClippedFastc/mi4.$MAGIC.stats.ace
    endif
  end
  echo "pparse tmp/ClippedFastc/mi4.$MAGIC.stats.ace" | bin/tacembly MetaDB -noprompt
endif

# collate the frequent reads, count them in all runs
# 1000 means 10^-4 of all tags and at least 100 tags are in each read listed as R1000 in at least one sample
# 1000 -> 10^-4   100->10^-5   10->10^-3

if (! -e tmp/ClippedFastc/mi4.$MAGIC.10.tc) then
  if (-e tmp/ClippedFastc/toto.10) \rm tmp/ClippedFastc/toto.10
  if (-e tmp/ClippedFastc/toto.100) \rm tmp/ClippedFastc/toto.100
  if (-e tmp/ClippedFastc/toto.1000) \rm tmp/ClippedFastc/toto.1000
  foreach run ( `cat MetaDB/$MAGIC/RunList `)
    foreach min (10 100 1000)  
      if (-e  tmp/ClippedFastc/$run/f.filtered.$min.tc) then
        cat tmp/ClippedFastc/$run/f.filtered.$min.tc >> tmp/ClippedFastc/toto.$min
      endif
    end
  end
 
  date
  cat tmp/ClippedFastc/toto.10 | sort | gawk -F '\t' '{if($1 != old) {if(old)printf("%s\t%d\n",old,n);n=0;old=$1;}n+=$2;}END{if(old)printf("%s\t%d\n",old,n);}' | sort -k 2nr | gawk -F '\t' '{k++;printf("%s\t%d\tn.%d#%d\n",$1,$2,k,$2);}' > tmp/ClippedFastc/mi4.RatMicro.10.tc
  date
  cat tmp/ClippedFastc/toto.100 ZZZZZ tmp/ClippedFastc/mi4.$MAGIC.10.tc  | gawk -F '\t' '/^ZZZZZ/{zz=1;next;}{if(zz<1){ok[$1]=1;next;}if(ok[$1]==1)print;}' > tmp/ClippedFastc/mi4.$MAGIC.100.tc
  cat tmp/ClippedFastc/toto.1000 ZZZZZ tmp/ClippedFastc/mi4.$MAGIC.100.tc  | gawk -F '\t' '/^ZZZZZ/{zz=1;next;}{if(zz<1){ok[$1]=1;next;}if(ok[$1]==1)print;}' > tmp/ClippedFastc/mi4.$MAGIC.1000.tc

  \rm tmp/ClippedFastc/toto.10
  \rm tmp/ClippedFastc/toto.100
  \rm tmp/ClippedFastc/toto.1000

  date
endif


set toto=tmp/GENEINDEX/mi4.$MAGIC.small_rna.preace
if (-e $toto) \rm $toto
foreach ii (1000)
  echo '#' > $toto.$ii
  foreach run ( `cat MetaDB/$MAGIC/RunSmallRnaList ` ) 
    if (-e  tmp/ClippedFastc/$run/f.filtered.$ii.tc) then
      cat tmp/ClippedFastc/mi4.$MAGIC.1000.tc ZZZZZ tmp/ClippedFastc/$run/f.filtered.10.tc | gawk -F '\t' '/^#/{next}/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;next;}}{if(ok[$1]==1){printf("%s\t%s\t%s\n",$1,run,$2);}}' run=$run >> $toto.$ii
    endif
  end
  
  #sort 
  cat $toto.$ii | sort -k 1,1 > $toto.$ii.s
  mv $toto.$ii.s $toto.$ii
  wc $toto.$ii

# create an ace file 
  cat $toto.$ii | gawk -F '\t' '/^#/{next}{if ($1 != old) printf ("\nGene %s\n",$1); old=$1;printf ("Run_U %s %d seq %d tags %d kb\n", $2, $3, $3, 100*$3);}END{printf ("\n");} ' > tmp/GENEINDEX/mi4.$MAGIC.small.GENE.u.ace
  \rm $toto.$ii
end
 
# global length statistics
# cat $toto.1000 | gawk '{n[length($1)]+=$3;}END{for(i=1;i<=100;i++)if(n[i]>0)printf("%d\t%d\n",i,n[i]);}'


# map the reads exactly
if (! -d  tmp/ClippedMap) mkdir tmp/ClippedMap
if (! -e tmp/ClippedMap/mi4.$MAGIC.1000.hits) then

  dna2dna -i tmp/ClippedFastc/mi4.$MAGIC.1000.tc -I tc -O fastc -o tmp/ClippedFastc/mi4.$MAGIC.1000


  set ff=tmp/ClippedFastc/mi4.$MAGIC.1000.fastc
  foreach target (genome RefSeq mito rrna)
    bin/clipalign -i $ff -t TARGET/Targets/$species.$target.fasta.gz -o  tmp/ClippedMap/mi4.$MAGIC.1000.$target -maxHit 500 -minAli 18
  end
  if (-e toto876) \rm toto876
  foreach target (rrna mito RefSeq genome)
    cat tmp/ClippedMap/mi4.$MAGIC.1000.$target.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)printf("%s\t%s\n",$1,$9)}' | sort -u > tmp/ClippedMap/mi4.$MAGIC.1000.$target.mapped
    cat tmp/ClippedMap/mi4.$MAGIC.1000.$target.mapped ZZZZZ tmp/ClippedFastc/mi4.$MAGIC.1000.tc | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){m[$1]=1;next;}}{if(m[$3]==1)print;}' > tmp/ClippedMap/mi4.$MAGIC.1000.$target.mapped.tc
    cat tmp/ClippedMap/mi4.$MAGIC.1000.$target.mapped ZZZZZ tmp/ClippedFastc/mi4.$MAGIC.1000.tc | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){m[$1]=1;g[$1]=$2;next;}}{if(m[$3]==1){u=t;if(t=="RefSeq")u=g[$3];printf("%s\t",u);print}}' t=$target >> toto876
  end
  cat toto876 | gawk -F '\t' '{if(ok[$2]==1)next;ok[$2]=1;print}' >  tmp/ClippedMap/mi4.$MAGIC.1000.maps_in

  if (-e leming.s1.fasta) then
    set ff=leming.s1.fasta
    foreach target (genome RefSeq mito rrna)
      bin/clipalign -i $ff -t TARGET/Targets/$species.$target.fasta.gz -o  leming.s1.$target -maxHit 500 -minAli 18
    end
    if (-e toto876) \rm toto876
    foreach target (rrna mito RefSeq genome)
      cat leming.s1.$target.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)printf("%s\t%s\n",$1,$9)}' | sort -u > leming.s1.$target.mapped
      cat leming.s1.$target.mapped ZZZZZ leming.s1.tc | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){m[$1]=1;next;}}{if(m[$3]==1)print;}' > leming.s1.$target.mapped.tc
      cat leming.s1.$target.mapped ZZZZZ leming.s1.tc | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){m[$1]=1;g[$1]=$2;next;}}{if(m[$3]==1){u=t;if(t=="RefSeq")u=g[$3];printf("%s\t",u);print}}' t=$target >> toto876
    end
    cat toto876 | gawk -F '\t' '{if(ok[$2]==1)next;ok[$2]=1;print}' >  leming.s1.maps_in
  endif




  cat tmp/ClippedFastc/mi4.$MAGIC.1000.tc ZZZZZ tmp/ClippedMap/mi4.$MAGIC.1000.genome.mapped.tc | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$3]=1;s++;t+=$2;next;}}{if (ok[$3]==1){ks++;kt+=$2;}}END{printf("%s\t%s\t%d\t%d\t%.2f\t%d\t%d\t%.2f\n",run,title,s,ks,100.0*ks/s,t,kt,100.0*kt/t);}' run="Union_320_runs" title="mapped" 


  if (! -e TARGET/GENES/known_micro_18_35__genome.list) then
    bin/clipalign -i TARGET/GENES/known_micro_18_35.fasta -t TARGET/Targets/$species.genome.fasta.gz -o  TARGET/GENES/known_micro_18_35__genome -maxHit 500 -minAli 18
    cat TARGET/GENES/known_micro_18_35__genome.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $1}' | sort -u > TARGET/GENES/known_micro_18_35__genome.list
  endif

endif


if (0 && -e  tmp/ClippedMap/mi4.$MAGIC.1000.genome.hits) then
  foreach chrom ($chromSetAll)
     cat  tmp/ClippedMap/mi4.$MAGIC.1000.genome.hits | gawk -F '\t' '{if($11 == chrom)print}' chrom=$chrom > toto.hits 
     set n=`wc toto.hits | gawk '{print 0+$1}'`
     if ($n == 0) continue 
     wiggle  -i toto.hits -I BHIT -strand -unique -peaks -out_step 1 -mapOnChrom $chrom -minCover 1000 -O BV -o tmp/ClippedMap/mi4.$MAGIC.$chrom.u.f
     wiggle  -i toto.hits -I BHIT -antistrand -unique -peaks -out_step 1 -mapOnChrom $chrom -minCover 1000 -O BV -o tmp/ClippedMap/mi4.$MAGIC.$chrom.u.r
     wiggle  -i toto.hits -I BHIT -strand  -peaks -out_step 1 -mapOnChrom $chrom -minCover 1000 -O BV -o tmp/ClippedMap/mi4.$MAGIC.$chrom.nu.f
     wiggle  -i toto.hits -I BHIT -antistrand  -peaks -out_step 1 -mapOnChrom $chrom -minCover 1000 -O BV -o tmp/ClippedMap/mi4.$MAGIC.$chrom.nu.r
  end
endif

echo -n "phasemi4 done : "
goto phaseLoop

###################################################################################
## mi5: align the short reads with high counts on the known miRNA and smallRNA

phasemi5:
echo -n "phase mi5: small RNA, consolidate the tag counts "
date

if (! -d tmp/ClippedFastc) goto phaseLoop
if (! -d tmp/ClippedMap)  mkdir tmp/ClippedMap


if (-e TARGET/GENES/known_micro.fasta) then
  dna2dna -i TARGET/GENES/known_micro.fasta -minLength 18 -maxLength 35 -o TARGET/GENES/known_micro_18_35

  bin/clipalign -i TARGET/GENES/known_micro_18_35.fasta -t tmp/ClippedFastc/mi4.$MAGIC.1000.fastc  -o  tmp/ClippedMap/mi5.$MAGIC.known21000 -minAli 18
  bin/clipalign -t TARGET/GENES/known_micro.fasta -i tmp/ClippedFastc/mi4.$MAGIC.1000.fastc  -o  tmp/ClippedMap/mi5.$MAGIC.10002known -minAli 18

  cat tmp/ClippedMap/mi5.$MAGIC.10002known.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)printf ("%s\t%s\n",$1,$11)}' | sort -u  > tmp/ClippedMap/mi5.$MAGIC.10002known.list
  cat tmp/ClippedMap/mi5.$MAGIC.known21000.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)printf ("%s\t%s\n",$11,$1)}' | sort -u  > tmp/ClippedMap/mi5.$MAGIC.known21000.list
  wc *known*.list
  cat tmp/ClippedMap/mi5.$MAGIC.10002known.list tmp/ClippedMap/mi5.$MAGIC.known21000.list | sort -u > tmp/ClippedMap/mi5.$MAGIC.recognized.list
  cat tmp/ClippedMap/mi5.$MAGIC.recognized.list ZZZZZ tmp/ClippedFastc/mi4.$MAGIC.1000.tc | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;u[$1]=$2;next;}}{if (ok[$3]==1)printf("%s\t%s\n",$1,u[$3]);}' > tmp/ClippedMap/mi5.$MAGIC.recognized.dna

  set toto=RESULTS/$MAGIC.Known_micro.txt
  echo -n "### $toto ; " > $toto
  date >> $toto
  echo "## Compare the 3878 reads clipped and seen at least 1000 times to the 1142 known MIR in the length range [18,35]" >> $toto
  echo "#Run\tTitle\tSequence\tKnown\tKnown percentatge\tTag\tKnown\tKnown tag percentage" >> $toto 
  cat tmp/ClippedFastc/mi4.$MAGIC.1000.tc ZZZZZ tmp/ClippedMap/mi4.$MAGIC.1000.genome.mapped.tc | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$3]=1;s++;t+=$2;next;}}{if (ok[$3]==1){ks++;kt+=$2;}}END{printf("%s\t%s\t%d\t%d\t%.2f\t%d\t%d\t%.2f\n",run,title,s,ks,100.0*ks/s,t,kt,100.0*kt/t);}' run="Union_320_runs" title="mapped" >> $toto
  cat tmp/ClippedMap/mi5.$MAGIC.recognized.list ZZZZZ tmp/ClippedFastc/mi4.$MAGIC.1000.tc | gawk '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;next;}}{if (ok[$3]==1){ks++;kt+=$2;}s++;t+=$2;}END{printf("%s\t%s\t%d\t%d\t%.2f\t%d\t%d\t%.2f\n",run,title,s,ks,100.0*ks/s,t,kt,100.0*kt/t);}' run="Union_320_runs"  title="Known in mirDB"  >> $toto
  cat tmp/ClippedMap/mi5.$MAGIC.recognized.list ZZZZZ tmp/ClippedMap/mi4.$MAGIC.1000.genome.mapped.tc | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;next;}}{if (ok[$3]==1){ks++;kt+=$2;}s++;t+=$2;}END{printf("%s\t%s\t%d\t%d\t%.2f\t%d\t%d\t%.2f\n",run,title,s,ks,100.0*ks/s,t,kt,100.0*kt/t);}' run="Union_320_runs"  title="known and mapped"  >> $toto


  echo "mi5AA"
  foreach run (`cat MetaDB/$MAGIC/RunsList`)
    set title=`cat MetaDB/$MAGIC/gtitle.txt | gawk -F '\t' '{gsub(/\"/,"",$0);gsub(/\\\//,"/",$0);gsub(/\\%/,"%",$0);if($1==run)print $6;}' run=$run`
    set ff1=tmp/ClippedMap/mi4.$MAGIC.1000.genome.mapped.tc
    set ff2=tmp/ClippedFastc/$run/f.filtered.10.tc
    if (-e $ff1 && -e $ff2) then
      cat tmp/ClippedMap/mi5.$MAGIC.recognized.dna ZZZZZ $ff1 ZZZZZ $ff2 | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;next;}}{if(zz==1){ok2[$1]=1;next;}}{if (ok[$1]==1){ks++;kt+=$2;}if (ok2[$1]==1){s++;t+=$2;}}END{if(t==0){s=1;t=1;}printf("%s\t%s\t%d\t%d\t%.2f\t%d\t%d\t%.2f\n",run,title,s,ks,100.0*ks/s,t,kt,100.0*kt/t);}' run="$run"  title="$title"  >> $toto
    endif
  end

endif
  echo "mi5BB"
cat TARGET/GENES/known_micro_18_35.fasta ZZZZZ tmp/ClippedMap/mi5.$MAGIC.recognized.dna | gawk -F '\t' '/^ZZZZZ/{zz++;next;}/^>/{i=index($1," ");s=substr($1,2,i-2);t=substr($1,i+1);s2t[s]=t;next;}{if(zz==1){printf("%s\t%s %s\n",$1,$2,s2t[$2]);}}' > tmp/ClippedMap/mi5.$MAGIC.recdna.s.t 
cat tmp/ClippedMap/mi5.$MAGIC.recdna.s.t > toto
echo ZZZZZ >> toto
cat tmp/ClippedMap/mi4.$MAGIC.1000.maps_in >> toto
echo ZZZZZ >> toto
cat MetaDB/$MAGIC/gtitle.txt | gawk -F '\t' '{gsub(/\"/,"",$0);printf("%s\t%s\ttitle\ttitle\ttitle\n",$1,$6);}' | tail -n +2 >> toto
echo ZZZZZ >> toto
cat tmp/GENEINDEX/$MAGIC.small.GENE.u.ace | gawk '/^Gene/{s=$2;;next;}/Run_U/{printf("%s\t%s\t%d\n",s,$2,$3);}' >> toto

  cat toto | gawk -F '\t' '{if(NF==5){nr++;i2r[nr]=$1;i2t[nr]=$2;next;}}END{printf("#Sequence\tMaps in\tMirDB\tUnion\tMax");for(i=1;i<=nr;i++)printf("\t%s",i2r[i]);printf("\n#Sequence\tMaps in\tMirDB\tUnion\tMax");for(i=1;i<=nr;i++)printf("\t%s",i2t[i]);}' > toto1
  echo >> toto1
  cat toto | gawk -F '\t' '{if(NF==5){nr++;i2r[nr]=$1;next;}if(NF==2){g2k[$1]=$2;next;}if(NF==4){g2m[$2]=$1;next;}if(NF==3){g=$1;gg[g]=1;z[g,$2]=$3;n[g]+=$3;if($3>x[g])x[g]=$3;next;}}END{for(g in gg){printf("\n%s\t%s\t%s\t%d\t%d",g,g2m[g],g2k[g],n[g],x[g]);if(1)for(i=1;i<=nr;i++)printf("\t%d",z[g,i2r[i]]);}printf("\n");}' > toto2
set toto=RESULTS/$MAGIC.Small_RNA_counts.txt
echo -n "### $toto :" > $toto
date >> $toto
cat toto1 | head -12 | gawk '/^#/{print}' >> $toto
cat toto2 | gawk '/^#/{next;}{print}' | tab_sort -k 4nr  >> $toto

  echo "mi5CC"

set toto=RESULTS/$MAGIC.Small_RNA_counts.txt
set toto2=RESULTS/$MAGIC.Small_RNA_cumuls.txt
echo -n "### $toto2 :" > $toto2
date >> $toto2
cat $toto | gawk -F '\t' '/^###/{next;}/^#/{print}' >> $toto2
cat $toto | gawk -F '\t' '/^#/{next;}/genome/{next;}{if (length($3)>1)print;}' | tab_sort -k 4n  > toto10
cat $toto | gawk -F '\t' '/^#/{next;}/genome/{next;}{if (length($3)>1)next; if(length($2)>1)print;}' | tab_sort -k 4n  > toto11
cat toto10 | gawk -F '\t' '{s=$3;dna[s]=$1;if(length($2)>1)k[s]=$2;for(i=4;i<=NF;i++)z[s,i]+=$i;nf=NF;}END{for(s in dna){printf("%s\t%s\t%s",dna[s],k[s],s);x=0;for(i=4;i<=nf;i++)if(z[s,5]>x)x=z[s,5];z[s,5]=x;for(i=4;i<=nf;i++)printf("\t%d",z[s,i]);printf("\n");}}' > toto12
cat toto11 | gawk -F '\t' '{s=$2;dna[s]=$1;if(length($3)>1)k[s]=$3;for(i=4;i<=NF;i++)z[s,i]+=$i;nf=NF;}END{for(s in dna){printf("%s\t%s\t%s",dna[s],s,k[s]);x=0;for(i=4;i<=nf;i++)if(z[s,5]>x)x=z[s,5];z[s,5]=x;for(i=4;i<=nf;i++)printf("\t%d",z[s,i]);printf("\n");}}' > toto13
cat $toto | gawk -F '\t' '/^#/{next;}/genome/{print;next;}{if (length($2)>1)next;if (length($3)>1)next;;print;}' > toto14
cat toto12 toto13 toto14  | tab_sort -k 4nr >> $toto2

  echo "mi5DD"
if (-e leming.s1.maps_in) then
  cat tmp/ClippedMap/mi5.$MAGIC.recdna.s.t > toto
  echo ZZZZZ >> toto
  cat leming.s1.maps_in | gawk -F '\t' '{printf("%s\t%s\t",$1,$2);for(i=3;i<=NF;i++)printf("%s ",$i);}' >> toto
  echo ZZZZZ >> toto
  cat MetaDB/$MAGIC/gtitle.txt | gawk -F '\t' '{gsub(/\"/,"",$0);printf("%s\t%s\ttitle\ttitle\ttitle\n",$1,$6);}' | tail -n +2 >> toto
  echo ZZZZZ >> toto
  cat tmp/ClippedFastc/leming.s1.ace | gawk '/^Gene/{s=$2;;next;}/Run_U/{printf("%s\t%s\t%d\n",s,$2,$3);}' >> toto
  cat leming.s1.tc | gawk -F '\t' '{printf ("%s\tjunk\t0\n",$1);}' >>  toto

  cat toto | gawk -F '\t' '{if(NF==5){nr++;i2r[nr]=$1;i2t[nr]=$2;next;}}END{printf("#Sequence\tMaps in\tMirDB\tUnion\tMax");for(i=1;i<=nr;i++)printf("\t%s",i2r[i]);printf("\n#Sequence\tMaps in\tMirDB\tUnion\tMax");for(i=1;i<=nr;i++)printf("\t%s",i2t[i]);}' > toto1
  echo >> toto1
  cat toto | gawk -F '\t' '{if(NF==5){nr++;i2r[nr]=$1;next;}if(NF==2){g2k[$1]=$2;next;}if(NF==4){g2m[$2]=$1;next;}if(NF==3){g=$1;gg[g]=1;z[g,$2]=$3;n[g]+=$3;if($3>x[g])x[g]=$3;next;}}END{for(g in gg){printf("\n%s\t%s\t%s\t%d\t%d",g,g2m[g],g2k[g],n[g],x[g]);if(1)for(i=1;i<=nr;i++)printf("\t%d",z[g,i2r[i]]);}printf("\n");}' > toto2
  set toto=RESULTS/leming.s1.counts.txt
  echo -n "### $toto :" > $toto
  date >> $toto
  cat toto1 | head -12 | gawk '/^#/{print}' >> $toto
  cat toto2 | gawk '/^#/{next;}{print}' | tab_sort -k 4nr  >> $toto
endif

# align on known mir precursor the short seq seen at leat 1000 times
# dna2dna -i  tmp/ClippedMap/mi4.$MAGIC.fastc -I fastc -O fastc -minMultiplicity 1000 -o  tmp/ClippedMap/mi5.$MAGIC.1000
# droso use 
# set tSmall=TARGET/Targets/dmel-all-miRNA-r6.12.fasta.gz

# smallRNA
  echo "mi5EE"
foreach tSmall (miR smallRNA)
  if (-e TARGET/Targets/$species.$tSmall.fasta.gz) then
    clipalign -i  tmp/ClippedMap/mi5.$MAGIC.10000.fastc -t TARGET/Targets/$species.$tSmall.fasta.gz  -strand     -o  tmp/ClippedMap/mi5.$MAGIC.10000.$tSmall.f -maxHit 12
    clipalign -i  tmp/ClippedMap/mi5.$MAGIC.10000.fastc -t TARGET/Targets/$species.$tSmall.fasta.gz -antistrand -o  tmp/ClippedMap/mi5.$MAGIC.10000.$tSmall.r -maxHit 12

    # gunzip -c $tSmall | gawk '/^>/{ok=0;if(index($0,"pre-mi")==0)ok=1;}{if(ok)print;}' >  tmp/ClippedMap/miRNA.fasta
    # clipalign -i  tmp/ClippedMap/mi5.$MAGIC.10000.fastc -t  tmp/ClippedMap/miRNA.fasta -strand -o  tmp/ClippedMap/mi5.$MAGIC.10000.mir.f -maxHit 12

    # count the hits per mir in f or r direction, may be some runs are forward, some are reverse
    cat tmp/ClippedMap/mi5.$MAGIC.10000.$tSmall.[fr].hits | gawk -F '\t' '{n[$11]+= $3;}END{for(k in n)print k,n[k];}' | sort -k 2n
  endif
end


echo -n "phasemi5 done : "
goto phaseLoop


  cat TARGET/GENES/known_micro_18_35.tc ZZZZZ tmp/ClippedFastc/$run/f.filtered.1000

    ATCCCGGAC GAGCCCCCA
 CCTCACTCAAGT CTCGGG

### recognize the list that Leming exports as candidates

ln -s /home/mieg/AW/Rat_DATA/20211107_GSE172269_List_novel_miRNA_candidates.txt leming.candidates.txt
cat leming.candidates.txt | gawk '{printf(">%s\n%s\n",$1,$3);}'  | tail -n +3 | dna2dna -I fasta -O fasta -o leming.s1
cat leming.candidates.txt | gawk '{printf(">%s\n%s\n",$1,$4);}'  | tail -n +3 | dna2dna -I fasta -O fasta -o leming.s2

  bin/clipalign -i TARGET/GENES/known_micro_18_35.fasta -t leming.s1.fasta  -o  knwn_ls1 -minAli 18
  bin/clipalign -t TARGET/GENES/known_micro_18_35.fasta -i leming.s1.fasta  -o  ls1_knwn -minAli 18 
  bin/clipalign -i TARGET/GENES/known_micro_18_35.fasta -t leming.s2.fasta  -o  knwn_ls2 -minAli 18
  bin/clipalign -t TARGET/GENES/known_micro_18_35.fasta -i leming.s2.fasta  -o  ls2_knwn -minAli 18


  cat ls1_knwn.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $1}' | sort -u  > ls1_knwn.prelist
  cat knwn_ls1.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $11}' | sort -u  >> ls1_knwn.prelist
  cat ls1_knwn.prelist | sort -u > ls1_knwn.list
  cat ls2_knwn.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $1}' | sort -u  > ls2_knwn.prelist
  cat knwn_ls2.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $11}' | sort -u  >> ls2_knwn.prelist
  cat ls2_knwn.prelist | sort -u > ls2_knwn.list
  wc ls?_knwn.list

  
# do not transform 10.tc into fastc because the naming would be wrong
  dna2dna -i tmp/ClippedFastc/mi4.$MAGIC.100.tc -o tmp/ClippedFastc/mi4.$MAGIC.100 -I tc -O fastc
  dna2dna -i tmp/ClippedFastc/mi4.$MAGIC.10.tc -o tmp/ClippedFastc/mi4.$MAGIC.10 -I tc -O fastc

  bin/clipalign -i tmp/ClippedFastc/mi4.$MAGIC.1000.fastc -t leming.s1.fasta  -o  R1000_ls1 -minAli 18
  bin/clipalign -t tmp/ClippedFastc/mi4.$MAGIC.1000.fastc -i leming.s1.fasta  -o  ls1_R1000 -minAli 18

  bin/clipalign -i tmp/ClippedFastc/mi4.$MAGIC.100.fastc -t leming.s1.fasta  -o  R100_ls1 -minAli 18
  bin/clipalign -t tmp/ClippedFastc/mi4.$MAGIC.100.fastc -i leming.s1.fasta  -o  ls1_R100 -minAli 18

  bin/clipalign -i tmp/ClippedFastc/mi4.$MAGIC.10.fastc -t leming.s1.fasta  -o  R10_ls1 -minAli 18
  bin/clipalign -t tmp/ClippedFastc/mi4.$MAGIC.10.fastc -i leming.s1.fasta  -o  ls1_R10 -minAli 18

  bin/clipalign -i tmp/ClippedFastc/mi4.$MAGIC.1000.fastc -t leming.s2.fasta  -o  R1000_ls2 -minAli 18
  bin/clipalign -t tmp/ClippedFastc/mi4.$MAGIC.1000.fastc -i leming.s2.fasta  -o  ls2_R1000 -minAli 18

  bin/clipalign -i tmp/ClippedFastc/mi4.$MAGIC.100.fastc -t leming.s2.fasta  -o  R100_ls2 -minAli 18
  bin/clipalign -t tmp/ClippedFastc/mi4.$MAGIC.100.fastc -i leming.s2.fasta  -o  ls2_R100 -minAli 18

  bin/clipalign -i tmp/ClippedFastc/mi4.$MAGIC.10.fastc -t leming.s2.fasta  -o  R10_ls2 -minAli 18
  bin/clipalign -t tmp/ClippedFastc/mi4.$MAGIC.10.fastc -i leming.s2.fasta  -o  ls2_R10 -minAli 18

  cat ls1_R1000.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $1}' | sort -u  > ls1_R1000.prelist
  cat R1000_ls1.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $11}' | sort -u  >> ls1_R1000.prelist
  cat ls1_R1000.prelist | sort -u > ls1_R1000.list

  cat ls1_R1000.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $11}' | sort -u  > ls1_R1000.prelist2
  cat R1000_ls1.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $1}' | sort -u  >> ls1_R1000.prelist2
  cat ls1_R1000.prelist2 | sort -u > ls1_R1000.list2

  cat ls1_R1000.list2 ZZZZZ tmp/ClippedFastc/mi4.$MAGIC.1000.tc | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;next;}}{if(ok[$3]==1)print;}' 

  cat ls1_R100.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $1}' | sort -u  > ls1_R100.prelist
  cat R100_ls1.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $11}' | sort -u  >> ls1_R100.prelist
  cat ls1_R100.prelist | sort -u > ls1_R100.list

  cat ls1_R10.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $1}' | sort -u  > ls1_R10.prelist
  cat R10_ls1.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $11}' | sort -u  >> ls1_R10.prelist
  cat ls1_R10.prelist | sort -u > ls1_R10.list

  cat ls2_R1000.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $1}' | sort -u  > ls2_R1000.prelist
  cat R1000_ls2.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $11}' | sort -u  >> ls2_R1000.prelist
  cat ls2_R1000.prelist | sort -u > ls2_R1000.list

  cat ls2_R100.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $1}' | sort -u  > ls2_R100.prelist
  cat R100_ls2.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $11}' | sort -u  >> ls2_R100.prelist
  cat ls2_R100.prelist | sort -u > ls2_R100.list

  cat ls2_R10.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $1}' | sort -u  > ls2_R10.prelist
  cat R10_ls2.hits | gawk '/^#/{next;}{gsub(/>/,"",$1);if($5>=$4-3)print $11}' | sort -u  >> ls2_R10.prelist
  cat ls2_R10.prelist | sort -u > ls2_R10.list

cat leming.counts | sed -e 's/rno/AARno/' | gawk '{n++;if(n==1)printf("\t");print;}' | transpose > toto30
cat toto30 | gawk -F '\t' '{split($1,a,"_");printf("%s_%s\t%s\t%s",a[2],a[3],a[4],a[5]);for(i=2;i<=NF;i++){nf=NF;printf("\t%s",$i);}printf("\n");}' | sort -k 1,1 -k 2n > toto31
cat toto31 | gawk -F '\t' '{printf("%s_%s_%s",$1,$2,$3);for(i=4;i<=NF;i++){t[i]+=$i;nf=NF;printf("\t%s",$i);}printf("\n");}END{printf("Total");for(i=4;i<=nf;i++)printf("\t%d",t[i]);printf("\n");}' > toto32
cat toto32 | grep ___ > toto33
cat toto32 | grep Total >> toto33
cat toto32 | grep -v Total | grep -v ___  >> toto33
cat toto33 | transpose | sed -e 's/AARno/rno/' > toto34
cat toto34 | grep  ___  > toto35
cat toto34 | grep -v  ___ | sort -k 2nr  >> toto35

cat toto35 > leming.counts.sorted.txt
\cp leming.counts.sorted.txt ~/AW/Rat_DATA/


###################################################################################
## phase a0Ba: telomeres and polyA

phasea0Ba: 
echo -n "phasea0Ba start : "
date

if (! -d tmp/Bloom) mkdir tmp/Bloom
foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -d tmp/Bloom/$run) $mkDir Bloom $run
  if (! -e tmp/Bloom/$run/a0B.telomere_distribution.txt ) then
     scripts/submit tmp/Bloom/$run/a0B.any  "scripts/a0B.Bloom.tcsh telomere $run any" UGE4
  endif
end

goto phaseLoop

phasea0Bua: 
echo "phasea0Bua start : "
date

if (! -d tmp/Bloom) mkdir tmp/Bloom
foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -d tmp/Bloom/$run) $mkDir Bloom $run
  if (! -e tmp/Bloom/$run/a0B.unaligned.telomere_distribution.txt) then
    scripts/submit tmp/Bloom/$run/a0B.unaligned  "scripts/a0B.Bloom.tcsh telomere $run unaligned"
  endif
end

goto phaseLoop

###################################################################################
## phase a0Br: telomeres and polyA global report

phasea0Br: 
echo "phasea0Br start : "
date
if (! -d RESULTS/Mapping) mkdir RESULTS/Mapping
scripts/a0B.Bloom.tcsh telomereReport anyRun any

goto phaseLoop

phasea0Bur: 
echo "phasea0Br start : "
date
if (! -d RESULTS/Mapping) mkdir RESULTS/Mapping
scripts/a0B.Bloom.tcsh telomereReport anyRun  unaligned

goto phaseLoop

###################################################################################
## phase a0mr: map the telomeres fragments on the genome

phasea0Bm: 
echo "phasea0Bm start : "
date
if (! -d RESULTS/Mapping) mkdir RESULTS/Mapping
scripts/a0B.Bloom.tcsh telomereReport anyRun any

foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (-e tmp/Bloom/$run/a0Bm.err) continue    
  if (! -e tmp/Bloom/$run/a0B.telomere_hits.txt) continue     
  scripts/submit tmp/Bloom/$run/a0Bm "scripts/a0B.Bloom.tcsh telomereRemap $run any"
end

goto phaseLoop

###################################################################################
## phase a0P: profiles

phasea0P: 
echo "phasea0P start : "
date

if (! -d tmp/Profiles) mkdir tmp/Profiles 

echo "date" > tmp/Profiles/_r
foreach run (`cat MetaDB/$MAGIC/RunList`)

  if (! -d tmp/Profiles/$run) $mkDir Profiles $run
  foreach prefix (f f1 f2 f3)
    set n=`cat Fastc/$run/LaneList | sed -e "s/$run\///" | gawk "/$prefix\./{n++}END{print n+0}"`
    if ($n == 0) continue
    if ( ! -e tmp/Profiles/$run/$prefix.readsBeforeAlignment.1.profile.txt) then
	scripts/submit tmp/Profiles/$run/a0P  "scripts/a0P.profile.tcsh $run $prefix"
    endif
  end
  
end
echo -n  "phase a0P done: "
date
goto phaseLoop

ls -ls RESULTS/*Before*txt | gawk '{if($6==249)printf("\\rm %s\n",$10);}' > _k
source _k

goto phaseLoop

# export the unaligned concensus sequence
 cat tmp/Profiles/BL10_200_B3_D2_S12/f2.unaligned.1.txt  | gawk '{m=0;for(i=5;i<=NF;i++)if($i>m){m=$i;k=i;}printf ("%s",substr("ATGC",k-5,1));}END{printf("\n");}'


# quality profiles of the original fastq files
gunzip -c  Fastc/KIDNEY/kidney/kidney_dummer_kopp_2010_06_15.fastq.original.gz | bin/dna2dna -gvplot 100 -o tmp/Profiles/$run/readsBeforeAlignment.quality  -title "Quality profile in the raw data: Kidney project file received 2010_06_15" -I fastq -qualityPlot
cp  tmp/Profiles/$run/readsBeforeAlignment.quality.profile.txt RESULTS

### obsolete code, 
   set v1=""
    set v2=""
# the leftClipInPhase is very specific, it does not matter that we did not specialize the list per protocol
    set plateforme=`cat MetaDB/$MAGIC/run2machine2adaptors.txt | gawk 'BEGIN{m="NULL";}{if($1 == run && $2 != machine) m=$2;}END{print m;}' run=$run`
    if ($plateforme == "Illumina" && $?exitAdaptorIllumina)  then
      set v1=" -leftClipInPhase   $exitAdaptorIllumina "
    endif
    if ($plateforme == "Roche_454" && $?exitAdaptorRoche_454) then
      set v1=" -leftClipInPhase  $exitAdaptorRoche_454 "
    endif
    if ($plateforme == "SOLiD" && $?exitAdaptorSOLiD) then
      set v1="  -leftClipInPhase $exitAdaptorSOLiD "
    endif
    if ($plateforme == "PGM" && $?exitAdaptorPGM) then
      set v1="  -leftClipInPhase $exitAdaptorPGM "
    endif
    if ($plateforme == "Helicos" && $?exitAdaptorHelicos) then
      set v1="  -leftClipInPhase  $exitAdaptorHelicos  "
    endif
# the right clipping before alignment is too aggressive
#    if ($?exitAdaptorRaw) then
#      set v2=" -rightClipOn $exitAdaptorRaw " 
#    endif

###################################################################################
###################################################################################
## phase echo '    createTestSet: Make a test set of 10M 50mers, matching the RefSeq, with artificial SNPs at position 50,100,150,200,..."

phasecreateRNATestSet:
phasecreateMitoTestSet:
phasecreateGenomicTestSet:

set xMillion=800000
if ($2 != "") then
  set n1=`echo $2 | gawk '{printf("%d",0+$1);}'`
  if ($n1 < 1 || $n1 > 10) then
    echo "MAGIC createTestSet <n> expects n to be a number of millions between 1 and 10 and will create 6n million reads"
    echo "Invalid <n> parameter: MAGIC createTestSet $2"
    exit 1
  endif
  @ xMillion = 1000000 * $n1
endif

echo "createTestSet:  6 times $xMillion reads (forward, reverse, SOLiD) times (exact, SNP)"

if (! -d  TestData) mkdir  TestData
set myselect=""

if ($phase == createRNATestSet) then
  if (! -e  TARGET/Targets/$species.RefSeq.fasta.gz) then
    echo "Missing file TARGET/Targets/$species.RefSeq.fasta.gz"
    echo "I quit"
    goto phaseLoop
  endif
  set mytarget=TARGET/Targets/$species.RefSeq.fasta.gz
  gunzip -c $mytarget | gawk '/^>/{if(g){n1=nn[g]+0;if(n+0>n1+0){nn[g]=n;g2m[g]=m;}}m=substr($1,2);split(m,aa,"|");g=aa[3];n=0;next;}{n+=length($1);}END{for (g in g2m)print g2m[g];}' >  TestData/RefSeq.longest.list  
  set myselect=" -select TestData/RefSeq.longest.list "
  echo '    createRNATestSet: Make a 2 test sets of x Million 50mers, covering 20 times the RefSeq, one exact one with with artificial SNPs at position 100,200,...'
endif
if ($phase == createGenomicTestSet) then
  if (! -e  TARGET/Targets/$species.genome.fasta.gz) then
    echo "Missing file TARGET/Targets/$species.genome.fasta.gz"
    echo "I quit"
    goto phaseLoop
  endif
  if ($species == worm) then
    set chrom=III
    set x1=1000000
    set x2=1500000
  else
    # use CYP2C18andCYP2C19: 212kb
    set chrom=10
    set x1=96400510
    set x2=96650000
  endif
  if (! -e TestData/genome_section.fasta.gz) then
    bin/dna2dna -i TARGET/Targets/$species.genome.fasta.gz -get $chrom -leftClipAt $x1 -rightClipAt $x2 -I fasta -O fasta -gzo -o TestData/genome_section
  endif
  set mytarget=TestData/genome_section.fasta.gz
  echo '    createGenomicTestSet: Make a 2 test sets of x Million 50mers, covering 20 times a section of the genome, one exact one with with artificial SNPs at position 100,200,...'
endif
if ($phase == createMitoTestSet) then
  if (! -e  TARGET/Targets/$species.mito.fasta.gz) then
    echo "Missing file TARGET/Targets/$species.mito.fasta.gz"
    echo "I quit"
    goto phaseLoop
  endif
  if (! -e TestData/genome_section.fasta.gz) then
    gunzip -c  TARGET/Targets/$species.mito.fasta.gz  TARGET/Targets/$species.rrna.fasta.gz | bin/dna2dna -I fasta -O fasta -gzo -o TestData/genome_section
  endif
  set mytarget=TestData/genome_section.fasta.gz
  echo '    createMitoTestSet: Make a 2 test sets of x Million 50mers, covering 20 times the mito, one exact one with with artificial SNPs at position 100,200,...'
endif

# construct a fastc file with a set of stranded 50 mers
# construct the fasta forward reads
if (! -e TestData/test.exact.fasta.gz) then
# construct a fasta file ordered by length

   bin/dna2dna $myselect -i $mytarget -I fasta -createTestSet -$xMillion -ctsL 50 -ctsStep 1 -O fasta -gzo -o TestData/exact_ForwardStrand
   bin/dna2dna $myselect -i $mytarget -I fasta -createTestSet  $xMillion -ctsL 50 -ctsStep 1 -O fasta -gzo -o TestData/variant_ForwardStrand
endif
# construct the fasta reverse reads
   bin/dna2dna -i TestData/exact_ForwardStrand.fasta.gz -O fasta -gzo -complement -o TestData/exact_ReverseStrand
   bin/dna2dna -i TestData/variant_ForwardStrand.fasta.gz  -O fasta -gzo -complement -o TestData/variant_ReverseStrand

# construct the SOLiD reads
   bin/dna2dna -i TestData/exact_ForwardStrand.fasta.gz -O csfasta -gzo -o TestData/exact_SOLiD
   bin/dna2dna -i TestData/variant_ForwardStrand.fasta.gz  -O csfasta -gzo  -o TestData/variant_SOLiD

echo toto | gawk '{printf("Run exact_ForwardStrand\n-D File\nGroup TestGroup\nSample RefSeq\nTotal\nForward\nIllumina\nFile fasta TestData/exact.F.fasta.gz\nde_duo\nSNP\n\n");}' >  TestData/test.run.ace
echo toto | gawk '{printf("Run variant_ForwardStrand\n-D File\nGroup TestGroup\nSample RefSeq\nTotal\nForward\nIllumina\nFile fasta TestData/snps.F.fasta.gz\nde_duo\nSNP\n\n");}' >>  TestData/test.run.ace
echo toto | gawk '{printf("Run exact_ReverseStrand\n-D File\nGroup TestGroup\nSample RefSeq\nTotal\nReverse\nIllumina\nFile fasta TestData/exact.R.fasta.gz\nde_duo\nSNP\n\n");}' >>  TestData/test.run.ace
echo toto | gawk '{printf("Run variant_ReverseStrand\n-D File\nGroup TestGroup\nSample RefSeq\nTotal\nReverse\nIllumina\nFile fasta TestData/snps.R.fasta.gz\nde_duo\nSNP\n\n");}' >>  TestData/test.run.ace

echo toto | gawk '{printf("Run exact_SOLiD\n-D File\nGroup TestGroup\nSample RefSeq\nTotal\nForward\nSOLiD\nFile ccfa TestData/exact.F.ccfa.gz\nde_duo\nSNP\n\n");}' >>  TestData/test.run.ace
echo toto | gawk '{printf("Run variant_SOLiD\n-D File\nGroup TestGroup\nSample RefSeq\nTotal\nForward\nSOLiD\nFile ccfa TestData/snps.F.ccfa.gz\nde_duo\nSNP\n\n");}' >>  TestData/test.run.ace

echo toto | gawk '{printf("Run TestGroup\nW_colour_ns RED\nW_new_exon\n\n");}' >>  TestData/test.run.ace

bin/tacembly  MetaDB <<EOF > /dev/null
  pparse  TestData/test.run.ace
  query find run SOLiD && Is_run
  edit group ExactOrSNP_SOLiD
  query find run NOT SOLiD && Is_run && Forward
  edit group ExactOrSNP_ForwardFA
  query find run NOT SOLiD && Is_run && Reverse
  edit group ExactOrSNP_reverseFA
  query find groups
  edit SNP
  edit de_duo
  find run
  edit project $MAGIC
  edit Total
  edit Title "RNA test"
  save
  quit
EOF

gunzip -c TestData/variant_ForwardStrand.fasta.gz | gawk '/^>/{i=index ( $1,"@" ) ; printf ( "Variant %s\n",substr ( $1,2,i-2 )) ; }' | $tab_sort -u  >  TestData/Variant.list
cat  TestData/Variant.list | gawk '{print ; printf("dbSNP\n\n");}' >  TestData/Variant.ace

if ($phase == createGenomicTestSet) then
  bin/tacembly  MetaDB <<EOF > /dev/null
    find run
    edit -D protocol
    edit protocol genome
    edit -D sample
    edit sample "Genome Test CYP2C19"
    edit Title "Genome test"
    save
    quit
EOF


gunzip -c TestData/variant_ForwardStrand.fasta.gz | gawk '/^>/{i=index ( $1,"@" ) ; z=substr ( $1,5,i-5 );n=0;u=0;for(k=1;u==0 && k<length(z);k++){cc=substr(z,k,1);if(cc<"A"){n=10*n + cc;}else{ u=1;}} printf ( "Variant 10:%d%s\t//\t%s\n",n+96400510-1,substr(z,k-1),substr(z,k-1)) ; }' | $tab_sort -u  >  TestData/Variant.list
cat  TestData/Variant.list | gawk '{print ; printf("Type %s\ndbSNP\n\n",$4);}' >  TestData/Variant.ace

endif


echo hello1
if ($phase == createGenomicTestSet) then
  echo 'setenv MOLECULE_TYPE DNA' > LIMITS
  echo 'setenv Strategy Genome' >> LIMITS
  echo 'setenv chromSetAll 10' >> LIMITS
  echo 'setenv targets "SpikeIn mito genome gdecoy" ' >> LIMITS
  echo 'setenv seedLength 20' >> LIMITS
  echo 'setenv minAli 22' >> LIMITS
endif
if ($phase == createRNATestSet) then
  echo 'setenv MOLECULE_TYPE RNA' > LIMITS
  echo 'setenv Strategy RNA_seq' >> LIMITS
  echo 'setenv targets "SpikeIn mito rrna rnaGene RefSeq av genome gdecoy" '>> LIMITS
  echo 'setenv seedLength 20' >> LIMITS
  echo 'setenv minAli 40' >> LIMITS
endif
if ($phase == createMitoTestSet) then
# do not align on mito, we want to see the mito cognates
  echo 'setenv MOLECULE_TYPE DNA' > LIMITS
  echo 'setenv Strategy Genome' >> LIMITS
  echo 'setenv targets "SpikeIn rnaGene genome gdecoy" '>> LIMITS
  echo 'setenv seedLength 20' >> LIMITS
  echo 'setenv minAli 40' >> LIMITS
endif

  echo 'setenv minCoveron 20' >> LIMITS
  echo 'unsetenv exitAdaptorSOLiD'            >> LIMITS
  echo 'unsetenv exitAdaptorIllumina'            >> LIMITS
  echo 'unsetenv exitAdaptorPGM'            >> LIMITS
  echo 'unsetenv exitAdaptorRaw'             >> LIMITS
  echo 'unsetenv  inPhaseEntryAdaptor'             >> LIMITS

echo hello2

# NOTICE: we deal here with the color files and fasta files in a uniform way as fasta
#  then rename them to fastc so that the identifiers are conserved accross all the runs
# split the file in fasta format, so as not to lose the identifiers
# we split by 1/2M whichis nice for testing
# in real life we recommend 5M 50-mers or 250Mbp per file (-splitMb 250) which should be appropiate for 8Gb machines

mkdir Fastc
foreach ff (variant_ForwardStrand variant_ReverseStrand exact_ForwardStrand exact_ReverseStrand )
  mkdir Fastc/$ff
  gunzip -c TestData/$ff.*a.gz | bin/dna2dna -I fasta -O fasta -gzo -split 500000 -o Fastc/$ff/f
  foreach ff2 (`ls Fastc/$ff/f.*.fasta.gz`)
    mv $ff2 `echo $ff2 | sed -e 's/fasta/fastc/'`
  end
end
foreach ff (variant_SOLiD exact_SOLiD)
  mkdir Fastc/$ff
  gunzip -c TestData/$ff.*a.gz | bin/dna2dna -I csfasta -O csfasta -gzo -split 500000 -o Fastc/$ff/f 
  foreach ff2 (`ls Fastc/$ff/f.*.csfasta.gz`)
    mv $ff2 `echo $ff2 | sed -e 's/csfasta/fastc/'`
  end
end

# kill empty files which are the zero left over of the division by 1M
ls -ls Fastc/*/*.fastc.gz | gawk '{if($6 < 50)printf("\\rm %s\n", $10);}' > _k
source _k

# do not phaseLoop after createTestSet
exit 0
goto phaseLoop

## use the mitotest to create a mask on the genome

gunzip -c tmp/COUNT/exact_ForwardStrand/f.1.hits.gz | $tab_sort -k 11,11 -k 12,12n -k 13,13n | gawk '{c=$11;a1=$12;a2=$13;if(a1>a2){a0=a1;a1=a2;a2=a0;}if(c!=oldc || a1>olda2+120){if (oldc)printf("%s\t%d\t%d\n", oldc,olda1-0,olda2+0);olda1=a1;oldc=c}olda2=a2;}END{printf("%s\t%d\t%d\n", oldc,olda1-0,olda2+0);}' | $tab_sort -k 1,1n -k 2,2n > TARGET/Targets/genomeMask.txt
cat TARGET/Targets/genomeMask.txt | gawk '{n++;n1+=$3-$2;}END{print n,n1}'   

## use the files in ftp-SEQC
foreach ff (exact.forward        exact.reverse        variant.forward        variant.reverse exact.forward.solid  exact.reverse.solid  variant.forward.solid  variant.reverse.solid )
  echo "Run $ff" >> r.ace
  echo "File" >> r.ace
  echo "polyA" >> r.ace
  echo "NonStranded" >> r.ace
  echo "Project TEST" >> r.ace
  echo >> r.ace
end

###################################################################################
###################################################################################
## phase a1/a2 align with clipalign
## speyrubo  is the archetypal mito pseudogene present in the genome

phasea0S:

if (! -d tmp/ShortFragments) mkdir tmp/ShortFragments

foreach run (`cat MetaDB/$MAGIC/RunPairedList`)
  if (! -d tmp/ShortFragments/$run) $mkDir ShortFragments $run
  foreach lane (`cat Fastc/$run/LaneList`)
    if (! -e tmp/ShortFragments/$lane.fragments) then
      scripts/submit tmp/ShortFragments/$lane "scripts/a0S.stitch.tcsh $lane"
    endif
  end
end

goto phaseLoop

###################################################################################
###################################################################################
## phase a1/a2 align with clipalign
## speyrubo  is the archetypal mito pseudogene present in the genome

phasea123:

if ($USEMAGICBLAST == 1) then
  if (-e ~/bin/magicblast && ! -x bin/magicblast) then
    pushd bin
    ln -s `~/bin/magicblast`
    popd
  endif
  if (! -x bin/magicblast) then
    pushd bin
    ln -s `which magicblast`
    popd
  endif
  if (! -x bin/magicblast) then
    echo "missing program bin/magicblast"
    exit 1
  endif
endif

if ($USEMAGICBLAST == 1) scripts/a123M.magicblast.tcsh makeDB
# if ($USEMAGICBLAST == 2) scripts/a123MH.matchhits.tcsh makeDB

if (! -d tmp/$MAGIC_COUNT_DIR) mkdir tmp/$MAGIC_COUNT_DIR
if (! -d tmp/Unaligned) mkdir tmp/Unaligned

bin/tacembly MetaDB <<EOF
  query find run project == $MAGIC AND  Remove_inserts_shorter_than 
  bql -o MetaDB/$MAGIC/Remove_inserts_shorter_than select r,m from r in @, m in r->Remove_inserts_shorter_than 
EOF
touch  MetaDB/$MAGIC/Remove_inserts_shorter_than

foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -e Fastc/$run/fastc_count.ace) then
    echo "Fastc/$run/fastc_count.ace missinng"
    echo "Please run phase a0C"
    exit 1
  endif
  set minInsertLength=`cat  MetaDB/$MAGIC/Remove_inserts_shorter_than  | gawk '{gsub(/\"/,"",$1);if($1==run) m=$2;}END{print 0+m;}' run=$run`
 
  if (! -d tmp/$MAGIC_COUNT_DIR/$run) then
    $mkDir $MAGIC_COUNT_DIR $run
    bin/clipalign --hits_file_caption -o  tmp/$MAGIC_COUNT_DIR/$run/README
  endif
  set ok=1
  foreach lane (`cat Fastc/$run/LaneList`)
    if ($USEMAGICBLAST == 1) then
        if (! -e  tmp/MAGICBLAST/$lane.done) then
          scripts/submit tmp/MAGICBLAST/$lane.a123 "scripts/a123M.magicblast.tcsh ALIGN $run $lane" 32G
        endif
      continue 
    endif
    if ($USEMAGICBLAST == 2) then
        if (! -d tmp/MATCHHITS) mkdir tmp/MATCHHITS
        if (! -d tmp/MATCHHITS/$run) $mkDir MATCHHITS $run
        if (! -e tmp/MATCHHITS/$lane.done) then
          scripts/submit tmp/MATCHHITS/$lane.a123 "scripts/a123MH.matchhits.tcsh ALIGN $run $lane" 32G
        endif
      continue 
    endif

    if (! -e tmp/$MAGIC_COUNT_DIR/$lane.hits.gz || ( -e tmp/PLEASE_UPDATE && ! -e tmp/$MAGIC_COUNT_DIR/$lane.update.done)) then 
      # echo $lane
      foreach target ($targets)
        if (! -d tmp/PHITS_$target) mkdir tmp/PHITS_$target
        if (! -d tmp/PHITS_$target/$run) $mkDir PHITS_$target $run
        if (! -d tmp/Unaligned/$run) $mkDir Unaligned $run
      end
      if (-e tmp/COUNT/$run/Venn.u.txt) \rm tmp/COUNT/$run/Venn.*.txt
      if (-e tmp/COUNT/$run/c2.alistats.ace) \rm  tmp/COUNT/$run/c2.*
      if (-e RESULTS/Mapping/$MAGIC.job_statistics.txt) \rm RESULTS/Mapping/$MAGIC.job_statistics.txt
      if ( -e tmp/PLEASE_UPDATE) touch  tmp/$MAGIC_COUNT_DIR/$lane.update.done
      scripts/submit tmp/COUNT/$lane.a123 "scripts/alignAndSelectBest.tcsh $run $lane $minInsertLength $USEMAGICBLAST"    32G
      set ok=0
    endif
  end
  if ($ok == 0 && -e tmp/COUNT/$run/c2.alistats.ace) \rm tmp/COUNT/$run/c2.*
end

goto phaseLoop

phased6:
 echo -n "Phase d6:  align on the candidate introns "
 set pp=3
 date

foreach target (introns)

  source scripts/target2target_class.txt
  set targetFasta=$target

  set showOverhang=""
  set Xintrons="-exactTargetStart 93 -exactTargetStop 108"
  setenv minAli 35
  
  if (0 || ! -e TARGET/Targets/$species.introns.fasta.gz) then
    gunzip -c  tmp/introns/introns.candidates/*/introns.fasta.gz  | gzip > TARGET/Targets/$species.introns.fasta.gz
  endif

  if (! -d tmp/PHITS_$target) mkdir tmp/PHITS_$target

# | grep Ghs99
  foreach run (`cat MetaDB/$MAGIC/RunList`)
echo $run
    if (! -e Fastc/$run/fastc_count.ace) then
      echo "Fastc/$run/fastc_count.ace missinng"
      echo "Please run phase a0C"
      exit 1
    endif
    if (! -d tmp/PHITS_$target/$run) $mkDir  PHITS_$target $run

    set isSplice=" "
    set slBonus=" "

    set bonus=-6
    set targetBonus="-targetBonus $bonus"

    set clipPolyA=" "
    set clipPolyT=" "
    foreach run2 (`cat RunRnaList`)
      if ($run == $run2) then
        if ($target == genome || $target == gdecoy || $target == mito) then
          set clipPolyA="-clipPolyA"
          set clipPolyT="-clipPolyT"
        else
          set clipPolyA="-SclipPolyA"
          set clipPolyT="-SclipPolyT"
        endif
      endif
    end


    set pair=""
    foreach run2 (`cat MetaDB/$MAGIC/RunPairedList`)
      if ($run == $run2) then
        set pair="-pair 500"
      endif
    end

    set isSolid=" "
    set iiSolid=0
    foreach run2 (`cat MetaDB/$MAGIC/RunSolidList`)
      if ($run == $run2) set iiSolid=1
    end
    if ($iiSolid == 1) set isSolid="-solidC"

    set isStranded=" "
    foreach run2 (`cat MetaDB/$MAGIC/RunForwardList`)
      if ($run == $run2 && $target != genome && $target !~ chrom* && $target != gdecoy  && $target != rrna && $target != mito) set isStranded="-stranded $bonusStrand"
    end
    foreach run2 (`cat MetaDB/$MAGIC/RunReverseList`)
      if ($run == $run2 && $target != genome && $target !~ chrom* && $target != gdecoy  && $target != rrna && $target != mito) set isStranded="-stranded -$bonusStrand"
    end
   set isSplice=" "

   if ($species == worm) set slBonus="-slBonus 5"

   echo "## $Strategy #$target $run $isSolid $clipPolyT  $isSplice $slBonus $isStranded $targetBonus"

   foreach lane (`cat Fastc/$run/LaneList`)
 # echo $target $lane
      if (-e tmp/PHITS_$target/$lane.hits.gz) continue
      if (-e tmp/PHITS_$target/$lane.done) continue

      set minEntropy4=`echo $minAli | gawk '{printf("%d",int((2.0*$1)/3));}'`
      set off3="1 -seedShift 5"
      if ($target == gdecoy) set off3="3 -seedShift 50 -decoy"

      set t2g=""
      if (-e  TARGET/MRNAS/$species.$target.transcript2gene.txt.gz) set t2g="-target2gene TARGET/MRNAS/$species.$target.transcript2gene.txt.gz"

  set v2=""

    set plateforme=`cat MetaDB/$MAGIC/run2machine2adaptors.txt | gawk 'BEGIN{m="NULL";}{if($1 == run && $2 != machine) m=$2;}END{print m;}' run=$run`
    if ($plateforme == "Illumina" && $?exitAdaptorIllumina) then
      set v2=" -exitAdaptor $exitAdaptorIllumina "
    endif
    if ($plateforme == "Roche_454" && $?exitAdaptorRoche_454) then
      set v2="-exitAdaptor $exitAdaptorRoche_454 "
    endif
    if ($plateforme == "SOLiD" && $?exitAdaptorSOLiD) then 
      set v2="   -exitAdaptor $exitAdaptorSOLiD "
    endif
    if ($plateforme == "PGM" && $?exitAdaptorPGM) then
      set v2="  -exitAdaptor $exitAdaptorPGM "
    endif

    if ($plateforme == "Helicos" && $?exitAdaptorHelicos) then
      set v2=" -exitAdaptor $exitAdaptorHelicos "
    endif

      set prevScore=""
      if ($target == seqc3 || $target == introns) then
        if (! -e tmp/COUNT/$lane.hits.gz) continue
        if (! -e tmp/COUNT/$lane.best_score.gz) then
          gunzip -c tmp/COUNT/$lane.hits.gz | gawk -F '\t' '/^#/{next;}{p=$1;s=$2;if(p==oldp)next;printf("%s\t%s\n",p,s);}' | gzip > tmp/COUNT/$lane.best_score.gz
        endif
      endif
      if (-e  tmp/COUNT/$lane.best_score.gz) then
        set prevScore=" -previousScore  tmp/COUNT/$lane.best_score.gz "
      else 
        if ($target == gdecoy && -e  tmp/PHITS_genome/$lane.hits.gz) then
          set prevScore=" -previousScore  tmp/PHITS_genome/$lane.hits.gz "
        endif
      endif

set targetMask=""
if (-e TARGET/Targets/$species.$target.mask.txt) set targetMask="-targetMask TARGET/Targets/$species.$target.mask.txt"
  echo "bin/clipalign -i Fastc/$lane.fastc.gz -gzo  $isSolid -t TARGET/Targets/$species.$targetFasta.fasta.gz  -maxHit $maxHit $clipPolyA  $clipPolyT -minEntropy $minEntropy4 -seedLength $seedLength -probeMinLength $minAli  -clipN $clipN -minAli $minAli $isSplice $slBonus  $targetBonus  $Xintrons $isStranded -seedOffset $off3 -intronMaxLength  $intronMaxLength -o tmp/PHITS_$target/$lane -showTargetPrefix -target_class $target_class $t2g $v2 $prevScore -showOverhang $targetMask" >  tmp/PHITS_$target/$lane.out
   
  scripts/submit tmp/PHITS_$target/$lane "bin/clipalign -i Fastc/$lane.fastc.gz  $isSolid -t TARGET/Targets/$species.$targetFasta.fasta.gz  -maxHit $maxHit $clipPolyA  $clipPolyT -minEntropy $minEntropy4 -seedLength $seedLength -probeMinLength $minAli  -clipN $clipN -minAli $minAli $isSplice $slBonus  $targetBonus  $Xintrons $isStranded -seedOffset $off3 -intronMaxLength  $intronMaxLength -gzo -o tmp/PHITS_$target/$lane -showTargetPrefix -target_class $target_class $t2g $v2 $prevScore $showOverhang -strategy $Strategy $targetMask" 

    end
  end
end

goto phaseLoop
# -doubleSeed

#######################################################################################
## Count tags aligning everywhere
## speyrubo  is the archetypal mito pseudogene present in the genome
## notera is the archetypic pseudo ribosomic gene present in the genome

phasea3:
echo "Obsolete, use a123"
goto phaseLoop

###############################################################
## ali_clean_up: remove all alignment files if an error is reported in tmp/COUNT/$lane.a123.err

phaseali_clean_up:
echo -n 'phase ali_clean_up: remove all alignment files if an error is reported in tmp/COUNT/$lane.a123.err'
date

if (-e _cleanup) \rm _cleanup
touch _cleanup
foreach lane (`cat MetaDB/$MAGIC/LaneList`)
  set ff=tmp/COUNT/$lane.a123.err
  set ok=0
  if (-e $ff) then
    set ok=`cat $ff | gawk '/Status/{if (index ($0, "= 0") > 0) ok=1;}END{print ok+0}'`
  endif
  if ($ok < 1) then
    echo $lane | gawk '{printf("\\rm tmp/PH*/%s.* tmp/COUNT/%s.*\n",$1,$1);}' >> _cleanup
  endif
end

wc _cleanup
echo "please check the file _cleanup,if it seems correct type:  csh _cleanup"

goto phaseLoop

###############################################################
## Evaluate the paired end statistics

phasea5:
echo -n "phase a5:  Evaluate the bar code statistics "
date

goto phaseLoop

###############################################################
## Evaluate the fastq qualities

phasea6:
echo -n "phase a6:  Evaluate the fastq qualities "
date
 goto phaseLoop

if (! -d tmp/ALIa) goto phaseLoop
if (! -d tmp/QUAL) mkdir tmp/QUAL

# get the file names
setenv ici `pwd`
bin/tacembly MetaDB <<EOF > /dev/null
  query find run  project=$MAGIC AND File 
  bql -a -o tmp/QUAL/run2file.txt select r,ft,f from r in @, ft in r->file, f in ft[1] 
  quit
EOF

foreach run (Rhs472 Rhs478 Rhs485 Rhs488)
# select the first file name
  set ff=`cat  tmp/QUAL/run2file.txt | gawk '{gsub(/\"/,"",$0);gsub(/\\/,"",$0);if($1==run && n<1) {n++;printf(" %s ",$2);}}' run=$run`
  if ($ff != fastq) continue
  set ff=`cat  tmp/QUAL/run2file.txt | gawk '{gsub(/\"/,"",$0);gsub(/\\/,"",$0);if($1==run && n<1) {n++;printf(" %s ",$3);}}' run=$run`

# ALIa countains the renaming, 
  if (-d tmp/ALIa/$run) then
    scripts/submit tmp/QUAL/$run "gunzip -c tmp/ALIa/$run/*.hits.gz | bin/bestali -fastqAnalysis $ff -run $run -o tmp/QUAL/$run"
    continue
  endif

end

goto phaseLoop

###############################################################
## Evaluate the fastq qualities
## draft for this phase

gunzip -c tmp/COUNT2/Rhs444/g.*.hits.gz | gawk -F '\t' '{p=$1;if(p==oldp)next;oldp=p;if(index($16,"62")>0)next;{split(p,aa,":");split(aa[5],bb,"#");print aa[3] "\t" aa[4] "\t" bb[1] "\t" bb[2] ;}}' > tmp/QUAL/Rhs444.coord_no_error_at_62.test.txt &
gunzip -c tmp/COUNT2/Rhs444/g.*.hits.gz | gawk -F '\t' '{p=$1;if(p==oldp)next;oldp=p;if(index($16,"62")>0){split(p,aa,":");split(aa[5],bb,"#");print aa[3] "\t" aa[4] "\t" bb[1] "\t" bb[2] ;}}' > tmp/QUAL/Rhs444.coord_with_error_at_62.test.txt &
gunzip -c tmp/COUNT2/Rhs444/g.*.hits.gz | gawk -F '\t' '{p=$1;if(p==oldp)next;oldp=p;if(index($16,"72")>0){split(p,aa,":");split(aa[5],bb,"#");print aa[3] "\t" aa[4] "\t" bb[1] "\t" bb[2] ;}}' > tmp/QUAL/Rhs444.coord_with_error_at_72.test.txt &
gunzip -c tmp/COUNT2/Rhs444/g.*.hits.gz | gawk -F '\t' '{p=$1;if(p==oldp)next;oldp=p;if(index($16,"72")>0)next;{split(p,aa,":");split(aa[5],bb,"#");print aa[3] "\t" aa[4] "\t" bb[1] "\t" bb[2] ;}}' > tmp/QUAL/Rhs444.coord_no_error_at_72.test.txt &

set run=Rhs444
foreach yn (with no)
  foreach pos (62 72)
    foreach col (1 2 3)
      cat  tmp/QUAL/$run.coord_"$yn"_error_at_$pos.test.txt | bin/histo -title $run.coord_"$yn"_error_at_"$pos"_column_$col -plain -columns $col -o tmp/QUAL/$run.$yn.$pos.col$col -plot -w 1000
    end
  end
end

# get the list of tags with error
gunzip -c tmp/COUNT2/Rhs444/g.*.hits.gz | gawk -F '\t' '{p=$1;if(p==oldp)next;oldp=p;if(index($16,"72")>0)print p}' > tmp/QUAL/Rhs444.coord_with_error_at_72.list
gunzip -c tmp/COUNT2/Rhs444/g.*.hits.gz | gawk -F '\t' '{p=$1;if(p==oldp)next;oldp=p;if(index($16,"62")>0)print p}' > tmp/QUAL/Rhs444.coord_with_error_at_62.list
# plot their quality file
set pos=72
gunzip -c DATA/Rhs438_459/Proteome.Wang_HiScan.AB02FYACXX.2011_08/110809_H147_0150_AB02FYACXX/A_R_s_3_1_sequence.txt.gz | bin/dna2dna -I fastq -select  tmp/QUAL/Rhs444.coord_with_error_at_$pos.list -qualityPlot -gvplot 110  -title $run.1.error_at_"$pos" -count -o  tmp/QUAL/$run.1.coord_with_error_at_$pos &
gunzip -c DATA/Rhs438_459/Proteome.Wang_HiScan.AB02FYACXX.2011_08/110809_H147_0150_AB02FYACXX/A_R_s_3_2_sequence.txt.gz | bin/dna2dna -I fastq -select  tmp/QUAL/Rhs444.coord_with_error_at_$pos.list -qualityPlot -gvplot 110  -title $run.2.error_at_"$pos" -count -o  tmp/QUAL/$run.2.coord_with_error_at_$pos &
gunzip -c DATA/Rhs438_459/Proteome.Wang_HiScan.AB02FYACXX.2011_08/110809_H147_0150_AB02FYACXX/A_R_s_3_1_sequence.txt.gz | bin/dna2dna -I fastq -reject  tmp/QUAL/Rhs444.coord_with_error_at_$pos.list -qualityPlot -gvplot 110  -title $run.1.exact_at_"$pos" -count -o  tmp/QUAL/$run.1.coord_no_error_at_$pos &
gunzip -c DATA/Rhs438_459/Proteome.Wang_HiScan.AB02FYACXX.2011_08/110809_H147_0150_AB02FYACXX/A_R_s_3_2_sequence.txt.gz | bin/dna2dna -I fastq -reject  tmp/QUAL/Rhs444.coord_with_error_at_$pos.list -qualityPlot -gvplot 110  -title $run.2.exact_at_"$pos" -count -o  tmp/QUAL/$run.2.coord_no_error_at_$pos &

cat tmp/QUAL/Rhs444.2.coord_with_error_at_72.profile.txt ZZZZZ tmp/QUAL/Rhs444.2.coord_no_error_at_72.profile.txt | gawk 'BEGIN{zz=0;}/^ZZZZZ/{zz=1;next;}/^72/{old=0;for(q=2;q<=42;q++){n[q-2,zz]=old - $q ; old = $q ;}}END{printf("Quality\tFalse\tExact\tTotal\t%%false\t-10 log(f/t)");for(q=2;q<=40;q++){printf("\n%d",q);bad=n[q,0];good=n[q,1];tot=bad+good;tot2=tot;if(tot2==0)tot2=1;f=bad/tot2;z=0;if(f>0)z=-10*log(f)/log(10);printf("\t%d\t%d\t%d\t%.2f\t%.2f",bad,good,tot,100*f,z);}printf("\n");}'

cat tmp/QUAL/Rhs444.1.coord_with_error_at_62.profile.txt ZZZZZ tmp/QUAL/Rhs444.1.coord_no_error_at_62.profile.txt | gawk 'BEGIN{zz=0;}/^ZZZZZ/{zz=1;next;}/^72/{old=0;for(q=2;q<=42;q++){n[q-2,zz]=old - $q ; old = $q ;}}END{printf("Quality\tFalse at %d\tExact at %d\tTotal at %d\t%%false at %d\t-10 log(f/t)",pos,pos,poss,pos);for(q=2;q<=40;q++){printf("\n%d",q);bad=n[q,0];good=n[q,1];tot=bad+good;tot2=tot;if(tot2==0)tot2=1;f=bad/tot2;z=0;if(f>0)z=-10*log(f)/log(10);printf("\t%d\t%d\t%d\t%.2f\t%.2f",bad,good,tot,100*f,z);}printf("\n");}' pos=62

###############################################################
###############################################################

bin/tacembly ~/yk <<EOF > /dev/null
  query find mrna from_gene
  bql -a -o /home/mieg/ykdeep/MRNAS/$species.av.transcript2gene.txt select m,g from m in @ , tg in m->from_gene, g in tg->gene
  query find sequence  geneid AND ref_seq
  bql -a -o  hs.RefSeq.transcript2gene.txt select s,g from s in @, g in s->geneid
EOF
gzip  /home/mieg/ykdeep/MRNAS/$species.RefSeq.transcript2gene.txt
gzip /home/mieg/ykdeep/MRNAS/$species.HINV.transcript2gene.txt
cat  hs.RefSeq.transcript2gene.txt | gawk '/NULL/{next}{gsub(/\"/,"",$0);printf("%s\tGeneId_%s\n",$1,$2);}' | $tab_sort | gzip >  hs.RefSeq.transcript2gene.txt.gz


foreach chrom ($chromSetAll)
bin/tacembly ~/ykdeep/tmp/XH$chrom <<EOF > /dev/null
  query find mrna from_gene
  bql -a -o toto.transcript2gene.$chrom.txt select m,g from m in @ , tg in m->from_gene, g in tg->gene
EOF
end
# ATTENTION, the G_ tg by definition have no genebox
cat toto.transcript2gene.*.txt | gawk '/NULL/{m=$1;i=index(m,".");g=substr(m,2,i-2);printf("%s\t\"%s\"\n",m,g);next;}{print}' | gzip >  worm.av.transcript2gene.txt.gz
mv  worm.av.transcript2gene.txt.gz /home/mieg/ykdeep/MRNAS

## try to align the complete jensen on the mrnas using the AceView aligner
foreach off (16)
  bsub -q unified "bin/clipalign  -i J1/JensenInfoA/est.dna -t MRNAS/AceView.main_mrnas.fasta -minAli 30 -errRateMax 6 -minEntropy 16 -probeMinLength 100 -clipPolyA -errPosMax 100 -seedLength 16 -seedOffset $off >! tmp/PHITS_roche/UHR.$off.hits"
  bsub -q unified "bin/clipalign  -i J1/JensenInfoB/est.dna -t MRNAS/AceView.main_mrnas.fasta -minAli 30 -errRateMax 6 -minEntropy 16 -probeMinLength 100 -clipPolyA -errPosMax 100 -seedLength 16 -seedOffset $off >! tmp/PHITS_roche/Brain.$off.hits"
end

###
## tmp/PHITS main_aceview cloud RefSeq Vega EBI

## little trick to run a test
echo toto | gawk '/END/{for (i=1;i<=10;i++)printf("tail -n +%d Fastc/LIF_S/UHR/f.55.fastc | head -1000000 > toto.%d.fastc\n",1+1000000*(i-1),i);}' > _k
source _k

foreach ii (1 2 3 4 5 6 7 8 9 10)
  scripts/submit tmp/TEST/$ii.out "bin/clipalign -t MRNAS/RefSeq.fasta.gz -i tmp/TEST/toto.$ii.fastc.gz -gzo  -solidC -maxHit 10 -minAli 30 -errRateMax 6 -clipPolyA  -clipPolyT -minEntropy 16  -seedLength 16 -seedOffset 11 > tmp/TEST/RefSeq.$ii.hits.gz"
end

###################################################################################
## r2g1: RNA editing  see also phase s2r
phaser2g1:
  echo -n "phase r2g1 : realign the analigned pairs and the orphans in RNA-editing mode : "
  date
 
if ($Strategy != RNA_seq) goto phaseLoop

if (! -d tmp/RNA_editing) mkdir tmp/RNA_editing
foreach run (`cat MetaDB/$MAGIC/RunList`) 
  if (! -d tmp/Unaligned/$run) continue 
  if (! -d tmp/RNA_editing/$run) $mkDir RNA_editing $run
  foreach lane (`cat Fastc/$run/LaneList`)
    if (! -e tmp/COUNT/$lane.hits.gz) continue
    if (-e  tmp/RNA_editing/$lane.r1.done) continue
    scripts/submit tmp/RNA_editing/$lane.r1 "scripts/r1.rna_realign.tcsh $run $lane"
  end
end

 echo -n "phase r1 done"
goto phaseLoop

###################################################################################
## r2g4: RNA editing predictions
phaser2g4:
  echo -n "phase r2g4 : Run gene predictions using RNA editing counts : "
  date
 
  if ($Strategy != RNA_seq) goto phaseLoop
  if (! -d tmp/RNA_editing) goto phaseLoop
  scripts/geneindex.tcsh r2g4

goto phaseLoop

###################################################################################
## p1: parasites : extract the fasta file of unaligned reads
phasep1:

if (! -d tmp/Unaligned) mkdir tmp/Unaligned

# extract the fasta file of unaligned sequences
foreach run (`cat MetaDB/$MAGIC/RunList`) 
  if (! -d tmp/Unaligned/$run) $mkDir Unaligned $run
end
foreach lane (`cat MetaDB/$MAGIC/LaneList | $tab_sort -u`)
  if (-e tmp/COUNT/$lane.hits.gz && ! -e  tmp/Unaligned/$lane.fastc.gz) then

    gunzip -c tmp/COUNT/$lane.hits.gz | gawk '{if($1 != old) print $1;old=$1;}' > tmp/COUNT/$lane.ok
    if (-e tmp/COUNT/$lane.noInsert.gz) then
      gunzip -c tmp/COUNT/$lane.noInsert.gz >>  tmp/COUNT/$lane.ok
    endif
    if (-e  tmp/COUNT/$lane.ok.gz) \rm tmp/COUNT/$lane.ok.gz
    gzip  tmp/COUNT/$lane.ok
    scripts/submit  tmp/Unaligned/$lane  "bin/dna2dna -I fastc -i Fastc/$lane.fastc.gz -gzi -gzo  -minEntropy $minEntropy -reject  tmp/COUNT/$lane.ok.gz  -count -O fastc -o tmp/Unaligned/$lane"

  endif
end


goto phaseLoop

gunzip -c tmp/Unaligned/Va1/*.fastc.gz | bin/dna2dna -I fastc -gvplot 100 -o tmp/Unaligned/Rhs450/Rhs450.unaligned -title "Va1 unaligned sequences"

########################################################################################
## Unaligned: BLAST unmapped sequences
# tom madden says that for quasi exact hits Mail of 2009_04_08 in info we shoudl do
#  blastn -db nt -query SRRRRR.fsa -outfmt 7 -out out.new
#  megablast -d nt -i SRRRR.fsa -o out.old -m 9
#  -penalty -5       -min_raw_gap_score 100       -perc_identity 100
#                   -> at least 100 bp long      -> identical
megablast -d nt -i  f.4.unmapped.fastc.short -m 9  -o  f.4.unmapped.megablast.out.0 -D 0 -W 32 -f T -p 100 
megablast -d nt -i  f.4.unmapped.fastc.short -m 9  -o  f.4.unmapped.megablast.out.2 -D 2 -W 32 -f T -p 100 &
megablast -d nt -i  f.4.unmapped.fastc.short -m 9  -o  f.4.unmapped.megablast.out.3 -D 3 -W 32 -f T -p 100 &
date
echo "blastn -db nt -query tmp/Unaligned/$run/$lane.unmapped.fastc.short -outfmt  7 -out  tmp/Unaligned/$run/$lane.unmapped.blast.out"
time blastn -db nt -query tmp/Unaligned/$run/$lane.unmapped.fastc.short -outfmt  7 -out  tmp/Unaligned/$run/$lane.unmapped.blast.out
date
echo "blastn -db nt -query tmp/Unaligned/$run/$lane.unmapped.fastc.short -outfmt  7 -out  tmp/Unaligned/$run/$lane.unmapped.blast.out"
# time magicblast -db nt -query tmp/Unaligned/$run/$lane.unmapped.fastc.short -outfmt  7 -out  tmp/Unaligned/$run/$lane.unmapped.blast.out
date


#  -penalty -5       -min_raw_gap_score 100       -perc_identity 100
#                   -> at least 100 bp long      -> identical
phasep2:

foreach run (`cat MetaDB/$MAGIC/RunList`) 
  if (-e tmp/Unaligned/$run/gi.list) continue
  foreach lane (`cat Fastc/$run/LaneList`)
    if (-e  tmp/Unaligned/$lane.fastc.gz && ! -e  tmp/Unaligned/$lane.gi.list) then
      scripts/submit tmp/Unaligned/p2.megablast "scripts/p2.megablast.tcsh $run $lane"
    endif
  end
end

goto phaseLoop

phasep3: 
# list the corresponding gi
echo " " > tmp/Unaligned/_p3
foreach run (`cat MetaDB/$MAGIC/RunList`)  
  if (! -d tmp/Unaligned/$run) continue
  if (! -e tmp/Unaligned/$run/gi.list) then
    set ok=1
    foreach lane (`cat Fastc/$run/LaneList`)
      if (! -e tmp/Unaligned/$lane.gi.list) set ok=0
    end
    if ($ok == 1) then
      cat tmp/Unaligned/$run/*.gi.list | gawk '{nn[$1]+=$2;}END{for (k in nn)printf("%s\t%d\n",k,nn[k]);}' | $tab_sort -u -k 2nr >  tmp/Unaligned/$run/gi.list
    endif
  endif
  cat tmp/Unaligned/$run/gi.list >> tmp/Unaligned/_p3
end
cat tmp/Unaligned/_p3  | gawk '{nn[$1]+=$2;}END{for (k in nn)printf("%s\t%d\n",k,nn[k]);}' | $tab_sort -u -k 2nr > tmp/Unaligned/gi.list
\rm  tmp/Unaligned/_p3


echo " idfetch/seqfetch the corresponding sequences"
echo "ATTENTION as of june 2018 NCBI replaced idfetch by seqfetch, this may not work "

head -4000 tmp/Unaligned/gi.list | cut -f 1 > tmp/Unaligned/gi.list.2
#idfetch -d n -t 3 -c 1 -G tmp/Unaligned/gi.list.2 > tmp/Unaligned/gi.gb
seqfetch -d n -t 3 -c 1 -G tmp/Unaligned/gi.list.2 > tmp/Unaligned/gi.gb
  

foreach seq (`head -4000 tmp/Unaligned/gi.list`)
  echo $seq
  # wget "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=$seq&rettype=gb&retmode=text" -O tyty3
  # cat tyty3 >> tmp/Unaligned/gi.gb
end

# convert NCBI Accession to gi
if (-e patric.list && ! -e patric.gi) then 
  foreach seq (`cat patric.list`)
    echo "toto[accn]" > -q
    cat patric.list | gawk '{printf("OR%s[accn]",$1);}' >> _q
    wget "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=nucleotide&term=$seq" -O tyty3
    cat tyty3 | gawk '/<Id>/{gsub("<Id>","",$1);gsub("</Id>","",$1);print $1;}' >> patric.gi
  end
  cat  patric.gi | $tab_sort -u >  patric.gis
  mv  patric.gis  patric.gi
endif

if (! -d PARASITES) mkdir PARASITES
if (! -e PARASITES/patric.gb) then 
 pushd PARASITES
  echo "download patric sequences "
  foreach seq (`cat patric.gi`)
    echo $seq
    wget "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=$seq&rettype=gb&retmode=text" -O tyty3
    cat tyty3 >> patric.gb
    wget "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=$seq&rettype=fasta&retmode=text" -O tyty3
    cat tyty3 >> patric.fasta
  end
  setenv want_import NNM
  perl ../scripts/genbank_import.pl < patric.gb > patric.ace    
  cat patric.fasta | gawk '/^>/{printf("%s\t%s %s\n",$1,$2,$3);}' > patric.gi2title

 popd
endif

setenv want_import NM
perl scripts/genbank_import.pl < tmp/Unaligned/gi.gb > tmp/Unaligned/gi.ace
setenv want_import NNM
setenv accept_join 1
perl scripts/genbank_import.pl < tmp/Unaligned/gi.gb > tmp/Unaligned/gi.nnm.ace

pushd tmp/Unaligned

if (! -d database) then
  mkdir database
  mkdir wspec
        cd wspec
        foreach ff (`ls ../../../metaData/wspec.aceview_web_site/*.wrm`)
          ln -s $ff
        end
        cd ..
        \rm wspec/passwd.wrm
        cp ../metaData/wspec.aceview_web_site/passwd.wrm wspec
        set mynam=`whoami`
        set n=`cat wspec/passwd.wrm | gawk '{if($1==mynam)n++}END{printf("%d", 0+n)}' mynam=$mynam`
        if ($n == 0) whoami >> wspec/passwd.wrm
endif
  
../../bin/tacembly . <<EOF > /dev/null
y
  pparse  gi.ace
  pparse  gi.nnm.ace
  query find sequence DNA
  dna $species.parasites.fasta
  query find sequence Database 
  bql -a -o seq2title2gid.txt select s,t,gid from s in @, t in s->title, gid in s->database[3]
  save
  quit
EOF


# grab the title lines
set toto1=$MAGIC.top_2000_external_targets.txt
echo -n "# Missing_genome_and_Metabiome/$MAGIC.top_2000_external_targets in project $MAGIC : " > $toto1
date >> $toto1
echo "# First 2000 sequence with most frequent perfect match to sequence tags not matching the human genome or human transcriptome" >> $toto1
echo "# GI\tHits\tId\tTitle" >> $toto1

cat seq2title2gid.txt  ../../ZZZZZ gi.list | gawk -F '\t' '/^ZZZZZ/{zz=1;next}{ if(zz==0){gsub(/\"/,"",$0);split($3,aa,":");gi=aa[2];gi2t[gi]=$2;gi2s[gi]=$1;next;}}{printf("%s\t%d\t%s\t%s\n",$1,$2,gi2s[$1],gi2t[$1]);}' > toto

cat toto | $tab_sort -k 2nr | $tab_sort -u | grep -v Macaca | grep -v troglodyt | grep -v human | grep -v sapiens| grep -v Sapiens | grep -v Gorilla | grep -v Chimpanzee | grep -v Human | grep -v Pongo | grep -v leucogenys | grep -v Macaque | grep -v MACACA | grep -v Papio | grep -v Rhesus | grep -v  Chlorocebus | grep -v Callithrix    | grep -v Microcebus  | $tab_sort -u | $tab_sort -k 2nr >> $toto1
\rm toto
if (! -d  ../../RESULTS/Missing_genome_and_Metabiome) mkdir ../../RESULTS/Missing_genome_and_Metabiome
mv $toto1   ../../RESULTS/Missing_genome_and_Metabiome

gzip  seq2title2gid.txt
cd ../..

goto phaseLoop

phasep4: 

if (! -d PARASITES) mkdir PARASITES
cat PARASITES/patric.fasta tmp/Unaligned/$species.parasites.fasta >  PARASITES/$MAGIC.parasites.fasta

set target=bacteria
mkdir tmp/PHITS_$target

foreach run (`cat MetaDB/$MAGIC/RunList`)

  if (-e tmp/PHITS_$target/$run/$run.p4) continue
  if (! -d  tmp/PHITS_$target/$run) $mkDir  PHITS_$target $run

  if (-e tmp/PHITS_$target/$run/$target.count) \rm  tmp/PHITS_$target/$run/$target.count 
  if (-e tmp/PHITS_$target/p5.stats.ace) \rm tmp/PHITS_$target/p5.stats.ace
  foreach lane (`cat fastc/$run/LaneList`)
    scripts/submit  tmp/PHITS_$target/$run/p4  "scripts/p4.parasite_align.tcsh $run $lane $target"
  end
end

goto phaseLoop

## Add the bacteria in the h_ali stats in MetaDB

phasep5: 

set target=bacteria
set target2=parasites
source scripts/target2target_class.txt

if (! -e  tmp/PHITS_$target/p5.stats.ace) then
  foreach run (`cat MetaDB/$MAGIC/RunList`)
    if (! -d  tmp/PHITS_$target/$run || -e  tmp/PHITS_$target/$run/$target.count) continue
    echo $run
    gunzip -c  tmp/PHITS_$target/$run/*.hits.gz | bin/bestali -countBest -o  tmp/PHITS_$target/$run/$target.count
    cat  tmp/PHITS_$target/$run/$target.count | gawk -F '\t' '/^HITS/{if($2==tcl){printf ("Ali %s\nnh_Ali  %s %d seq %d tags  %d kb_ali  %.2f bp_av_ali %d kb_clip %.2f bp_av_clip\n",run, $2, $4,$8,$9/1000,($9)/$8,$10/1000,($10)/$8);printf ("h_Ali  %s %d seq %d tags  %d kb_ali  %.2f bp_av_ali %d kb_clip %.2f bp_av_clip\n\n",$2, $4,$8,$9/1000,($9)/$8,$10/1000,($10)/$8);}}' run=$run tcl=$target_class >>  tmp/PHITS_$target/p5.stats.ace
  end
  echo "pparse tmp/PHITS_$target/p5.stats.ace" | bin/tacembly MetaDB -no_prompt
  echo "Updating the groups stats in MetaDB"
  bin/bestali -groupLetterProfile -db MetaDB -project $MAGIC

endif

# report
if (! -d  RESULTS/Parasites) mkdir RESULTS/Parasites

set target=bacteria
  foreach run (`cat MetaDB/$MAGIC/RunList`)   
    cat  tmp/Unaligned/seq2title2gid.txt ZZZZZ tmp/PHITS_$target/$run/$run.p4  | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{gsub(/\"/,"",$0);}{if(zz==0){p=$1;title[p]=$2;next;}}{p=$2;nn[p]+=$1;}END{for (k in nn)printf("%d\t%s\t%s\t%s\n",nn[k],run,k,title[k]);}' run=$run >> toto.para
  end

cat toto.para | grep -v Macaca | grep -v troglodyt | grep -v human | grep -v sapiens| grep -v Sapiens | grep -v Gorilla | grep -v Chimpanzee | grep -v Human | grep -v Pongo | grep -v leucogenys | grep -v Macaque | grep -v MACACA | grep -v Papio | grep -v Rhesus | grep -v  Chlorocebus | grep -v Callithrix | $tab_sort -k 1nr  > toto.para_non_primates_per_run


set toto=RESULTS/Parasites/$MAGIC.non_primates_counts_per_run.txt
echo -n '# ' > $toto
date >> $toto
echo "# Number of tags supporting each of the alien sequences and not aligning on human"  >> $toto
echo "Read count\tRun\tAccession\tTitle" >> $toto
cat toto.para_non_primates_per_run | $tab_sort -k 1nr  >> $toto

set toto=RESULTS/Parasites/$MAGIC.non_primates_counts_per_group.txt
echo -n '# ' > $toto
date >> $toto
echo "# Number of tags supporting each of the alien sequences and not aligning on human"  >> $toto
echo "Read count\tRun\tAccession\tTitle" >> $toto
cat MetaDB/$MAGIC/_q2 ZZZZZ toto.para_non_primates_per_run | gawk -F '\t' '/^ZZZZZ/{zz++;next;}/Is_run/{r=$1;g=$4;if(zz<1 && r != g)r2g[r]=r2g[r] "|" g;gg[g]=1;next;}{if(zz<1)next;r=$2;p=$3;title[p]=$4;n=split(r2g[r],aa,"|");for(i=1;i<=n;i++)ng[p,aa[i]]+=$1;nn[p]++;}END{for(g in gg)for(p in nn)if(ng[p,g]>0)printf("%s\t%d\t%s\t%s\n",p,ng[p,g],g,title[p]);}' | $tab_sort -k 1,1 -k 2,2nr >> $toto

goto phaseLoop

# special banana
set toto=RESULTS/Parasites/$MAGIC.non_primates_counts_per_group.txt
echo -n "# " > $toto
date >> $toto
echo "Runs\tRuns up to Rhs4090\tRuns above Rhs4091\tRead count\tAccession\tTitle" >> $toto
cat toto.para_non_primates_per_run | gawk -F '\t' '{z=$3 "\t" $4;if($2<"Rhs4091")nA[z]++;else nB[z]++;n[z]+= $1;nr[z]++;}END{for (k in n)printf("%d\t%d\t%d\t%s\t%s\n",nr[k],nA[k],nB[k],n[k],k);}' | $tab_sort -k 1,1nr -k 4,4nr | grep -v 'musculus' | grep -v 'Rattus'  | grep -v 'Zebrafish' | grep -v Oryza | grep -v laevis | grep -v nigromaculata | grep -v Anguilla  >> $toto

echo $toto

# parasites
goto phaseLoop

###################################################################################
###################################################################################
###################################################################################
###################################################################################
## Gene Expression index
## g1: initialize the GeneIndex database

phaseg1:

if ($Strategy == RNA_seq && ! -e GeneIndexDB/ii1.done) then
  echo "phase g1: parse the aceview and refseq genes basic annotations and the MAQC results"
  scripts/geneindex.tcsh g1a   # create the GeneIndexDB database
  scripts/geneindex.tcsh g1b   # import known genes metadata
  scripts/geneindex.tcsh g1c   # Import ERCC and MAQC metadada
  scripts/geneindex.tcsh ii1   # Import the introns annotated in RefSeq and aceview
endif

goto phaseLoop

###################################################################################
## Gene Expression index
## g2/3a: Exportation des comptages $MAGIC par gene par lane

phaseg2a:
  echo >  MetaDB/$MAGIC/missing_strand.list
  bin/tacembly MetaDB <<EOF
    query find project IS  $MAGIC ; > run IS_run ; ! (forward || reverse || nonstranded)
    list -a -f MetaDB/$MAGIC/missing_strand.list
    quit
EOF
  set k=`cat  MetaDB/$MAGIC/missing_strand.list | gawk '/^Run/{k++}END{print 0+k}'`
  if (0 && $k > 0) then
    echo "The following $k runs should be assign a strand before we can compute the gene indexes"
    echo "query find project IS  $MAGIC ; > run ; Is_run && ! (forward || reverse || nonstranded)"
    echo "cat  MetaDB/$MAGIC/missing_strand.list"
    exit 1
  endif
  echo "phase g2a: Centralization des comptages en genes unique $MAGIC par lane, all runs have an assigned strand "
  scripts/geneindex.tcsh g2a
goto phaseLoop

phasem2a:
phasem2aH:
  echo >  MetaDB/$MAGIC/missing_strand.list
   bin/tacembly MetaDB <<EOF
    query find project IS  $MAGIC ; > run IS_run ; ! (forward || reverse || nonstranded)
    list -a -f MetaDB/$MAGIC/missing_strand.list
    quit
EOF
    
  set k=`cat  MetaDB/$MAGIC/missing_strand.list | gawk '/^Run/{k++}END{print 0+k}'`
  if (0 && $k > 0) then
    echo "The following $k runs should be assign a strand before we can compute the gene indexes"
    echo "query find project IS  $MAGIC ; > run IS_run ; ! (forward || reverse || nonstranded)"
    echo "cat  MetaDB/$MAGIC/missing_strand.list"
    exit 1
  endif
  set ok=1
  foreach lane (`cat MetaDB/$MAGIC/LaneList`)
   if ((-e  tmp/COUNT/$lane.hits.gz || -e  tmp/COUNT/$lane.hits.gz.mrnaOrder.gz) && ! -e tmp/COUNT/$lane.mrnaOrder.done) then
      scripts/submit  tmp/COUNT/$lane.mrnaOrder "scripts/count.global.tcsh $lane"
      set ok=0
    endif
  end
  if ($ok == 0) then
    echo "waiting on mrnaReordering"
    scripts/qusage 1
  endif

  if ($phase == m2a) then
    echo "phase m2a: Centralization des comptages en mRNAs unique $MAGIC par lane "
    scripts/geneindex.tcsh m2a
  else
    echo "phase m2aH: Hierarchic Centralization des comptages en mRNAs unique $MAGIC par lane "
    scripts/geneindex.tcsh m2aH
  endif
goto phaseLoop

phaseg3a:
  echo "phase g3a: Centralization des comptages quasi-unique $MAGIC par lane "
  scripts/geneindex.tcsh g3a
goto phaseLoop

phasem3a:
  echo "phase m3a: Centralization des comptages mRNA quasi-unique $MAGIC par lane "
  scripts/geneindex.tcsh m3a
goto phaseLoop

phasem3aH:
  echo "phase m3aH: Hierarchic centralization des comptages mRNA quasi-unique $MAGIC par lane "
  scripts/geneindex.tcsh m3aH
goto phaseLoop

###################################################################################
## Intron expression index
## ii2a/b: Intron support in transcriptome alignments per lane"

phaseii2a:
  echo "phase ii2a: Known_intron counts per lane"
  if ($Strategy == RNA_seq) scripts/geneindex.tcsh ii2a
goto phaseLoop

phaseii3a:
  echo "phase ii3a: Known_intron counts per lane in (non) unique alignments"
  if ($Strategy == RNA_seq) scripts/geneindex.tcsh ii3a
goto phaseLoop

phaseii2b:
  echo "phase ii2b: Known_intron counts per run"
  scripts/geneindex.tcsh ii2b
goto phaseLoop

phaseii3b:
  echo "phase ii3b: Known_intron counts per run in non unique alignments"
  if ($Strategy == RNA_seq) scripts/geneindex.tcsh ii3b
goto phaseLoop

phaseii2c:
  echo "phase ii2c: Known_intron counts per run with sublibraries"
  if ($Strategy == RNA_seq) scripts/geneindex.tcsh ii2c
goto phaseLoop

phaseii2d:
  echo "phase ii2d: Histogram of the cumulated support of annotated exon junctions"
  if ($Strategy == RNA_seq) scripts/geneindex.tcsh ii2c
goto phaseLoop


###################################################################################
## g2/3b: Gene index collect the gene expression data for each run
phaseg2b: 
  echo "phase g2b: Gene centralization des comptages unique $MAGIC par run "

  # parse the aceview and refseq genes basic annotations and the MAQC results
  scripts/geneindex.tcsh g2b

goto phaseLoop

phasem2b: 
  echo "phase m2b: mRNA centralization des comptages unique $MAGIC par run "

  # parse the aceview and refseq genes basic annotations and the MAQC results
  scripts/geneindex.tcsh m2b

goto phaseLoop

phasem2bH: 
  echo "phase m2bH: Hierarchique mRNA centralization des comptages unique $MAGIC par run "

  # parse the aceview and refseq genes basic annotations and the MAQC results
  scripts/geneindex.tcsh m2bH

goto phaseLoop

phaseg3b: 
  echo "phase g3b: Centralization des comptages quasi-unique $MAGIC par run "

  # parse the aceview and refseq genes basic annotations and the MAQC results
  scripts/geneindex.tcsh g3b

goto phaseLoop

phasem3b: 
  echo "phase m3b: Hierarchique Centralization des comptages quasi-unique $MAGIC par run "

  # parse the aceview and refseq genes basic annotations and the MAQC results
  scripts/geneindex.tcsh m3b

phasem3bH: 
  echo "phase m3bH: Hierarchique Centralization des comptages quasi-unique $MAGIC par run "

  # parse the aceview and refseq genes basic annotations and the MAQC results
  scripts/geneindex.tcsh m3bH

goto phaseLoop

###################################################################################
## Gene Expression index
## g4: Export gene expression tables and analyse differential expression according to the Compare class

phaseg4:
  echo "phase g4: Export gene expression tables  in RESULTS/Expression and analyse differential expression according to the Compare class"
  scripts/geneindex.tcsh g4

goto phaseLoop

phaseii4:
  echo "phase ii4: Export intron expression tables  in RESULTS/Expression and analyse differential expression according to the Compare class"
  #$chromSetAll

  cat MetaDB/$MAGIC/GroupIntronList MetaDB/$MAGIC/RunsIntronList | sort -u >   tmp/INTRON_DB/$MAGIC.RunList

  foreach chrom (20 $chromSetAll)
    scripts/geneindex.tcsh ii4 $chrom
    break
  end

goto phaseLoop

###################################################################################
## Gene Expression index
## ii5: Alternative intron report

phaseii5:
  echo "phase ii5: Alternative introns"

foreach chrom ( $chromSetAll )
   scripts/submit tmp/INTRONS_DB/$chrom/altIntrons "bin/altintrons -db tmp/INTRON_DB/$chrom -o tmp/INTRON_DB/$chrom/AlternativeIntrons.$chrom" 
end
qusage 1

set toto=RESULTS/Introns_exons_polyA/AlternativeIntrons.support.tsf 
echo -n "### $toto :" > $toto
date >> $toto
echo "## Number of introns suppported by at least  1, 2, 4, 8.... reads (log scale) in selected groups" >> $toto
cat tmp/INTRON_DB/*/AlternativeIntrons.*.support.tsf | tsf -g ALL --sumAll | gawk '/^#/{next;}{print}' >> $toto

cat tmp/INTRON_DB/*/AlternativeIntrons.*.altPairs.txt | gawk '/^#/{n++;if(n>2)next;}{print}' > RESULTS/Introns_exons_polyA/AlternativeBranchingRatios.txt
cat tmp/INTRON_DB/*/AlternativeIntrons.*.altIntrons.txt | gawk '/^#/{n++;if(n>2)next;}{print}' > RESULTS/Introns_exons_polyA/DifferentiallyExpressedIntrons.txt


goto phaseLoop

phaseii5A:


set GM=GENESP
\rm toto1
foreach capt (AGLR1 AGLR2 BSPR1 ILMR1 ILMR2 ILMR3  ROCR1 ROCR2 RNA_PolyA RNA_Total Nanopore.titr_AGLR2 Nanopore.titr_ROCR3 PacBio2.titr.ccs3_AGLR2 PacBio2.titr.ccs3_ROCR3)
  set c2=`echo $capt | gawk '{n=split($1,aa,"_");print substr(aa[n],1,1) substr(aa[n],5,1);}'` 
  echo $capt $c2
  set ff=RESULTS/Expression/unique/av/SEQC2.AceView.$GM.A2R2.u."$capt"_ACB_Profile.score.genes.profiles.txt
  cat $ff | gawk -F '\t' '/^#/{next;}{cap=$5;p=$29;m=$30; if(c2 != "PA" && c2 != "Tl" && index(cap,c2)<1){p=-10;m=-10;}printf("%s\t%s\t%s\t%s\t%s\n",$2,capt,cap,p,m);}' c2=$c2 capt=$capt  | sed -e 's/NA://g' -e 's/NE://g' >> toto1
end

cat toto1 | gawk '{g=$1;gg[g]=$1;capt[g]=$3;c=$2;cc[c]=1;odd[g,c]=$4;even[g,c]=$5;if ($4>0)ODD[g]+=$4;if ($5>0)EVEN[g]+=$5;}END{printf("# Gene\tCaptured by\tAll Odd B>A\tAll Even A>B");for(c in cc)printf("\t%s",c);for(c in cc)printf("\t%s",c);for (g in gg) {printf("\n%s\t%s\t%.2f\t%.2f",g,capt[g],ODD[g],EVEN[g]);for(c in cc)printf("\t%.2f",even[g,c]);for(c in cc)printf("\t%.2f",odd[g,c]);}printf ("\n");}' > toto2


set toto3=RESULTS/Expression/unique/av/SEQC2.A2R2.ACB.$GM.DegScore.txt
echo -n "### $toto3 : " > $toto3
date >> $toto3
cat toto2 | gawk -F '\t' '/^#/{print}' >> $toto3
cat toto2 | gawk -F '\t' '/^#/{next;}{if($3>0 && $4 == 0)print}'  | sort -k 3nr  >> $toto3
cat toto2 | gawk -F '\t' '/^#/{next;}{if($4>0 && $3 == 0)print}'  | sort -k 4nr  >> $toto3
cat toto2 | gawk -F '\t' '/^#/{next;}{if($4>0 && $3 > 0)print}'   | sort -k 3nr  >> $toto3
cat toto2 | gawk -F '\t' '/^#/{next;}{if($4==0 && $3 == 0)print}' | sort -k 1,1  >> $toto3

set toto3a=$toto3


\rm toto1
foreach capt (AGLR1 AGLR2 BSPR1 ILMR1 ILMR2 ILMR3 ROCR1 ROCR2 )
  set c2=`echo $capt | gawk '{print substr($1,1,1) substr($1,5,1);}'` 
  set ff=RESULTS/Expression/unique/av/SEQC2.AceView.$GM.A2R2.u."$capt"_AECDB_Profile.score.genes.profiles.txt 
  cat $ff | gawk -F '\t' '/^#/{next;}{cap=$5;A=$14;E=$15;C=$16;D=$17;B=$18;if(index(cap,c2)<1){p=-10;m=-10;}printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",$2,capt,cap,A,E,C,D,B);}' c2=$c2 capt=$capt  | sed -e 's/NA://g' -e 's/NE://g' >> toto1
end

cat toto1 | gawk '{g=$1;gg[g]=$1;capt[g]=$3;c=$2;cc[c]=1;A[g,c]=$4;E[g,c]=$5;C[g,c]=$6;D[g,c]=$7;B[g,c]=$8;if ($4>0){AA[g]+=$4;nAA[g]++;}if ($5>0){EE[g]+=$5;nEE[g]++;}if ($6>0){CC[g]+=$6;nCC[g]++;}if ($7>0){DD[g]+=$7;nDD[g]++;}if ($8>0){BB[g]+=$8;nBB[g]++;}}END{printf("# Gene\tCaptured by\tAll A\tAll E\tAll C\tAll D\tAll B");for(c in cc)printf("\tA %s",c);for(c in cc)printf("\tE %s",c);for(c in cc)printf("\tC %s",c);for(c in cc)printf("\tD %s",c);for(c in cc)printf("\tB %s",c);for (g in gg) {printf("\n%s\t%s\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f",g,capt[g],AA[g]/(nAA[g]+.000001),EE[g]/(nEE[g]+.000001),CC[g]/(nCC[g]+.000001),DD[g]/(nDD[g]+.000001),BB[g]/(nBB[g]+.000001));for(c in cc)printf("\t%.2f",A[g,c]);for(c in cc)printf("\t%.2f",E[g,c]);for(c in cc)printf("\t%.2f",C[g,c]);for(c in cc)printf("\t%.2f",D[g,c]);for(c in cc)printf("\t%.2f",B[g,c]);}printf ("\n");}' > toto2

cat $toto3a ZZZZZ toto2 | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){g=$1;A[g]=$3;B[g]=$4;next;}g=$1;printf("%s\t%s\t%s\t%s",g,$2,A[g],B[g]);for(i=3;i<=NF;i++)printf("\t%s",$i);printf("\n") ;}' > toto22
set toto3=RESULTS/Expression/unique/av/SEQC2.A2R2.AECDB.$GM.Expression.txt
echo -n "### $toto3 : " > $toto3
date >> $toto3
cat toto22 | gawk -F '\t' '/^#/{print}' >> $toto3
cat toto22 | gawk -F '\t' '/^#/{next;}{if($3>$7)print}'  | sort -k 3nr  >> $toto3
cat toto22 | gawk -F '\t' '/^#/{next;}{if($3<$7)print}'  | sort -k 7nr  >> $toto3
cat toto22 | gawk -F '\t' '/^#/{next;}{if($3==$7 && $3>0)print}'   | sort -k 3nr  >> $toto3
cat toto22 | gawk -F '\t' '/^#/{next;}{if($3==$7 && $3 == 0)print}' | sort -k 1,1  >> $toto3

\rm toto1
foreach capt (AGLR1 AGLR2 BSPR1 ILMR1 ILMR2 ILMR3 ROCR1 ROCR2 )
  set c2=`echo $capt | gawk '{print substr($1,1,1) substr($1,5,1);}'` 
  set ff=RESULTS/Expression/unique/av/SEQC2.AceView.$GM.A2R2.u."$capt"_AECDB_Profile.score.genes.profiles.txt 
  cat $ff | gawk -F '\t' '/^#/{next;}{cap=$5;p=$45;m=$46; if(index(cap,c2)<1){p=-10;m=-10;}printf("%s\t%s\t%s\t%s\t%s\n",$2,c2,cap,p,m);}' c2=$c2  | sed -e 's/NA://g' -e 's/NE://g' >> toto1
end

cat toto1 | gawk '{g=$1;gg[g]=$1;capt[g]=$3;c=$2;cc[c]=1;odd[g,c]=$4;even[g,c]=$5;if ($4>0)ODD[g]+=$4;if ($5>0)EVEN[g]+=$5;}END{printf("# Gene\tCaptured by\tAll Odd B>A\tAll Even A>B");for(c in cc)printf("\t%s",c);for(c in cc)printf("\t%s",c);for (g in gg) {printf("\n%s\t%s\t%.2f\t%.2f",g,capt[g],ODD[g],EVEN[g]);for(c in cc)printf("\t%.2f",even[g,c]);for(c in cc)printf("\t%.2f",odd[g,c]);}printf ("\n");}' > toto2



set toto3=RESULTS/Expression/unique/av/SEQC2.A2R2.AECDB.$GM.DegScore.txt
echo -n "### $toto3 : " > $toto3
date >> $toto3
cat toto2 | gawk -F '\t' '/^#/{print}' >> $toto3
cat toto2 | gawk -F '\t' '/^#/{next;}{if($3>0 && $4 == 0)print}'  | sort -k 3nr  >> $toto3
cat toto2 | gawk -F '\t' '/^#/{next;}{if($4>0 && $3 == 0)print}'  | sort -k 4nr  >> $toto3
cat toto2 | gawk -F '\t' '/^#/{next;}{if($4>0 && $3 > 0)print}'   | sort -k 3nr  >> $toto3
cat toto2 | gawk -F '\t' '/^#/{next;}{if($4==0 && $3 == 0)print}' | sort -k 1,1  >> $toto3

set toto3a=$toto3
\rm toto1
foreach capt (AGLR1 AGLR2 BSPR1 ILMR1 ILMR2 ILMR3  ROCR1 ROCR2 RNA_PolyA RNA_Total Nanopore.titr_AGLR2 Nanopore.titr_ROCR3 PacBio2.titr.ccs3_AGLR2 PacBio2.titr.ccs3_ROCR3)
  set c2=`echo $capt | gawk '{n=split($1,aa,"_");print substr(aa[n],1,1) substr(aa[n],5,1);}'` 
  echo $capt $c2
  set ff=RESULTS/Expression/unique/av/SEQC2.AceView.$GM.A2R2.u."$capt"_ACB_Profile.score.genes.profiles.txt
  cat $ff | gawk -F '\t' '/^#/{next;}{cap=$5;A=$14;C=$15;B=$16; if(c2 != "PA" && c2 != "Tl" && index(cap,c2)<1){A=-10;B=-10;C=-10;}printf("%s\t%s\t%s\t%s\t%s\t%s\n",$2,capt,cap,A,C,B);}' c2=$c2 capt=$capt | sed -e 's/NA://g' -e 's/NE://g'  >> toto1
end

cat toto1 | gawk '{g=$1;gg[g]=$1;capt[g]=$3;c=$2;cc[c]=1;A[g,c]=$4;C[g,c]=$5;B[g,c]=$6;if ($4>0){AA[g]+=$4;nAA[g]++;}if ($5>0){CC[g]+=$5;nCC[g]++;}if ($6>0){BB[g]+=$6;nBB[g]++;}}END{printf("# Gene\tCaptured by\tAll A\tAll C\tAll B");for(c in cc)printf("\tA %s",c);for(c in cc)printf("\tC %s",c);for(c in cc)printf("\tB %s",c);for (g in gg) {printf("\n%s\t%s\t%.2f\t%.2f\t%.2f",g,capt[g],AA[g]/(nAA[g]+.000001),CC[g]/(nCC[g]+.000001),BB[g]/(nBB[g]+.000001));for(c in cc)printf("\t%.2f",A[g,c]);for(c in cc)printf("\t%.2f",C[g,c]);for(c in cc)printf("\t%.2f",B[g,c]);}printf ("\n");}' > toto2

cat $toto3a ZZZZZ toto2 | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){g=$1;A[g]=$3;B[g]=$4;next;}g=$1;printf("%s\t%s\t%s\t%s",g,$2,A[g],B[g]);for(i=3;i<=NF;i++)printf("\t%s",$i);printf("\n") ;}' > toto22
set toto3=RESULTS/Expression/unique/av/SEQC2.A2R2.ACB.$GM.Expression.txt
echo -n "### $toto3 : " > $toto3
date >> $toto3
cat toto22 | gawk -F '\t' '/^#/{print}' >> $toto3
cat toto22 | gawk -F '\t' '/^#/{next;}{if($3>$5)print}'  | sort -k 3nr  >> $toto3
cat toto22 | gawk -F '\t' '/^#/{next;}{if($3<$5)print}'  | sort -k 5nr  >> $toto3
cat toto22 | gawk -F '\t' '/^#/{next;}{if($3==$5 && $3>0)print}'   | sort -k 3nr  >> $toto3
cat toto22 | gawk -F '\t' '/^#/{next;}{if($3==$5 && $3 == 0)print}' | sort -k 1,1  >> $toto3

goto phaseLoop

###################################################################################

phaseg4sp:
phaseg4spx:
  echo "phase g4: Export gene_sponge expression tables  in RESULTS/Expression and analyse differential expression according to the Compare class"
  scripts/geneindex.tcsh $phase

goto phaseLoop

phasegsnp4:
   echo "phase gsnp4: Export genes differing by the number of protein coding SNPs they contain"
  if (-e tmp/GENEINDEX/$MAGIC.snp_per_gene.protein.ace) then 
    if (! -d  tmp/GENEINDEX/Results) mkdir  tmp/GENEINDEX/Results
    scripts/geneindex.tcsh gsnp4
  else
    echo "Phase gsnp4 is part of MAGIC SNP, it requires phase s22"
  endif

goto phaseLoop

phasem4:
  echo "phase m4: Export mRNA expression tables  in RESULTS/Expression and analyse differential expression according to the Compare class"

  scripts/geneindex.tcsh ma4

goto phaseLoop

phase8kb_histo:
  echo "phase 8kb_histo: Export histogram of 8kb coverage"

if (! -d  tmp/GENEGROUPS) mkdir  tmp/GENEGROUPS
foreach kb (8kb 5kb)
  if (! -d RESULTS/Coverage_of_"$kb"_transcripts__3prime_bias) mkdir RESULTS/Coverage_of_"$kb"_transcripts__3prime_bias

# construct the group crocodiles
  foreach gr (`cat MetaDB/$MAGIC/g2r | cut -f 1`)
    if (! -d  tmp/GENEGROUPS/$gr) mkdir tmp/GENEGROUPS/$gr
    set totogr=tmp/GENEGROUPS/$gr/$gr.coverage_of_"$kb"_transcripts.txt
    echo -n "### $totogr : " > $totogr
    date >> $totogr
    # copy the title lines
    foreach run (`cat MetaDB/$MAGIC/g2r | gawk -F '\t' '{if($1 == gr) print $2;}' gr=$gr | sort -u | head -1`)
      set totorun=tmp/GENERUNS/$run/$run.coverage_of_"$kb"_transcripts.txt
      if (-e $totorun.gz) then
        gunzip -c $totorun.gz | tail -n +2 | head -8 | gawk '/^#/{print}' >> $totogr
      endif
    end
    # cumulate the content
    echo "#" > $totogr.1
    foreach run (`cat MetaDB/$MAGIC/g2r | gawk -F '\t' '{if($1 == gr) print $2;}' gr=$gr | sort -u`)
      set totorun=tmp/GENERUNS/$run/$run.coverage_of_"$kb"_transcripts.txt
      if (-e $totorun.gz) then
        gunzip -c $totorun.gz | gawk '/^#/{next;}{print}' >> $totogr.1
      endif
    end
    cat $totogr.1 | gawk -F '\t' '{gene=$2;for(i=3;i<=NF;i++)z[gene,i]+=$i;gg[gene]=1;if(NF>nf)nf=NF}END{for(gene in gg){printf("%s\t%s",gene,gr);for(i=3;i<=nf;i++)printf("\t%d",z[gene,i]+0);printf("\n");}}' gr=$gr | sort -k 3nr >> $totogr
    \rm $totogr.1
    \cp $totogr RESULTS/Coverage_of_"$kb"_transcripts__3prime_bias/$gr.coverage_of_"$kb"_transcripts.txt
  end

  set toto=RESULTS/Coverage_of_"$kb"_transcripts__3prime_bias/$MAGIC.cumulated_3prime_coverage_of_"$kb"_genes.txt
  echo -n "## $MAGIC.cumulated_3prime_coverage_of_"$kb"_genes.txt : " > $toto
  date >> $toto
  cat tmp/GENERUNS/*/*.coverage_of_"$kb"_transcripts.txt | head -20 | gawk '/^## /{n++;if(n>=2 && n<=4)print}' >> $toto
  if (-e $toto.1) \rm $toto.1
  touch $toto.1
  set xMax=0
  bin/tacembly MetaDB <<EOF
    query find project IS  $MAGIC ; > run ; CLASS runs ; > ali NOT Accessible_length
    bql -o   MetaDB/$MAGIC/AliList_noLn.list select @
EOF
  # (`cat MetaDB/$MAGIC/AliList_noLn.list'`)
  foreach run (`cat MetaDB/$MAGIC/RunsList `)
    if (-e tmp/GENERUNS/$run/$run.coverage_of_"$kb"_transcripts.txt.gz) then
      gunzip -f tmp/GENERUNS/$run/$run.coverage_of_"$kb"_transcripts.txt.gz
    endif
    if (-e tmp/GENERUNS/$run/$run.coverage_of_"$kb"_transcripts.txt) then
      bin/rsync -avh  tmp/GENERUNS/$run/$run.coverage_of_"$kb"_transcripts.txt RESULTS/Coverage_of_"$kb"_transcripts__3prime_bias >& /dev/null
      cat tmp/GENERUNS/$run/$run.coverage_of_"$kb"_transcripts.txt | grep Kept | grep transcripts | grep -v raw | gawk -F '\t' '{r=$1;split($2,aa," ");split(aa[2],bb,"/");x+=bb[1];y+=bb[2];for(i=3;i<=NF;i++)z[i]+=$i;if(nf<NF)nf=NF;}END{printf("Kept %d/%d transcripts\t%s",x,y,r);if(nf > 803)nf=803;for(i=3;i<=nf;i++)printf("\t%d",z[i]);printf("\n");}' >> $toto.1
      set xMax=`cat  tmp/GENERUNS/$run/$run.coverage_of_"$kb"_transcripts.txt | gawk -F '\t' '{if(50*NF > n)n= 50*NF}END{print n}' n=$xMax`
   endif
  end
  echo toto | gawk '{printf("#\t# Run\tAverage coverage of the first %s",kb);for(i=0;i<=xMax-200;i+=50)printf("\t%d bp",i);printf("\n");}' xMax=$xMax kb=$kb > $toto.2
  cat $toto.2 $toto.1 |  scripts/transpose  >>  $toto
  cat $toto.1 |  gawk -F '\t' '{printf("%s\t%s",$1,$2); for(i=8;i<NF;i+=10){n=0;for(j=-4;j<5;j++){k=i+j;n+=$k/9;}$i=n;}for(i=13;i<NF-10;i+=10){$i=($(i-5)+$(i+5))/2;$3=2*$13-$23;for(i=3;i<=NF;i+=5)printf("\t%d",$i);}printf("\n");}' | scripts/transpose  >>  $toto

  #if (-e $toto.1) \rm $toto.1 $toto.2 

  if ($kb == 5kb) continue

  set toto4=tmp/GENEGROUPS/$MAGIC.seuil
  echo -n "## $toto4.txt " > $toto4.txt
  date >>  $toto4.txt
  cat <<EOF >>  $toto4.txt
## Une belle idee de Danielle
EOF
  cat $toto | gawk -F '\t' '/^##/{next}/^# Run/{for(i=2;i<=NF;i++)rr[i]=$i;next;}/^Average/{for(i=2;i<=NF;i++)cover[i]=$i;next;}/^#/{if(substr($2,1,5)=="Kept "){for(i=2;i<=NF;i++){split($i,aa," ");split(aa[2],bb,"/");nKept[i]=bb[1];nCandidates[i]=bb[2];}}next;}/^#/{next}/ bp/{x=$1;gsub(" bp","",x);x=x+0;if(x<=8000)for(i=2;i<=NF;i++){rrx[i,x]=$i;rt[i]+=$i;}next;}END{printf("#Run\tKept\tCandidates\tCover\tH 30p%\tH 25p%\tH 20p%\tH 10%\tSurface 30%\tSurface 40%\tSurface 50%\tSurface 60%\tSurface 70%\tSurface 75%\tSurface 80%\tSurface 90%\tSurface 95%\tSurface 98%\tSurface 100%\n");for(r in rr){tt=rt[r];h=rrx[r,100];t=0;h10=0;h20=0;h25=0;h30=0;a30=0;a40=0;a50=0;a60=0;a70=0;a75=0;a80=0;a90=0;a95=0;a98=0;for(x=0;x<=8000;x+=50){y=rrx[r,x];t+=y;if(h10==0 && 10*y < h){h10=x;}if(h20==0 && 5*y < h)h20=x;if(h25==0 && 4*y < h)h25=x;if(h30==0 && 3.33*y < h)h30=x;if(a30==0 && 100*t > 30*tt)a30=x;if(a40==0 && 100*t > 40*tt)a40=x;if(a50==0 && 100*t > 50*tt)a50=x;if(a60==0 && 100*t > 60*tt)a60=x;if(a70==0 && 100*t > 70*tt)a70=x;if(a75==0 && 100*t > 75*tt)a75=x;if(a80==0 && 100*t > 80*tt)a80=x;if(a90==0 && 100*t > 90*tt)a90=x;if(a95==0 && 100*t > 95*tt)a95=x;if(a98==0 && 100*t > 98*tt)a98=x;if(a100==0 && 100*t >= 100*tt)a100=x;}if (h10==0)h10=8000;if (h20==0)h20=8000;if (h25==0)h25=8000;if (h30==0)h30=8000;if (nKept[r] >= 1){printf("%s\t%d\t%d\t%d",rr[r],nKept[r],nCandidates[r],cover[r]) ; printf("\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",h30,h25,h20,h10,a30,a40,a50,a60,a70,a75,a80,a90,a95,a98,a100);}}}' | scripts/tab_sort -k 3n  >>  $toto4.txt
  # $15 =  accessible length = 80% of surface of 8kb crocodile
  # $13 =  accessible length = 70% of surface of 8kb crocodile
  cat   $toto4.txt | gawk -F '\t' '/^#/{next;}{x=$13;if(x==0)x=8000;printf("Ali %s\nAccessible_length %s %s %s %s\n\n",$1,x,$2,$3,$4);}'  > $toto4.ace
  bin/tacembly MetaDB <<EOF
      read-models
      pparse  $toto4.ace
      save
      quit
EOF
  tags  $toto4.ace

# end 5kb 8kb loop
end
goto phaseLoop


phasem4H:
  echo "phase m4H: Export hierarchic mRNA expression tables in RESULTS/Expression and analyse differential expression according to the Compare class"

  scripts/geneindex.tcsh m4H

goto phaseLoop

phasema4:
  echo "phase ma4: Analyse the micro-array data declared in OTHER_PIPELINES as another RESULTS/Expression"

  scripts/geneindex.tcsh ma4

goto phaseLoop

phaseSF4:
  echo "phase $phase : Export the sailfish Gene index counts and gene comparisons in RESULTS/Expression"
  scripts/geneindex.tcsh $phase

goto phaseLoop

##############################################
###############################################
phaseg10: 
  echo "phase g10: Prevalence"

if (! -d RESULTS/PrevalenceProfiles) mkdir RESULTS/PrevalenceProfiles
if (! -d tmp/Prevalence) mkdir tmp/Prevalence

echo -n "--- number of comparisons to be processed "
cat  MetaDB/$MAGIC/ccc.list | wc -l

foreach target ($Etargets)
  if ($target == av || $target == magic) then
    foreach GM (GENE MRNAH)
      foreach ccc (`cat  MetaDB/$MAGIC/ccc.list` anyComparison)
        if (! -e  tmp/Prevalence/$target.$GM.$ccc.done) then
          scripts/submit tmp/Prevalence/$target.$GM "scripts/prevalence.tcsh $target $GM $ccc"
        endif
      end
    end
  endif
end

goto phaseLoop

###############################################
###############################################
phaseg11: 
  echo "phase g11: Chromosome density"


echo -n "--- number of comparisons to be processed "
set n=`cat  MetaDB/$MAGIC/ccc_pair.list | wc -l`

if ($n > 0) then
  if (! -d RESULTS/ChromDensity) mkdir RESULTS/ChromDensity
  if (! -d tmp/ChromDensity) mkdir tmp/ChromDensity

  foreach target ($Etargets)
    if ($target == av || $target == magic) then
      foreach GM (GENE MRNAH)
        foreach ccc (`cat  MetaDB/$MAGIC/ccc_pair.list` anyComparison)
          if (! -e  tmp/ChromDensity/$target.$GM.$ccc.done) then
            scripts/submit tmp/ChromDensity/$target.$GM "scripts/chrom_density.tcsh $target $GM $ccc"
          endif
        end
      end
    endif
  end
endif

goto phaseLoop

###############################################

phaseg12a: 
echo "phase g12a: Prepare the histogram of all measured non-NA indexes in the different targets"

foreach GM (GENE MRNAH MA)
  foreach target ($Etargets $other_targets )
    if (-e  RESULTS/Expression/AceFiles/$MAGIC.$target.$GM.u.ace.gz && (! -e RESULTS/Expression/unique/$target/$MAGIC.index.$GM.distrib.txt || !  -e RESULTS/Expression/unique/$target/$MAGIC.cumulated_support_notNA.$GM.txt)) then
      scripts/submit tmp/GENEINDEX/$MAGIC.$GM.$target.g12a "scripts/g12.expression_histos.tcsh $target $GM"
    endif
  end
end

goto phaseLoop

###############################################

phaseg12b: 
echo "phase g12b: Export the histogram of all measured non-NA indexes in the different targets"

     scripts/g12.expression_histos.tcsh export
     echo RESULTS/Expression/unique/$MAGIC.expression_index.histo.txt
     echo RESULTS/Expression/unique/$MAGIC.cumulated_support_of_annotated_genes_and_transcripts.histo.txt
goto phaseLoop

###############################################
###############################################

phaseklst0: 
  echo "phase kslt0 : prepare  Kallisto gene index"
  
  if (! -d  tmp/Kallisto_index) mkdir  tmp/Kallisto_index
  foreach target ($Etargets)
    if (! -e tmp/Kallisto_index/$species.$target.kallisto_index) then
      kallisto index --make-unique -i tmp/Kallisto_index/$species.$target.kallisto_index TARGET/Targets/$species.$target.fasta.gz
    endif
  end

goto phaseLoop
 
###############################################

phaseklst1: 
  echo "phase kslt1 : run kallisto on transcripts"
 
  if (! -d  tmp/Kallisto) mkdir  tmp/Kallisto
  foreach target ($Etargets)
     if (! -e tmp/Kallisto_index/$species.$target.kallisto_index) then
       echo "Missing file  tmp/Kallisto_index/$species.$target.kallisto_index, please run phase klst0"
       goto phaseLoop
     endif
  end

  foreach run (`cat MetaDB/$MAGIC/RunList`)
    if (! -d tmp/Kallisto/$run) $mkDir  Kallisto $run
    if (! -e tmp/Kallisto/$run/fastc.list) then
      cat Fastc/$run/LaneList | gawk '{ split ($1, aa, "/"); printf("%s.fastc.gz ", aa[2]);}' > tmp/Kallisto/$run/fastc.list
    endif
    foreach target ($Etargets)
      if (! -d tmp/Kallisto/$run/$target) mkdir  tmp/Kallisto/$run/$target
      if (-e tmp/Kallisto/$run/$target/abundance.tsv) continue
      if (-e tmp/Kallisto/$run/$target/abundance.tsv.gz) continue
      scripts/submit tmp/Kallisto/$run/$target/klst1  "scripts/kallisto.tcsh klst1 $species $target $run"
      
      set ok=1
    end
    if ($ok == 1 && -e  tmp/Kallisto/klst2.$target.stats.ace) \rm  tmp/Kallisto/klst2.$target.stats.ace
  end

goto phaseLoop
 
###############################################

phaseklst2: 
  echo "phase kslt2 : Centralize in MetaDB the Kallisot CPU and memory usage"
  if (! -d  tmp/Kallisto) goto phaseLoop
  foreach target ($Etargets)
     if (! -e tmp/Kallisto_index/$species.$target.kallisto_index) then
       continue
     endif
     if (! -d tmp/Kallisto/$target) continue 
     if (-e  tmp/Kallisto/$target/klst2.stats.$target.ace) continue 
     echo ' ' >  tmp/Kallisto/$target/klst2.stats.$target.ace
     foreach run (`cat MetaDB/$MAGIC/RunList`)
       set ff=tmp/Kallisto/$target/LOG/$run.err
       if (-e $ff) then
         set cpu=`gawk '/CPU/{n++;t=$3;split(t,z,":");s+=3600*z[1] + 60*z[2] + z[3]; }END{if(n==0)s=-10;printf("%d",s);}' $ff`  
         set mm=`gawk '/Max vmem/{t=$4;i=index(t,"M");k=1;j=index(t,"G");if(j>0){i=j;k=1000;}if(i>0)z=0+substr(t,1,i-1);z=z*k;}END{printf("%d",z+0);}' $ff`
         echo "Ali $run" >>  tmp/Kallisto/$target/klst2.stats.$target.ace
         echo "CPU Kallisto_$target $cpu seconds" >>  tmp/Kallisto/$target/klst2.stats.$target.ace
         if ($mm > 0) echo "Max_memory Kallisto_$target $mm Mb\n" >>  tmp/Kallisto/$target/klst2.stats.$target.ace
       endif
     end
     echo "pparse tmp/Kallisto/$target/klst2.stats.$target.ace" | bin/tacembly MetaDB -noprompt
  end

goto phaseLoop
 
###############################################

phaseklst4: 
  echo "phase kslt4 :  Run gene predictions using as index log2(1000* kallisto.tpm)"
  
  if (! -d  tmp/Kallisto_index || ! -d  tmp/Kallisto_index) then
    echo "please verify kallisto is on your path and run phase klst1, klst2"
    goto phaseLoop
  endif
  foreach target ($Etargets)
    foreach run (`cat MetaDB/$MAGIC/RunList`)
      if (! -e  tmp/Kallisto/$target/$run/abundance.tsv) then
        echo "Missing file  tmp/Kallisto/$target/$run/abundance.tsv"
        # goto phaseLoop
       endif
     end
  end
  scripts/geneindex.tcsh klst4
goto phaseLoop
 
###############################################
###############################################

phaseSF1:
  echo "phase SF1 : Sailfish, using k-mers k=24"
  
if (! -d tmp/Sailfish) mkdir  tmp/Sailfish
foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -d tmp/Sailfish/$run) $mkDir  Sailfish $run
  if (! -e tmp/Sailfish/$run/done) then
    scripts/submit tmp/Sailfish/$run/sailfish.$run "scripts/sailfish.tcsh $run"
  endif
end
goto phaseLoop

###############################################

phaseSF2:
  echo "phase SF2 : Sailfish, gene counts"

foreach run (`cat MetaDB/$MAGIC/RunList`)
    if (-e tmp/Sailfish/$run/done && ! -e  tmp/Sailfish/$run/GENE.done) then
      scripts/submit tmp/Sailfish/$run/sailfish.$run "scripts/sailfish.tcsh $run GENE"
    endif
end
goto phaseLoop

###############################################
###############################################

phaseFDR1:
  echo "phase FDR1: For all Experiment with DEG tag export FDR table in RESULTS/Expression"
  
  scripts/FDR.tcsh FDR1

goto phaseLoop

phaseFDR2:
  echo "phase FDR2: Export list of DEG at optimal FDR rate as .ace file"

  scripts/FDR.tcsh FDREXPORT           

goto phaseLoop

gunzip -c RESULTS/Expression/unique/AGLuK/NB.AGLuK.MA.u.ace.gz |  gawk '/Run_/{gsub(/\"/,"",$2);r=$2;rr[r]=1;z=log(1+$4)/log(2);rrz[r,5*int((z+.24)/.5)]++;next;}END{printf("Index");for(r in rr)printf("\t%s",r);for(k=0;k<=300;k+=5){printf("\n%.1f",k/10);for(r in rr)printf("\t%d",rrz[r,k]);}printf("\n");}' | scripts/transpose | $tab_sort | scripts/transpose > RESULTS/Expression/unique/AGLuK/NB.index.histo.txt



###################################################################################
## Gene Expression index
## g5:  Gene index compute the geneindex for each group

phaseg5:
  echo "phase g5: Parse the geneindex in GeneindexDB"

  scripts/geneindex.tcsh g5

goto phaseLoop

###################################################################################
## Gene Expression index
## ii5:  Intron index compute the intronIndex for each group

phaseii5old:
  echo "phase ii5: Recalcul des index, par run et par groupe"

  if ($Strategy == RNA_seq) scripts/geneindex.tcsh ii5

goto phaseLoop

###################################################################################
## Gene Expression index
## ii6:  Exportation a partir de GeneIndexDB des tables d'index par genes annotes"

phaseii6:
  echo "phase ii6: Intron index compute the intronIndex for each group"

  if ($Strategy == RNA_seq) scripts/geneindex.tcsh ii6

goto phaseLoop

###################################################################################
## Gene Expression index
## g6:  Exportation a partir de GeneIndexDB des tables d'index par genes annotes"

phaseg6:
  echo "phase g6: Exportation a partir de GeneIndexDB des tables d'index par genes annotes"

  scripts/geneindex.tcsh g6

  mv RESULTS/Expression/*ERCC*txt      RESULTS/Expression/ERCC
  mv RESULTS/Expression/*1000*.txt     RESULTS/Expression/1000genes_with_best_support
  mv RESULTS/Expression/*.nu.txt  RESULTS/Expression/quasi_unique
  mv RESULTS/Expression/*Variance*txt  RESULTS/Expression/Variance
  mv RESULTS/Expression/*.u.txt   RESULTS/Expression/unique

goto phaseLoop

###################################################################################
## Gene Expression index
## g7:  Most differentially expressed genes

phaseg7:
  echo "phase g7: Most expressed genes"
  scripts/geneindex.tcsh g7
goto phaseLoop

###################################################################################
## Gene Expression comparison
## g8:  Compare gene runs

phaseg8:
  echo "phase g8: Most differentially expressed genes"
  scripts/geneindex.tcsh g8
goto phaseLoop

###################################################################################
###################################################################################

##  Report the virus and batery counts

phaseVir1:
  if (! -d  tmp/VIRUS) mkdir  tmp/VIRUS
  if (! -d  tmp/BACTERIA) mkdir  tmp/BACTERIA
    echo "phase vir1: align on virus and bacteria"
    foreach run (`cat MetaDB/$MAGIC/RunList`)
      if (! -d  tmp/VIRUS/$run) $mkDir  VIRUS $run
      if (! -d  tmp/BACTERIA/$run) $mkDir  BACTERIA $run
      if (! -e  tmp/VIRUS/$run/vir1.virus.count || ! -e  tmp/BACTERIA/$run/vir1.bacteria.count) then
        scripts/submit tmp/VIRUS/$run/vir1 "scripts/virus.tcsh vir1 $run " 32G
      endif
    end
  endif
goto phaseLoop

phaseVir2: 
  if (-d  tmp/VIRUS) then
    scripts/virus.tcsh vir2
  endif
goto phaseLoop

###################################################################################
###################################################################################
###################################################################################
## Construct a map of the genome with sufficient coverage

phases1:
  set justMito=0
  goto phases1any
phases1m:
  set justMito=1 
phases1any:

 echo "phase s1: SNP analysis data collection strategy=$Strategy"
 if (! -d tmp/SNP) mkdir tmp/SNP

 set geneSNPTarget=xx
 foreach target ($Etargets $RNAtargets)
   if ($Strategy == RNA_seq && $geneSNPTarget == xx) then
     foreach target2 ($RNAtargets)
       if ($geneSNPTarget == xx && $target2 == $target)  set geneSNPTarget=$target
     end
   endif
 end

phases1xxx:
# fan out the bin/bestalignment per zone

if (! -d  tmp/SNP_ZONE) then
  echo "Please run phase tsnp0 before phase s1 or snp1"
  exit 1
endif

echo " export the quality coefficient in project $MAGIC"
bin/tacembly MetaDB <<EOF > /dev/null
  query find run is_run AND NOT sublibraries AND project == $MAGIC ; > ali
  bql -a -o tmp/SNP_BRS/Quality_profile.txt select r,f,x,q from r in @, f in r->Quality_profile, x in f[1], q in x[1]
EOF

# snp_accumulate creates the BRS counts and auto-detects at the default values, no user list
foreach run (`cat MetaDB/$MAGIC/RunsList`) 
  if (($Strategy == Exome || $Strategy == Genome) && ! -d  tmp/SNP_ZONERUN/$run) $mkDir  SNP_ZONERUN $run 
end

foreach run (`cat MetaDB/$MAGIC/RunList`) 
  if (! -d  tmp/SNP_BRS/$run) $mkDir  SNP_BRS $run 
  if (($Strategy == Exome || $Strategy == Genome) && ! -d  tmp/SNP_ZONERUN/$run) $mkDir  SNP_ZONERUN $run 

  if (-e  tmp/SNP_BRS/Quality_profile.txt && ! -e  tmp/SNP_BRS/$run/Quality_profile.txt) then 
    cat  tmp/SNP_BRS/Quality_profile.txt | gawk -F '\t' '/^#/{next}{gsub(/\"/,"",$0);if($1!=run)next;x=$3;q=$4;z=0+substr($2,2);printf("%d\t%d\t%g\n",z,x,q);}' run=$run > tmp/SNP_BRS/$run/Quality_profile.txt 
  endif

  if (! -e tmp/SNP_BRS/$run/s1.done && ! ($justMito == 1 && -e tmp/SNP_BRS/$run/s1.justMito.done)) then
    echo  "scripts/s1.snp_accumulate.tcsh $run justMito=$justMito $geneSNPTarget minAli=$minAli"
    scripts/submit tmp/SNP_BRS/$run/s1 "scripts/s1.snp_accumulate.tcsh $run $justMito $geneSNPTarget"
  endif
end

goto phaseLoop

###################################################################################
## SNP detection using Tricoteur, create the databases

phaseSnp0:
phaseTSnp0:


 set geneSNPTarget=xx
 foreach target ($Etargets $RNAtargets)
   if ($Strategy == RNA_seq && $geneSNPTarget == xx) then
     foreach target2 ($RNAtargets)
       if ($geneSNPTarget == xx && $target2 == $target)  set geneSNPTarget=$target
     end
   endif
 end

if (! -d tmp/SNP_ZONE) then
  mkdir tmp/SNP_ZONE

  set strategyOk=0
  if (! -e  tmp/SNP_ZONE/fasta.done  &&  ($Strategy == Exome || $Strategy == Genome)) then
    # new simpler method, look at genome legth and create sections < 100M 
    set strategyOk=1
    cat tmp/METADATA/genome.ns.sponge | gawk -F '\t' '{N=30000000;if($4<$5){n=1+int($5/N);oldx2=0;for(i=1;i<=n;i++){u=substr("abcdefghijklm",i,1);x1=1+(i-1)*N;x2=i*N+1000000;if(i==n)x2=$5;if(x2 > oldx2)printf("%s\t%d\t%d\t%s_%s\n",$3,x1,x2,$3,u);oldx2=x2;}}}' > tmp/SNP_ZONE/_allG
    echo $targets | gawk '/mito/{m=1;}END{cp=" ";if(m==1)cp="mito";print cp}' >  tmp/SNP_ZONE/ZoneList
    cat  tmp/SNP_ZONE/_allG | gawk -F '\t' '{printf("zoneG.%s\n",$4);}'  | $tab_sort -u | sort -V >> tmp/SNP_ZONE/ZoneList
    cat  tmp/SNP_ZONE/_allG | gawk '{printf("ln -s ../../TARGET/CHROMS/%s.chrom_%s.fasta.gz tmp/SNP_ZONE/zoneG.%s.fasta.gz\n", species,$1, $4);}' species=$species >  tmp/SNP_ZONE/_l
    source  tmp/SNP_ZONE/_l
    \rm  tmp/SNP_ZONE/_l
    touch  tmp/SNP_ZONE/fasta.done
  endif

endif

if ($Strategy == RNA_seq) then
    set target=$geneSNPTarget
    set strategyOk=1
    if (! -e tmp/SNP_ZONE/_allr) then

      gunzip -c TARGET/Targets/$species.$target.fasta.gz | gawk '/^>/{split(substr($1,2),aa,"|");print aa[1];}' >  tmp/SNP_ZONE/_allr

      set n=`wc tmp/SNP_ZONE/_allr | gawk '{print $1}'`
      cat  tmp/SNP_ZONE/_allr | gawk 'BEGIN{NN=20;}{k = 1 + int(NN*n/nn); n++ ; if (k!=oldk) out="tmp/SNP_ZONE/zoner." k ".txt" ; oldk=k ;printf("%s\t%s\t%s\t%d\n",$1,1,1000000000,k) > out ; }'  nn=$n
      if (-e tmp/SNP_ZONE/zoner.1.fasta) \rm tmp/SNP_ZONE/zoner.*.fasta
      foreach ff (`ls tmp/SNP_ZONE/zoner.*.txt`)
        set ff1=`echo $ff | sed -e 's/\.txt//'`
        scripts/submit $ff1 "bin/dna2dna -i TARGET/Targets/$species.$target.fasta.gz -select $ff -I fasta -O fasta -gzo -o $ff1" MULTICORE
      end

    endif
    scripts/submit tmp/SNP_ZONE/wait_split_target  wait MULTICORE

    echo "mito" > tmp/SNP_ZONE/ZoneList

    if (-e tmp/SNP_ZONE/zoner.1.fasta.gz) then
      ls  tmp/SNP_ZONE/zoner.*.fasta.gz | sed -e 's/tmp\/SNP_ZONE\///' -e 's/\.fasta\.gz//' | sort -V >> tmp/SNP_ZONE/ZoneList
    endif
endif



if ($Strategy == RNA_seq && -e TARGET/GENES/av.gene.ace  && ! -e tmp/SNP_ZONE/zoneg.999.fasta.gz) then
  echo "collect the profiling gene set"
  scripts/s1.CreateGeneSet.tcsh
endif

if ($Strategy == RNA_seq && ! -e tmp/TSNP_DB/Genes/tsnp0.parse.done) then
  if (! -e tmp/TSNP_DB) mkdir tmp/TSNP_DB
  if (! -e tmp/TSNP_DB/Genes) then
    mkdir tmp/TSNP_DB/Genes
    pushd tmp/TSNP_DB/Genes
      ln -s ../../../metaData/wspec
      mkdir database
      tace . <<EOF
y
      save
      quit
EOF
    popd
  endif


  set toto=tmp/TSNP_DB/Genes/_r
    echo "read-models" > $toto

    echo "pparse tmp/METADATA/av.MRNA.info.ace" >> $toto
    echo "pparse tmp/METADATA/av.GENE.info.ace" >> $toto
    if (-e tmp/METADATA/c7.av.captured_genes.ace) echo "pparse tmp/METADATA/c7.av.captured_genes.ace" >> $toto
    if (-e TARGET/MRNAS/mrna2product.ace ) echo "pparse TARGET/MRNAS/mrna2product.ace" >> $toto
    if (-e TARGET/MRNAS/good_product.ace ) echo "pparse TARGET/MRNAS/good_product.ace" >> $toto
    zcat TARGET/Targets/hs.av.fasta.gz | sed -e 's/^>/>mRNA:/' -e 's/|/ /' | gzip > tmp/TSNP_DB/Genes/mrna.fasta.gz
    echo "pparse tmp/TSNP_DB/Genes/mrna.fasta.gz" > $toto
    echo save >> $toto
    echo quit >> $toto

  bin/tace tmp/TSNP_DB/Genes < $toto

  touch tmp/TSNP_DB/Genes/tsnp0.parse.done
endif




 
if (strategyOk == 0) then
    echo "Unknown Strategy $Strategy in phase s1"
    goto phaseLoop
endif

goto phaseLoop

# seach for corona virus inside a project using tricoteur
# zero results in SEQC2_2020 and in NB : therefore a positive result somewhere else would be significant

foreach run ( `cat MetaDB/NB.RunListSorted` )
  if (-e Fastc/$run/LaneList) bin/tricoteur -count -wLn 31 -wordFile TARGET/Targets/corona.words.37 -run $run  -max_threads 8 | gawk '{if($3+$4>0)print;}' > tmp/COUNT/$run/corona.val.tsf
end


###################################################################################
## SNP detection using Tricoteur
project test
run COVHA_20200403_P1_H03_P

# probleme on exporte des tres long multisub

Variant "NC_045512:7151:Sub_56:GattctttagacacctatccttctttagaaactatacaaattaccatttcatcttT:TattctttagacacctatccttctttagaaactatacaaattaccatttcatcttA" // seg->a1/a2=1224770173/18771344, b1/b2=1235/306
Variant "NC_045512:7104:Sub_89:CctactgtactggttctataccttgtagtgtttgtcttagtggtttagattctttagacacctatccttctttagaaactatacaaatT:ActactgtactggttctataccttgtagtgtttgtcttagtggtttagattctttagacacctatccttctttagaaactatacaaatA" // seg->a1/a2=1224770173/18771344, b1/b2=1235/306
Variant "NC_045512:7529:Sub_19:GaatgtacaactattgttA:TaatgtacaactattgttT" // seg->a1/a2=1224770173/18771344, b1/b2=1235/321


phaseTSnp1a:
 set MB=2
 goto phaseTSnp1any
phaseTSnp1M:
 set MB="MB"

phaseTSnp1any:
if (! -d tmp/TSNP) mkdir tmp/TSNP


foreach run (`cat MetaDB/$MAGIC/RunsList`)
  if (! -d  tmp/TSNP/$run) then
     $mkDir TSNP $run
  endif

  echo > tmp/TSNP/$run/LaneList
  if (-e Fastc/$run/LaneList) then
    cat Fastc/$run/LaneList >  tmp/TSNP/$run/LaneList
  endif
  foreach r2 (`cat MetaDB/$MAGIC/r2sublib | gawk '{if($1==run)print $2;}' run=$run`)
    if (-e Fastc/$r2/LaneList) then
      cat Fastc/$r2/LaneList >>  tmp/TSNP/$run/LaneList
    endif
  end
end

tace MetaDB <<EOF
  query find project IS $MAGIC ; > run ; CLASS runs ; >ali
  select -o tmp/TSNP/r2t  a,t from a in @, tc in a->h_ali where tc == "z_genome", t in tc[3]
  query find project IS $MAGIC ; > run ; >ali   
  select -o tmp/TSNP/$MAGIC.minFrequency.txt a,f,t,z from a in @, f in a->Error_profile, t in f[1] where t == "Any", z in t[3]
  quit
EOF

if (-e TARGET/Targets/$species.mito.fasta.gz && ! -e tmp/SNP_ZONE/mito.fasta.gz) then
  cp TARGET/Targets/$species.mito.fasta.gz tmp/SNP_ZONE/mito.fasta.gz
endif

foreach run (`cat MetaDB/$MAGIC/RunsList`)
  if (! -e tmp/TSNP/$run/LaneList) continue 
  cat tmp/TSNP/$run/LaneList | gawk '{f[nn+0]=$1;nn++;}END{p = int((nn+9)/10);n=int(nn/p);dp=nn-n*p;m=0;for(i=0;i<p;i++){dq=0;if(dp>0)dq=1;dp--;for(j=0;j<n+dq;j++)printf("%d %s\n", i,f[m++]);}}' >  tmp/TSNP/$run/_t
  set nn=`cat tmp/TSNP/$run/_t | gawk '{n=$1;}END{print n}'`
  set nt=`cat  tmp/TSNP/r2t | gawk '{if($1==run)t=$2;}END{print t+0;}' run=$run`
  echo "$run desired number of bases $nt"
  if ($nt < 20000000) then
    set nn=0
    touch tmp/TSNP/$run/LaneList.0
    \rm tmp/TSNP/$run/LaneList.*
    # \rm tmp/TSNP/$run/*/tsnp1.*
    \cp tmp/TSNP/$run/LaneList  tmp/TSNP/$run/LaneList.0
  else
    touch tmp/TSNP/$run/LaneList.0
    \rm tmp/TSNP/$run/LaneList.*
    cat tmp/TSNP/$run/_t | gawk '{print $2 > ff"."$1;}' ff=tmp/TSNP/$run/LaneList
  endif
  
  foreach part (`seq 0 $nn`)
    foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
      if (! -d  tmp/TSNP/$run/$zone) mkdir tmp/TSNP/$run/$zone
      if (! -e tmp/TSNP/$run/$zone/tsnp1.$MB.0.deUno.tsf) then
        if ($Strategy == RNA_seq) then
	  set t1=0
	  set t2=0
        else
          set t1=`cat tmp/SNP_ZONE/_allG | gawk -F '\t' '{if("zoneG."$4==zone)n=$2;next;}END{print n+0;}' zone=$zone`
          set t2=`cat tmp/SNP_ZONE/_allG | gawk -F '\t' '{if("zoneG."$4==zone)n=$3;next;}END{print n+0;}' zone=$zone`
        endif
        if (! -e tmp/TSNP/$run/$zone/tsnp1.$MB.$part.deUno.tsf) then
          scripts/submit tmp/TSNP/$run/$zone/tsnp1.$MB.$part "scripts/tsnp1.tcsh $run $zone $MB $Strategy tmp/SNP_ZONE/$zone.fasta.gz tricoteur $part $t1 $t2" 32G
        endif
      endif
    end
  end
end

goto phaseLoop

###################################################################################
## using tsf   merge sublib counts in run counts, not important because the sublibs files were merged in tsnp1a
# kept as an example of merging files using bin/tsf
phaseTSnp1b:

goto phaseLoop

foreach run (`cat MetaDB/$MAGIC/RunsList MetaDB/$MAGIC/r2sublib | cut -f 1 | sort -u`)
  if (! -d tmp/TSNP/$run) continue
  foreach zone (`cat tmp/SNP_ZONE/ZoneList | grep -v mito`)
    if (! -d tmp/TSNP/$run/$zone) continue
    if (! -e tmp/TSNP/$run/$zone/tsnp1.2.0.deUno.tsf) continue
    if (-e tmp/TSNP/$run/$zone/tsnp2.2.deUno.tsf) continue
    set ok=1
    echo >  tmp/TSNP/$run/$zone/_r
    foreach lib (`cat MetaDB/$MAGIC/r2sublib | gawk '{if($1==run)print $2;}' run=$run`)
      if (! -e tmp/TSNP/$lib/$zone/tsnp1.2.0.deUno.tsf) then
        echo "missing file   tmp/TSNP/$lib/$zone/tsnp1.2.0.deUno.tsf"
        set ok=0
      else 
        cat  tmp/TSNP/$lib/$zone/tsnp1.2.*.deUno.tsf >>  tmp/TSNP/$run/$zone/_r
      endif
    end

    if ($ok == 0) continue
    if (-e  tmp/TSNP/$run/$zone/tsnp1.2.0.deUno.tsf)  then
       cat  tmp/TSNP/$run/$zone/tsnp1.2.0.deUno.tsf >>  tmp/TSNP/$run/$zone/_r
    endif
    scripts/submit tmp/TSNP/$run/$zone/tsnp1b "scripts/tsnp1b.tcsh $run $zone $minSnpCount $minSnpCover $minSnpFrequency" 
  end
end

goto phaseLoop

###################################################################################
## create a TSNP_DB database and parse the tsf files and the gene data
phasesnp2a:
phaseTSnp2a:

if (! -d tmp/TSNP_DB) mkdir tmp/TSNP_DB

foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
  if (! -d tmp/TSNP_DB/$zone) mkdir tmp/TSNP_DB/$zone
  if (! -e tmp/TSNP_DB/$zone/$MAGIC.$phase.done) then
    scripts/submit tmp/TSNP_DB/$zone/tsnp2a  "scripts/tsnp2.tcsh $phase $zone"
  endif
end
 
goto phaseLoop

###################################################################################
## make words 31 mers

phaseTSnp2b:

foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
  if (! -e tmp/TSNP_DB/$zone/tsnp2a.done) continue
  if (! -e tmp/TSNP_DB/$zone/tsnp2b.done) then
    scripts/submit tmp/TSNP_DB/$zone/tsnp2b  "scripts/tsnp2.tcsh tsnp2b $zone"
  endif
end

goto phaseLoop

###################################################################################
## count the words in all runs
phaseTSnp2c:

foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
  if (! -e tmp/TSNP_DB/$zone/tsnp2b.done) continue
    foreach run (`cat MetaDB/$MAGIC/RunsList`)
      if (-e tmp/TSNP_DB/$zone/tsnp2b.$MAGIC.w31.gz && -d tmp/TSNP/$run/$zone && ! -e  tmp/TSNP/$run/$zone/tsnp2c.$MAGIC.val.txt.gz) then
        scripts/submit tmp/TSNP/$run/$zone/tsnp2c  "scripts/tsnp2.tcsh tsnp2c $zone $run"
      endif
    end
  endif
end

goto phaseLoop


scripts/submit  tmp/TSNP/$run/tsnp2  "bin/tricoteur -count -wLn 31 -wordFile tmp/TSNP_DB/$zone/tsnp2.$MAGIC.w31.gz -run $run -gzo -o tmp/TSNP/$run/tsnp2.$MAGIC.$zone -antistrand" 32G
###################################################################################
## Report separate tables for sub, del, ins
phaseTSnp3:
foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
  if (! -d tmp/TSNP_DB/$zone) goto phaseLoop
  scripts/submit tmp/TSNP_DB/$zone/tsnp3 "scripts/tsnp3.tcsh  $Strategy $zone" 32G
end
goto phaseLoop
  
###################################################################################

phases1c:
set toto="snp.collect.job_stats.txt"
date >! $toto
echo -n 'Status' >> $toto
foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
  echo -n "\t$zone" >> $toto
end
echo -n '\t\tCPU' >> $toto
foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
  echo -n "\t$zone" >> $toto
end
echo -n '\t\tMemory' >> $toto
foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
  echo -n "\t$zone" >> $toto
end
echo " " >> $toto
set total=0
foreach run (`cat MetaDB/$MAGIC/RunList`) 
  echo -n "$run" >> $toto
  foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
    set ff=tmp/SNP_BRS/$run/$zone.snp.err
          if (-e $ff) then
            gawk '/Status/{n++;z+=$4;}END{if(n==0)z=-1;printf("\t%d",z);}' $ff >> $toto
          else
            echo -n "\t-1" >> $toto
          endif
  end

  echo -n '\t\t' >> $toto
  echo -n "$run" >> $toto
  foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
    set ff=tmp/SNP_BRS/$run/$zone.snp.err
     if (-e $ff) then
            set cpu=`gawk '/CPU/{n++;t=$3;split(t,z,":");s+=3600*z[1] + 60*z[2] + z[3]; }END{if(n==0)s=-10;printf("%d",s);}' $ff`
            echo -n "\t$cpu" >> $toto
            @ total = $total + $cpu
     else
            echo -n "\t-10" >> $toto
     endif
  end

  echo -n '\t\t' >> $toto
  echo -n "$run" >> $toto
  foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
    set ff=tmp/SNP_BRS/$run/$zone.snp.err
          if (-e $ff) then
            gawk -F '\n' '/max memory/{i = index($1,"max memory");s=substr($1,i+11);split(s,aa," ");mem=aa[1];}END{printf("\t%d",mem);}' $ff >> $toto
          else
            echo -n "\t-1" >> $toto
          endif
  end
  echo -n '\n' >> $toto
end
mv  $toto RESULTS

goto phaseLoop

###############################################################################################
# Collate theA2G
phases1A2G:

if (! -e tmp/SNP_ZONE/ZoneList || ! -d tmp/SNP_BRS) goto phaseLoop
if ($MAGIC_A2G == 1) then
  foreach run (`cat MetaDB/$MAGIC/RunList`) 
    foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
      if (-e  tmp/SNP_BRS/$run/$zone.BRS.u.gz && ! -e  tmp/SNP_BRS/$run/$zone.a2g.u.gz) then
        scripts/submit  tmp/SNP_BRS/$run/$zone.a2g "scripts/s2r.a2g_collect.tcsh $run $zone"
      endif
    end
  end
  echo "phase s1A2G done"
endif
goto phaseLoop

###############################################################################################

phases2A2G:
if (! -e tmp/SNP_ZONE/ZoneList || ! -d tmp/SNP_BRS) goto phaseLoop

if ($MAGIC_A2G == 1) then
  foreach run (`cat MetaDB/$MAGIC/RunsList MetaDB/$MAGIC/GroupAdditiveList`)
    echo > tmp/SNP_BRS/$run.tati
    foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
      gunzip -c tmp/SNP_BRS/$run/$zone.a2g.u.gz | gawk -F '\t' '{if($5 > 10)print}' | sort -k 1,1 -k 2,2n >> tmp/SNP_BRS/$run.tati
    end
    cat tmp/SNP_BRS/$run.tati | gawk -F '\t' -f scripts/s21.snpA2G.awk run=$run >>  tmp/SNP_BRS/$MAGIC.runs.A2G
    \rm tmp/SNP_BRS/$run.tati
  end
  echo "phase s2A2G done"
endif

goto phaseLoop
cat tmp/SNP_BRS/$MAGIC.runs.A2G | sort -k 2,2 -k 3,3n | gawk -F '\t' '{chrom=$2;x1=$3;x2=$4;if(chrom != old || x1 > y2+100){if(old)printf("%s\t%d\t%d\n",old,y1,y2);y1=x1;}old=chrom;y2=x2;}END{if(old)printf("%s\t%d\t%d\n",old,y1,y2);}'
e

###############################################################################################
# Collate the BRS files of sublibraries
phases2a:

if (! -e tmp/SNP_ZONE/ZoneList || ! -d tmp/SNP_BRS) goto phaseLoop

foreach group (`cat MetaDB/$MAGIC/RunHasSubLibList`) 
  if (! -d tmp/SNP_BRS/$group)  $mkDir SNP_BRS $group

  foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
    if (! -e  tmp/SNP_BRS/$group/ss2.$zone.done) then
      set ok=0
      set flist=tmp/SNP_BRS/$group/ss2.$zone.file_list
      if (-e $flist) \rm $flist
      foreach run (`cat MetaDB/$MAGIC/r2sublib | gawk -F '\t' '{if($1 == g)print $2;}' g=$group | sort -u`)
        if (-e tmp/SNP_BRS/$run/$zone.BRS.u.gz) then
          echo tmp/SNP_BRS/$run/$zone.BRS.u.gz  >> $flist 
          set ok=1
        endif
      end
      if ($ok == 1) then
       # echo "scripts/ss2.mergeBRS $group $zone"
        scripts/submit  tmp/SNP_BRS/$group/ss2.$zone "scripts/ss2.mergeBRS.tcsh $group $zone"
      endif
    endif
 
  end
end
echo "phase s2a done"
goto phaseLoop

###############################################################################################
# Collate the BRS files of groups SNP AND add_counts treating subgroups as atomic
# on the other hand there is no good reason to BRS count in non-addCounts groups
# actually it is probably more efficient to do the addition in the count/collect phase
phases2b:

set groupLevelMax=`cat  MetaDB/$MAGIC/g2r | cut -f 3 | sort -k 1n | tail -1`
foreach level (`seq 1 1 $groupLevelMax`)
echo level=$level
  set okk=0
  foreach group (`cat MetaDB/$MAGIC/GroupSnpAdditiveList`)
echo group=$group
    set gLevel=`cat MetaDB/$MAGIC/g2r |  gawk -F '\t' '{if($1==g)level=$3}END{print 0+level}' g=$group` 
    if ($gLevel != $level) continue
echo group-level=$group.$level

    if (! -d tmp/SNP_BRS/$group)   $mkDir SNP_BRS $group
    foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
      if (! -e  tmp/SNP_BRS/$group/ss2.$zone.done) then
        set ok=0
        set flist=tmp/SNP_BRS/$group/ss2.$zone.file_list
        if (-e $flist) \rm $flist
        foreach run (`cat MetaDB/$MAGIC/g2r | gawk -F '\t' '{if($1 == g)print $2;}' g=$group | sort -u`)
          if (-e tmp/SNP_BRS/$run/$zone.BRS.u.gz) then
            echo tmp/SNP_BRS/$run/$zone.BRS.u.gz  >> $flist 
            set ok=1
          endif
        end
        if ($ok == 1) then
         # echo "scripts/ss2.mergeBRS $group $zone"
          scripts/submit  tmp/SNP_BRS/$group/ss2.$zone "scripts/ss2.mergeBRS.tcsh $group $zone"
          set okk=1
        endif
      endif

    end
  end
  if ($okk == 1) then
    echo "Waiting for collation of BRS SNP files group-level $level"
    scripts/submit wait
  endif
end

goto phaseLoop

###############################################################################################
# Detect  the candidate SNPs per run or group filtered on Cover/Frequency, export in tmp/SNP 

phases3a:
  set justMito=0
  set collect=detect
   # use low thresholds for the first detection, then consolidate in s3a (SNPG) 
  goto phases3ab
phases3b:
  set justMito=0 
  set collect=count
  goto phases3ab
phases3am:
  set justMito=1
  set collect=detect
   # use low thresholds for the first detection, then consolidate in s3a (SNPG) 
  goto phases3ab
phases3bm:
  set justMito=1 
  set collect=count
  goto phases3ab

phases3ab:
if (! -d tmp/SNP_BRS || ! -e tmp/SNP_ZONE/ZoneList) goto phaseLoop
if (! -d tmp/SNP_LIST) mkdir  tmp/SNP_LIST

set MAGIC2=$MAGIC
if (-e tmp/SNP_LIST/GlobalProject) then
  set MAGIC2=`cat tmp/SNP_LIST/GlobalProject`
endif

if ($Strategy == Exome) then
  set zones1="mito SpikeIn"
  set zones2=`cat tmp/SNP_ZONE/ZoneList`
else
  set zones1="SpikeIn rrna geneset"
  set zones2=`cat tmp/SNP_ZONE/ZoneList`
endif

if ($justMito == 1) then
  set zones1="mito SpikeIn"
  set zones2=""
endif

foreach zone ($zones1 $zones2)

  echo "... $phase $zone"
  if (! -d tmp/SNP_LIST/$zone)    mkdir  tmp/SNP_LIST/$zone

  if ($collect == count) then

    set ok=0
    echo >  tmp/SNP_LIST/$zone/$MAGIC.SnpRunList.new
    foreach run (`cat MetaDB/$MAGIC/RunsList MetaDB/$MAGIC/GroupSnpAdditiveList`) 
      echo $run >> tmp/SNP_LIST/$zone/$MAGIC.SnpRunList.new
      if (! -e tmp/SNP/$run/$MAGIC2.snp.$collect.done) set ok=1
    end
    if ($ok == 0) goto phaseLoop

    cat tmp/SNP_LIST/$zone/$MAGIC.SnpRunList.new | sort -u > tmp/SNP_LIST/$zone/$MAGIC.SnpRunList.new.sorted
    mv tmp/SNP_LIST/$zone/$MAGIC.SnpRunList.new.sorted tmp/SNP_LIST/$zone/$MAGIC.SnpRunList.new
    set needCleanUp=1
    if (-e  tmp/SNP_LIST/$zone/$MAGIC.SnpRunList) then
      set n=`diff tmp/SNP_LIST/$zone/$MAGIC.SnpRunList tmp/SNP_LIST/$zone/$MAGIC.SnpRunList.new | wc -l`
      if ($n == 0) set needCleanUp=0
    endif
    if ($needCleanUp == 0) then
      \rm tmp/SNP_LIST/$zone/$MAGIC.SnpRunList.new
    else
      \cp tmp/SNP_LIST/$zone/$MAGIC.SnpRunList.new tmp/SNP_LIST/$zone/$MAGIC.SnpRunList
      \rm tmp/SNP_LIST/$zone/$MAGIC.SnpRunList.new  tmp/SNP_LIST/$zone/$MAGIC.Variant.list tmp/SNP/$MAGIC.$zone.* tmp/SNPH/$MAGIC.* tmp/SNPH/$zone/$MAGIC.* tmp/SNP_DB/$MAGIC.* tmp/SNP_DB/$zone/$MAGIC.*  tmp/SNP_DB/$zone/snp.*.done
    endif

    touch tmp/SNP_LIST/$zone/$MAGIC.Variant.list
    if (-e  FinalVlist/$zone.list) then
      set ok=2
      \cp  FinalVlist/$zone.list tmp/SNP_LIST/$zone/$MAGIC.Variant.list
    endif
    if ($ok == 1) then
      echo "Variant toto" >  tmp/SNP_LIST/$zone/$MAGIC.Variant.list1  
      foreach run (`cat MetaDB/$MAGIC/RunsList MetaDB/$MAGIC/GroupAdditiveList`)
        if (-e tmp/SNP_LIST/$zone/Variant.$run.u.list) then
          cat  tmp/SNP_LIST/$zone/Variant.$run.u.list | $tab_sort -u >>   tmp/SNP_LIST/$zone/$MAGIC.Variant.list1  
        endif
      end

      # cat position_somatic_TCGA.csv | gawk '{gsub(/>/,"2",$3);if(index($3,"-")==0 && length($3)<6)printf("%s:%s_%s\n",$1,$2,$3);}' | $tab_sort -u > position_somatic_TCGA.VLIST
      # cat RESULTS/GenomatixSNV_KatherineDec2014/*.vcf  RESULTS/PartekSNP_KatherineDec2014/*.vcf | gawk -F '\t' '/^#/{next;}{c=$1;gsub("chr","",c);if(length($4)==1 && length($5)==1)printf("%s:%s_%s2%s\n",c,$2,$4,$5);}' | $tab_sort -u > ExernalVlist 

      # export from the Exome_seq a table snp/mrna IS *aug*/rigth/snp->type then complement
      # cat snp_with_mrna.txt | gawk -F '\t' '{gsub(/\"/,"",$0);if($4==1)printf("%s:%d:%s\n",$2,$3,$5);}' > NBe2NB.snp.list  
      # cat snp_with_mrna.txt | gawk -F '\t' '{gsub(/\"/,"",$0);if($4==1)next;z=$5;gsub(/A/,"t",z);gsub(/T/,"a",z);gsub(/G/,"c",z);gsub(/C/,"g",z);printf("%s:%d:%s\n",$2,$3,z);}' >>  NBe2NB.snp.list   

      if (-e ../position_somatic_TCGA.VLIST) cat  ../position_somatic_TCGA.VLIST >>  tmp/SNP_LIST/$zone/$MAGIC.Variant.list1  
      if (-e ExternalVlist/$zone.list) then
         cat  ExternalVlist/$zone.list  >>  tmp/SNP_LIST/$zone/$MAGIC.Variant.list1  
      else
        if (-e ExternalVlist) cat  ExternalVlist  >>  tmp/SNP_LIST/$zone/$MAGIC.Variant.list1  
      endif
      if (-e   tmp/SNP_LIST/$zone/$MAGIC.Variant.list1) then
        cat   tmp/SNP_LIST/$zone/$MAGIC.Variant.list1 | sort -u >  tmp/SNP_LIST/$zone/$MAGIC.Variant.list
        \rm   tmp/SNP_LIST/$zone/$MAGIC.Variant.list1  
      endif
      if (-e tmp/SNP_DB/$zone/snp.parse.done)  \rm tmp/SNP_DB/$zone/snp.parse.done
    endif
  endif
end

if (0) then
  mkdir  ~/HumanRunsMasterDB/SNP_LIST_NB_Fatigue123.2016_02_03
  foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
    cat ~/NB/tmp/SNP_LIST/$zone/NB_DEG2.Variant.list ~/Fatigue3/tmp/SNP_LIST/$zone/Fatigue3.Variant.list ~/Fatigue/tmp/SNP_LIST/$zone/Fatigue.Variant.list | sort -u >  ~/HumanRunsMasterDB/SNP_LIST_NB_Fatigue123.2016_02_03/$zone.list
  end
endif


if (! -d tmp/SNP) mkdir  tmp/SNP
if (! -d tmp/SNP_BRS) mkdir  tmp/SNP_BRS

if (1 || ! -e tmp/SNP_BRS/$MAGIC.minFrequency.txt) then
    bin/tace MetaDB <<EOF > /dev/null
      query find project IS $MAGIC ; > run ; >ali   
      select -o tmp/SNP_BRS/$MAGIC.minFrequency.txt a,f,t,z from a in @, f in a->Error_profile, t in f[1] where t == "Any", z in t[3]
      quit
EOF

foreach run (`cat MetaDB/$MAGIC/RunsList MetaDB/$MAGIC/GroupSnpAdditiveList`) 
  # RunsList avoids runs which are sublibraries
  # do not count/detect in non-additive groups
  if (! -d  tmp/SNP_BRS/$run) continue
   if (! -d tmp/SNP/$run) $mkDir  SNP $run

    if ($collect == count) then
      set ok=1
      foreach z ( `cat tmp/SNP_ZONE/ZoneList` )
        if (0 && ! -e  tmp/SNP/$run/$z.detect.u.snp.gz) then
          echo "Run $run : missing file  tmp/SNP/$run/$z.detect.u.snp.gz"
          set ok=0
        endif
      end
      if ($ok == 10) continue
    endif

    if ((-e tmp/SNP/$run/snp.$collect.done) || ($justMito == 1 && -e tmp/SNP/$run/snp.$collect.$justMito.done)) continue

    set pool="pool"
      foreach run2 (`cat MetaDB/$MAGIC/RunSingleIndividualList`)    
        if ($run == $run2) set pool="XX"
      end

    set solid="XX"
    foreach run2 (`cat MetaDB/$MAGIC/RunSolidList`)
      if ($run == $run2) set solid="solid"
    end

    echo "scripts/snp.collect.tcsh $run $justMito  $pool $solid $collect minFrequency=$minSnpFrequency"
    if (-e tmp/SNP/$MAGIC.candidate_variants_detected_by_BRS.txt) \rm tmp/SNP/$MAGIC.candidate_variants_detected_by_BRS.txt


    foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
      if ($justMito == 1 && $zone != mito && $zone != SpikeIn) continue
      if (! -e tmp/SNP_BRS/$run/$zone.BRS.u.gz) continue

      if ($justMito == 1 && -e tmp/SNP/$run/$zone.snp.$collect.$justMito.done) continue
      if ($collect == detect && -e tmp/SNP/$run/$zone.snp.$collect.done && -e tmp/SNP_LIST/$zone/Variant.$run.u.list) continue
      if ($collect == count && -e tmp/SNP/$run/$MAGIC2.$zone.snp.$collect.done) continue 

      echo "submit scripts/snp.collect.tcsh $run $justMito $pool $solid $collect $zone "
      scripts/submit tmp/SNP/$run/$zone.snp.$collect "scripts/snp.collect.tcsh $run $justMito $pool $solid $collect $zone "
    end
end

echo "phase $phase done"

goto phaseLoop

# hack to study the standard deviation when we try to compensate the 3' biais
ls RESULTS/Expression/unique/av*/NB*index_sta*gz
RESULTS/Expression/unique/av.area75/NB_export_area75.AceView.GENE.u.index_standard_deviation.txt.gz
RESULTS/Expression/unique/av.noCorrection/NB_export_noCorrection.AceView.GENE.u.index_standard_deviation.txt.gz
RESULTS/Expression/unique/av/NB_export_h20.AceView.GENE.u.index_standard_deviation.txt.gz
RESULTS/Expression/unique/av_h20/NB_export_h20.AceView.GENE.u.index_standard_deviation.txt.gz
RESULTS/Expression/unique/av_march5/NB_export.AceView.GENE.u.index_standard_deviation.txt.gz

foreach type (h20 area75 noCorrection)
  set ff=RESULTS/Expression/unique/av.$type/NB_export_$type.AceView.GENE.u.index_standard_deviation.txt.gz
  gunzip -c $ff | gawk -F '\t' '/^#/{next;}{chrom=$6;idx=$15;std=$16;if(chrom=="X" || chrom=="Y")next;if(idx>0)print idx;}' | bin/histo -plain -plot -o std.$type.indexes
  \cp  std.$type.indexes.txt RESULTS


  gunzip -c $ff | gawk -F '\t' '/^#/{next;}{chrom=$6;idx=$15;std=$16;if(chrom=="X" || chrom=="Y")next;if(idx>0)print std;}' | bin/histo -plain -plot -o std.$type.any
  \cp  std.$type.any.txt RESULTS


  gunzip -c $ff | gawk -F '\t' '/^#/{next;}{chrom=$6;idx=$15;std=$16;if(chrom=="X" || chrom=="Y")next;if(idx>13)print std;}' | bin/histo -plain -plot -o std.$type.idx_over_13
  \cp  std.$type.idx_over_13.txt RESULTS
  gunzip -c $ff | gawk -F '\t' '/^#/{next;}{chrom=$6;idx=$15;std=$16;if(chrom=="X" || chrom=="Y")next;if(idx>9 && idx < 13)print std;}' | bin/histo -plain -plot -o std.$type.idx_9_13
  \cp  std.$type.idx_9_13.txt RESULTS
  gunzip -c $ff | gawk -F '\t' '/^#/{next;}{chrom=$6;idx=$15;std=$16;if(chrom=="X" || chrom=="Y")next;if(idx>6 && idx<9)print std;}' | bin/histo -plain -plot -o std.$type.idx_6_9
  \cp  std.$type.idx_6_9.txt RESULTS
  gunzip -c $ff | gawk -F '\t' '/^#/{next;}{ln=$5;chrom=$6;idx=$15;std=$16;if(chrom=="X" || chrom=="Y")next;if(ln>5000)print std;}' | bin/histo -plain -plot -o std.$type.ln_over_5kb
  \cp  std.$type.ln_over_5kb.txt RESULTS
  gunzip -c $ff | gawk -F '\t' '/^#/{next;}{ln=$5;chrom=$6;idx=$15;std=$16;if(chrom=="X" || chrom=="Y")next;if(ln>2000 && ln<5000)print std;}' | bin/histo -plain -plot -o std.$type.ln_2_5kb
  \cp  std.$type.ln_2_5kb.txt RESULTS
  gunzip -c $ff | gawk -F '\t' '/^#/{next;}{ln=$5;chrom=$6;idx=$15;std=$16;if(chrom=="X" || chrom=="Y")next;if(ln>000 && ln<2000)print std;}' | bin/histo -plain -plot -o std.$type.ln_below_2kb
  \cp  std.$type.ln_below_2kb.txt RESULTS

end


###############################################################################################
## s2c : Locally reextend the alignments

phases2c:

echo -n "phase s2c reextend the SNP alignments:NOT yest programmed "
goto phaseLoop
date
if (! -d tmp/SNP) goto phaseLoop

set fasta=fasta
foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (-e tmp/SNP/$run/s2c.list) \rm tmp/SNP/$run/s2c.list
  foreach zone  ( `cat tmp/SNP_ZONE/ZoneList` )
    foreach ff (`ls tmp/SNP/$run/$zone.count.u.txt.gz`)
      echo "$run\t$zone\t$ff"
      if (! -e tmp/SNP/$run/$zone.extend.u.txt.gz) then
        if (! -e tmp/SNP/$run/s2c.list) then
          ls tmp/COUNT/$run/*.hits.gz > tmp/SNP/$run/s2c.hits_file.list
        endif

        echo "scripts/submit tmp/SNP/$run/$zone.extend  scripts/s2c.snp_extend.tcsh $run $zone $ff"
              scripts/submit tmp/SNP/$run/$zone.extend "scripts/s2c.snp_extend.tcsh $run $zone $ff"
      endif
    end
  end
end

goto phaseLoop

###############################################################################################

phases4a:

set toto=RESULTS/$MAGIC.AUC_statistics.txt
echo -n " " > $toto
date >> $toto

\rm tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace
scripts/geneindex.tcsh snp4 000

# Ov Aspi Clopi Lipid Salt) 
foreach XXX (HRD  NoLib3 atig) 
if ($MAGIC == NBS && $XXX != HRD) continue
if ($MAGIC == NBS80_20 && $XXX != HRD) continue
if ($MAGIC != NBS && $MAGIC != NBS80_20 && $XXX == HRD) continue
if ($MAGIC == F12 && $XXX != NoLib3) continue
if ($MAGIC =~ B[0-9]* && $XXX != Ov) continue

foreach type (true VV)
  set XXX=""
  set typ="FC$XXX"
  if ($type == random) set typ=Rdm$XXX
  if ($type == VV) set typ=VV$XXX

echo -n "\n# AUC and AUC2 averages in the $type stratification SNPs, Unique, no iteration:" >> $toto
  grep "Plus genes"   RESULTS/Expression/unique/snp/$MAGIC.snp.*SNP.u.$typ*beta.0.txt | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -12 | gawk 'BEGIN{printf("Plus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto
  grep "Minus genes" RESULTS/Expression/unique/snp/$MAGIC.snp.*SNP.u.$typ*beta.0.txt  | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -12 | gawk 'BEGIN{printf("Minus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto

  grep AUC  RESULTS/Expression/unique/snp/$MAGIC.snp.*SNP.u.$typ*beta.0.txt | cut -f 1,2,6 | gawk -F '\t' '{if ($3>10){n++;u+=$2;v+=$3;}}END{if(n < 1)n=1;printf("Average of %d cases\t%.1f\t%.1f\n", n,u/n,v/n);}' >> $toto
  grep AUC  RESULTS/Expression/unique/snp/$MAGIC.snp.*SNP.u.$typ*beta.0.txt | cut -f 1,2,6 >> $toto 

echo -n "\n# AUC and AUC2 averages in the $type stratification SNPs, Unique, iterated: " >> $toto
  grep "Plus genes"   RESULTS/Expression/unique/snp/$MAGIC.snp.*SNP.u.$typ*beta.1.txt | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -12 | gawk 'BEGIN{printf("Plus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto
  grep "Minus genes" RESULTS/Expression/unique/snp/$MAGIC.snp.*SNP.u.$typ*beta.1.txt  | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -12 | gawk 'BEGIN{printf("Minus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto

  grep AUC  RESULTS/Expression/unique/snp/$MAGIC.snp.*SNP.u.$typ*beta.1.txt | cut -f 1,2,6 | gawk -F '\t' '{if ($3>10){n++;u+=$2;v+=$3;}}END{if(n < 1)n=1;printf("Average of %d cases\t%.1f\t%.1f\n", n,u/n,v/n);}' >> $toto
  grep AUC  RESULTS/Expression/unique/snp/$MAGIC.snp.*SNP.u.$typ*beta.1.txt | cut -f 1,2,6 >> $toto 

if ($Strategy != RNA_seq) continue

foreach mtmt (0 1)
foreach target (RefSeq av EBI seqc)
 if (! -d tmp/PHITS_$target) continue
 set target2=$target
 if ($target == av) set target2=AceView

set MT=$MAGIC.$target.GENE
set GM=Genes
if ($mtmt == 1) then
  set MT=$MAGIC.$target.MRNAH
  set GM=MRNAH
endif

echo "\n\n# AUC and AUC2 averages in the $type stratifications, $GM, $MT, Unique, no iteration: " >> $toto
  grep "Plus genes" RESULTS/Expression/unique/$target2/$MT.u.$typ*beta.0.txt | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -24 | gawk 'BEGIN{printf("Plus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto
  grep "Minus genes" RESULTS/Expression/unique/$target2/$MT.u.$typ*beta.0.txt | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -24 | gawk 'BEGIN{printf("Minus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto

  grep AUC RESULTS/Expression/unique/$target2/$MT.u.$typ*beta.0.txt | cut -f 1,2,6 |  gawk -F '\t' '{n++;u+=$2;v+=$3;}END{if(n < 1)n=1;printf("Average of %d %s %s cases\t%.1f\t%.1f\n", n,MT,TYP,u/n,v/n);}' MT=$MT TYP=$type >> $toto
  grep AUC RESULTS/Expression/unique/$target2/$MT.u.$typ*beta.0.txt | cut -f 1,2,6 >> $toto

echo "\n# AUC and AUC2 averages in the $type stratifications, $GM, $MT, Unique, iterated: " >> $toto
  grep "Plus genes"  RESULTS/Expression/unique/$target2/$MT.u.$typ*beta.1.txt  | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -24 | gawk 'BEGIN{printf("Plus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto
  grep "Minus genes"  RESULTS/Expression/unique/$target2/$MT.u.$typ*beta.1.txt  | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -24 | gawk 'BEGIN{printf("Minus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto

  grep AUC RESULTS/Expression/unique/$target2/$MT.u.$typ*beta.1.txt | cut -f 1,2,6 |  gawk -F '\t' '{n++;u+=$2;v+=$3;}END{if(n < 1)n=1;printf("Average of %d %s %s cases\t%.1f\t%.1f\n", n,MT,TYP,u/n,v/n);}' MT=$MT TYP=$type >> $toto
  grep AUC RESULTS/Expression/unique/$target2/$MT.u.$typ*beta.1.txt | cut -f 1,2,6 >> $toto

echo "\n\n# AUC and AUC2 averages in the $type stratifications, $GM, $MT, Non-unique, no iteration: " >> $toto
  grep "Plus genes"  RESULTS/Expression/quasi_unique/$target2/$MT.nu.$typ*beta.0.txt  | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -24 | gawk 'BEGIN{printf("Plus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto
  grep "Minus genes"  RESULTS/Expression/quasi_unique/$target2/$MT.nu.$typ*beta.0.txt  | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -24 | gawk 'BEGIN{printf("Minus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto

  grep AUC RESULTS/Expression/quasi_unique/$target2/$MT.nu.$typ*beta.0.txt | cut -f 1,2,6 |  gawk -F '\t' '{n++;u+=$2;v+=$3;}END{if(n < 1)n=1;printf("Average of %d %s %s cases\t%.1f\t%.1f\n", n,MT,TYP,u/n,v/n);}' MT=$MT TYP=$type >> $toto 
  grep AUC RESULTS/Expression/quasi_unique/$target2/$MT.nu.$typ*beta.0.txt | cut -f 1,2,6 >> $toto 

echo "\n# AUC and AUC2 averages in the $type stratifications, $GM, $MT, Non-unique, iterated: " >> $toto
  grep "Plus genes"  RESULTS/Expression/quasi_unique/$target2/$MT.nu.$typ*beta.1.txt | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -24 | gawk 'BEGIN{printf("Plus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto
  grep "Minus genes" RESULTS/Expression/quasi_unique/$target2/$MT.nu.$typ*beta.1.txt | gawk -F '\t' '{for(i=3;i<=NF;i++)n[$i]++;}END{for(k in n)printf("%d\t%s\n",n[k],k);}' | $tab_sort -k 1,1nr | head -24 | gawk 'BEGIN{printf("Minus genes\t");}{printf("%s[%d] ",$2,$1);}END{printf("\n");}' >> $toto

  grep AUC RESULTS/Expression/quasi_unique/$target2/$MT.nu.$typ*beta.1.txt | cut -f 1,2,6 |  gawk -F '\t' '{n++;u+=$2;v+=$3;}END{if(n < 1)n=1;printf("Average of %d %s %s cases\t%.1f\t%.1f\n", n,MT,TYP,u/n,v/n);}' MT=$MT TYP=$type >> $toto 
  grep AUC RESULTS/Expression/quasi_unique/$target2/$MT.nu.$typ*beta.1.txt | cut -f 1,2,6 >> $toto 

end
end
end
end

mv $toto $toto.99
cat $toto.99 | sed -e 's/RESULTS\/Expression\/Expression_//g' >  $toto 
\rm  $toto.99

echo $toto
goto phaseLoop

###############################################################################################
## s10: report the per run and type the mismatches and candidate SNPs in RESULTS/SNV

phases10: 

echo -n "phase s10 : report the per run and type the mismatches and candidate SNPs in RESULTS/SNV "
date
if (! -d RESULTS/SNV) mkdir RESULTS/SNV

if (-d Bzzzzzzzzzzzz) \rm -rf  Bzzzzzzzzzzzz

# Multi Venn diagram the mismatches of all types in the same format
set MAGIC2=$MAGIC
if (-e tmp/SNP_LIST/GlobalProject) then
  set MAGIC2=`cat tmp/SNP_LIST/GlobalProject`
endif

set toto=tmp/COUNT/$MAGIC.mismatch_type_in_best_ali.txt

if (! -e $toto) then
  date > $toto
  echo "Distribution of the types of mismatches in the best unique alignments, no clustering, no thresholds" >> $toto
  # foooreach run (`cat MetaDB/$MAGIC/RunsList MetaDB/$MAGIC/GroupAdditiveList`)
  #  cat MetaDB/$MAGIC/Error_type.txt | gawk '{ r=$1;gsub(/\"/,"",r); if(r == run)print;}' run=$run >> $toto.tmp
  # ennnd
  cat MetaDB/$MAGIC/RunListSorted  MetaDB/$MAGIC/GroupAdditiveList ZZZZZ  MetaDB/$MAGIC/gtitle.txt ZZZZZ  MetaDB/$MAGIC/Error_type.txt  | gawk -F '\t' -f scripts/snpSupportStat.awk  format=Error_type minMut=1 minCover=1 minF=0 >> $toto

  # \rm $toto.tmp
  \cp  $toto RESULTS/SNV
endif

# we no longer want to export the candidate SNPs
echo "phase s10 done : $toto" 
goto phaseLoop


# Multi Venn diagram of the candidate SNP detected by BRS

foreach minFreq (20 95)

  set toto=tmp/SNP/$MAGIC.SNP_types_seen_at_least_once_above_$minFreq'_and_coverage_'$minSnpCover.txt
  if (! -e $toto) then

    echo -n "# " > $toto
    date >> $toto
    echo "# Table of candidate SNPs, i.e. mismatches seen significantly in each run or group" >> $toto
    foreach dce (count)

      if ($dce == detect) then
        echo "\n# Number of candidate variant and their support detected by the BRS analysis in each run" >> $toto
        echo "# each variant is seen at frequency at least $minFreq %, coverage at least $minSnpCover, with at least $minSnpCount supporting reads" >> $toto
        echo "# Only read-pairs aligning uniquely over at least 90% of their length are considered." >> $toto
      endif  
      if ($dce == count) then
        echo "\n# Number of candidate variant and their support counted by the BRS analysis in any run" >> $toto
        echo "# each variant is seen at frequency $minSnpFrequency %, coverage $minSnpCover, with $minSnpCount supporting reads" >> $toto
        echo "# Only read pairs aligning uniquely over at least 90% of their length are considered." >> $toto
      endif  
      if ($dce == extend) then
        echo "\n# Number of candidate variant and their support after extension" >> $toto
        echo "# each variant is seen at frequency $minFreq %, coverage $minSnpCover, with $minSnpCount supporting reads" >> $toto
      endif
  
      echo " " >! $toto.tmp
      foreach run (`cat MetaDB/$MAGIC/RunListSorted MetaDB/$MAGIC/GroupAdditiveList`)
  
        set n1=`ls -ls tmp/SNP/$run/zone*.detect.u.snp.gz | wc -l`
        set n2=`ls -ls tmp/SNP/$run/$MAGIC2.zone*.count.u.snp.gz | wc -l`
        if ($n1 != $n2) then
          echo "Run $run : $n1 zones $n2 $dce files, missing some, please rerun phase s3a/s3b"
        endif
        if ($n2>0) then
          gunzip -c tmp/SNP/$run/*.$dce.u.txt.gz | grep -v N_rich | grep -v Incompatible_strands >> $toto.tmp
        endif
      end
      echo "cat MetaDB/$MAGIC/RunListSorted  MetaDB/$MAGIC/GroupAdditiveList ZZZZZ  MetaDB/$MAGIC/gtitle.txt ZZZZZ $toto.tmp | gawk -F '\t' -f scripts/snpSupportStat.awk  format=snpq minMut=$minSnpCount minCover=$minSnpCover minF=$minFreq"
            cat MetaDB/$MAGIC/RunListSorted  MetaDB/$MAGIC/GroupAdditiveList ZZZZZ  MetaDB/$MAGIC/gtitle.txt ZZZZZ $toto.tmp | gawk -F '\t' -f scripts/snpSupportStat.awk  format=snpq minMut=$minSnpCount minCover=$minSnpCover minF=$minFreq >> $toto
      # \rm $toto.tmp
    end
  
  endif 
  if (-e $toto) bin/rsync -ah  $toto RESULTS/SNV
end

echo "phase s10 done : $toto" 
goto phaseLoop

###############################################################################################
## s11: collate in tmp/SNPH all SNPs, filter, and look for differential

phases11: 
echo -n "phase s11: collate in tmp/SNPH all SNPs, filter, and look for differential "
date

# create the zones 
if (! -d  tmp/SNPH) mkdir tmp/SNPH
if (! -d  tmp/GENEINDEX) mkdir tmp/GENEINDEX
scripts/geneindex.tcsh snp4 000

if (-d Bzzzzzzzzzzzz) \rm  Bzzzzzzzzzzzz
set n=`cat MetaDB/$MAGIC/RunListSorted  MetaDB/$MAGIC/GroupSnpAdditiveList  | wc | gawk '{print $1}'`
if ($n < 1) then
  echo "No run or additive group in this project has the tag SNP,  phase s11 cannot proceed"
  goto phaseLoop
endif

set MAGIC2=$MAGIC
if (-e tmp/SNP_LIST/GlobalProject) then
  set MAGIC2=`cat tmp/SNP_LIST/GlobalProject`
endif

foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
  if (! -d  tmp/SNPH/$zone) mkdir tmp/SNPH/$zone
  scripts/submit tmp/SNPH/$zone/s11 "scripts/s11.cover.tcsh $zone $MAGIC2"
end

goto phaseLoop

###############################################################################################
## s12: report the per run and type the quality filtered and differential SNPs in RESULTS/SNV

phases12: 
set n=`cat MetaDB/$MAGIC/RunsList  MetaDB/$MAGIC/GroupSnpAdditiveList  | wc | gawk '{print $1}'`
if ($n < 1) then
  echo "No run or group in this project has the tag SNP,  phase s12 cannot proceed"
  goto phaseLoop
endif

# in retina we want zoner.[56]  chr=6 a1=99770000 a2=100430000
if (! -d  tmp/SNPH/Histo) mkdir  tmp/SNPH/Histo
if ($MAGIC == Retina) then
  cat tmp/SNPH/*/$MAGIC.snp.sorted  | gawk -F '\t' '/^#/{next;}{c=$1;x=0+$2;if(c==chr && x >= a1 && x <= a2)print}' chr=6 a1=99770000 a2=100430000 > tmp/SNPH/Histo/_h
   cat tmp/SNPH/Histo/_h | gawk '{print}' | bin/histo -snp -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -o  tmp/SNPH/Histo/$MAGIC.zone_SNP.any.frequency_histo_per_run
   cat tmp/SNPH/Histo/_h | gawk '{if(substr($3,1,3)=="Sub")print}' | bin/histo -snp -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -o   tmp/SNPH/Histo/$MAGIC.zone_SNP.substitutions.frequency_histo_per_run
   if ($MAGIC_A2G == 1) then
     cat tmp/SNPH/Histo/_h | gawk '{if(S3=="Sub:A:G")print}' | bin/histo -snp -smooth   -colList MetaDB/$MAGIC/Run2Title.txt -o   tmp/SNPH/Histo/$MAGIC.zone_SNP.A2G.frequency_histo_per_run
     cat tmp/SNPH/Histo/_h | gawk '{if($3 == "Sub:A:G")next;if(substr($3,1,3)=="Sub")print}' | bin/histo -snp -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -o   tmp/SNPH/Histo/$MAGIC.zone_SNP.substitutions_no_A2G.frequency_histo_per_run
   endif
   cat tmp/SNPH/Histo/_h | gawk '{if(substr($3,1,3)=="Ins")print}' | bin/histo -snp -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -o   tmp/SNPH/Histo/$MAGIC.zone_SNP.insertions.frequency_histo_per_run
   cat tmp/SNPH/Histo/_h | gawk '{if(substr($3,1,3)=="Del")print}' | bin/histo -snp -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -o   tmp/SNPH/Histo/$MAGIC.zone_SNP.deletions.frequency_histo_per_run
  \cp  tmp/SNPH/Histo/$MAGIC.zone_SNP.*.frequency_histo_per_run.txt  RESULTS/SNV
else
  cat tmp/SNPH/*/$MAGIC.snp.sorted  | gawk '{print}' | bin/histo -snp -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -o   tmp/SNPH/Histo/$MAGIC.SNP.any.frequency_histo_per_run ; \cp   tmp/SNPH/Histo/$MAGIC.SNP.any.frequency_histo_per_run.txt  RESULTS/SNV
  cat tmp/SNPH/*/$MAGIC.snp.sorted  | gawk '{if(substr($3,1,3)=="Sub")print}' | bin/histo -snp -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -o   tmp/SNPH/Histo/$MAGIC.SNP.substitutions.frequency_histo_per_run ; \cp   tmp/SNPH/Histo/$MAGIC.SNP.substitutions.frequency_histo_per_run.txt  RESULTS/SNV
  if ($MAGIC_A2G == 1) then
    cat tmp/SNPH/*/$MAGIC.snp.sorted  | gawk '{if(S3=="Sub:A:G")print}' | bin/histo -snp -smooth   -colList MetaDB/$MAGIC/Run2Title.txt -o   tmp/SNPH/Histo/$MAGIC.SNP.A2G.frequency_histo_per_run ; \cp   tmp/SNPH/Histo/$MAGIC.SNP.A2G.frequency_histo_per_run.txt  RESULTS/SNV
    cat tmp/SNPH/*/$MAGIC.snp.sorted  | gawk '{if($3 == "Sub:A:G")next;if(substr($3,1,3)=="Sub")print}' | bin/histo -snp -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -o   tmp/SNPH/Histo/$MAGIC.SNP.substitutions_no_A2G.frequency_histo_per_run ; \cp   tmp/SNPH/Histo/$MAGIC.SNP.substitutions_no_A2G.frequency_histo_per_run.txt  RESULTS/SNV
  endif
  cat tmp/SNPH/*/$MAGIC.snp.sorted  | gawk '{if(substr($3,1,3)=="Ins")print}' | bin/histo -snp -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -o   tmp/SNPH/Histo/$MAGIC.SNP.insertions.frequency_histo_per_run ; \cp   tmp/SNPH/Histo/$MAGIC.SNP.insertions.frequency_histo_per_run.txt  RESULTS/SNV
  cat tmp/SNPH/*/$MAGIC.snp.sorted  | gawk '{if(substr($3,1,3)=="Del")print}' | bin/histo -snp -smooth -colList MetaDB/$MAGIC/Run2Title.txt   -o   tmp/SNPH/Histo/$MAGIC.SNP.deletions.frequency_histo_per_run ; \cp   tmp/SNPH/Histo/$MAGIC.SNP.deletions.frequency_histo_per_run.txt  RESULTS/SNV
endif # Retina

echo "phase s12: report the per run and type the quality filtered and differential SNPs in RESULTS/SNV"

foreach type (snp.sorted snp.sorted.filtered)
  set minFreq=$minSnpFrequency
  echo -n "...$type $minFreq : "
  date
  if ($type ==  snp.sorted.homozygous) set minFreq=95
  set toto=tmp/SNPH/$MAGIC.$type.txt
  set n1=`ls tmp/SNPH/*/$MAGIC.$type | wc -l`
  set fil=raw
  if ($type == snp.sorted.filtered) set fil=filtered
  if (! -e $toto && $n1 > 0) then
    set toto=RESULTS/SNV/$MAGIC.SNP_Types.cov$minSnpCover.pc$minFreq.$fil.txt
    echo -n "# File $toto " > $toto
    date >> $toto
      echo "\n# Number of candidate variants, strand compatible and differential in any run" >> $toto
      echo "# each variant was seen in at least one run at frequency $minFreq %, coverage $minSnpCover, with $minSnpCount supporting reads" >> $toto
      echo "# and selected by differential analysis in at least one comparative group." >> $toto  
      echo "# Only reads-pairs aligning uniquely over at least 90% of their length are considered." >> $toto

     cat MetaDB/$MAGIC/RunListSorted  MetaDB/$MAGIC/GroupSnpAdditiveList ZZZZZ  MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/SNPH/*/$MAGIC.$type | gawk -F '\t' -f scripts/snpSupportStat.awk  format=snpq minMut=$minSnpCount minCover=$minSnpCover minF=$minSnpFrequency >> $toto
  endif
  # bin/rsync -ah  $toto RESULTS/SNV   toto is already in this dir
end


set toto=RESULTS/SNV/$MAGIC.snp.sorted.filtered.VariantFrequency.histo.txt
echo -n "# File $toto " > $toto
date >> $toto
echo "# Histogram of the observed SNP frequency in project $MAGIC, by genotype category, homozygote reference or variant, heterozygote or intermediate, possibly corresponding to gene duplication or non diploid content" >> $toto
cat tmp/SNPH/*/$MAGIC.snp.sorted.filtered | gawk -F '\t' '/^#/{next;}{t=10*$7;if(t!=10*int(t/10))t+=30;if(t<10)t="0" t; d=.5;if($8<30)d=.2;if($8>70)d=.8;f=int($8 + d);if(substr($3,2,1)!=">"){t1= "H" t; tt[t1]=1;nnn[t1]++;nn[t1,f]++;}else {t1= "B" t; tt[t1]=1;nnn[t1]++;nn[t1,f]++;} {t1= "A" t; tt[t1]=1;nnn[t1]++;nn[t1,f]++;}}END{for (t in tt){for(i=-2;i<=102;i++)nns[t,i]=(nn[t,i-2]+4*nn[t,i-1]+6*nn[t,i]+4*nn[t,i+1]+nn[t,i+2])/16;nns[t,0]+=nns[t,-1]+nns[t,-2];nns[t,100]+=nns[t,101]+nns[t,102];}ttt["A00"]="+/+";ttt["A33"]="~m/+/+";ttt["A35"]="+ or m/+";ttt["A10"]="m/+";ttt["A45"]="+ or m/m";ttt["A47"]="~m/m/+";ttt["A20"]="m/m";ttt["B00"]="Subst +/+";ttt["B33"]="Subst ~m/+/+";ttt["B35"]="Subst + or m/+";ttt["B10"]="Subst m/+";ttt["B45"]="Subst + or m/m";ttt["B47"]="Subst ~m/m/+";ttt["B20"]="Subst m/m";ttt["H00"]="InDel +/+";ttt["H33"]="InDel ~m/+/+";ttt["H35"]="InDel + or m/+";ttt["H10"]="InDel m/+";ttt["H45"]="InDel + or m/m";ttt["H47"]="InDel ~m/m/+";ttt["H20"]="InDel m/m";printf("\n0Type");for(t in tt)printf("\t%s",t);printf("\n0Observed frequency of the variant allele in SNPs");for(t in tt)printf("\t%s",ttt[t]);for(i=0;i<=100;i++){printf("\n%d",i);for (t in tt)printf("\t%d",nns[t,i]);}printf("\nTotal");for (t in tt)printf("\t%d",nnn[t]);printf("\n");}' > $toto.1
cat $toto.1 | scripts/transpose | $tab_sort -k 1n | scripts/transpose >> $toto
\rm $toto.1

set toto=RESULTS/SNV/$MAGIC.snp.sorted.VariantFrequency.histo.txt
echo -n "# File $toto  " > $toto
date >> $toto
echo "# Histogram of the observed SNP frequency in project $MAGIC, by genotype category, homozygote reference or variant, heterozygote or intermediate, possibly corresponding to gene duplication or non diploid content" >> $toto
cat tmp/SNPH/*/$MAGIC.snp.sorted | gawk -F '\t' '/^#/{next;}{t=10*$7;if(t!=10*int(t/10))t+=30;if(t<10)t="0" t; d=.5;if($8<30)d=.2;if($8>70)d=.8;f=int($8 + d);if(substr($3,2,1)!=">"){t1= "H" t; tt[t1]=1;nnn[t1]++;nn[t1,f]++;}else {t1= "B" t; tt[t1]=1;nnn[t1]++;nn[t1,f]++;} {t1= "A" t; tt[t1]=1;nnn[t1]++;nn[t1,f]++;}}END{for (t in tt){for(i=-2;i<=102;i++)nns[t,i]=(nn[t,i-2]+4*nn[t,i-1]+6*nn[t,i]+4*nn[t,i+1]+nn[t,i+2])/16;nns[t,0]+=nns[t,-1]+nns[t,-2];nns[t,100]+=nns[t,101]+nns[t,102];}ttt["A00"]="+/+";ttt["A33"]="~m/+/+";ttt["A35"]="+ or m/+";ttt["A10"]="m/+";ttt["A45"]="+ or m/m";ttt["A47"]="~m/m/+";ttt["A20"]="m/m";ttt["B00"]="Subst +/+";ttt["B33"]="Subst ~m/+/+";ttt["B35"]="Subst + or m/+";ttt["B10"]="Subst m/+";ttt["B45"]="Subst + or m/m";ttt["B47"]="Subst ~m/m/+";ttt["B20"]="Subst m/m";ttt["H00"]="InDel +/+";ttt["H33"]="InDel ~m/+/+";ttt["H35"]="InDel + or m/+";ttt["H10"]="InDel m/+";ttt["H45"]="InDel + or m/m";ttt["H47"]="InDel intermidiate high";ttt["H20"]="InDel m/m";printf("\n0Type");for(t in tt)printf("\t%s",t);printf("\n0Observed frequency of the variant allele in SNPs");for(t in tt)printf("\t%s",ttt[t]);for(i=0;i<=100;i++){printf("\n%d",i);for (t in tt)printf("\t%d",nns[t,i]);}printf("\nTotal");for (t in tt)printf("\t%d",nnn[t]);printf("\n");}' > $toto.1
cat $toto.1 | scripts/transpose | $tab_sort -k 1n | scripts/transpose >> $toto
\rm $toto.1

goto phaseLoop


###############################################################################################
## s13: Export the SNP differential between runs

phases13: 

echo "phase s13: Export the SNP differential between runs using the tag : run->compare_snp"

if (! -d tmp/SNPH) goto phaseLoop
if (! -d RESULTS/SNV) mkdir RESULTS/SNV
set n=`cat MetaDB/$MAGIC/RunsList  MetaDB/$MAGIC/GroupSnpAdditiveList  | wc | gawk '{print $1}'`
if ($n < 1) then
  echo "No run or group in this project has the tag SNP,  phase s13 cannot proceed"
  goto phaseLoop
endif

touch tmp/SNPH/_s13
cat MetaDB/$MAGIC/runs.ace | gawk '{gsub(/\"/,"",$0);}/^Run/{r1=$2;}/^Compare_SNP/{r2=$2;printf("%s:%s\n",r1,r2);}' > tmp/SNPH/_s13
set n=`cat tmp/SNPH/_s13 | wc -l`
if ($n == 0) then
  echo "To make class predictions using SNPs, please add the tag Compare_SNP to some runs of project $MAGIC"
  goto phaseLoop
endif
cat  tmp/SNPH/_s13

scripts/geneindex.tcsh snp4 000
cat  MetaDB/$MAGIC/RunListSorted  MetaDB/$MAGIC/GroupAdditiveList | sed -e 's/\"//g' >   tmp/SNPH/s13.runs_groupsList
foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
  if (-e tmp/SNPH/$zone/$MAGIC.snp.sorted.filtered && ! -e tmp/SNPH/$zone/$MAGIC.snpCompare3) then
    echo " bin/geneindex -deepSNP tmp/SNPH/$zone/$MAGIC.snp.sorted.filtered -u -runList  tmp/SNPH/s13.runs_groupsList -runAce tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace -pA -snpCompare"
    bin/geneindex -deepSNP tmp/SNPH/$zone/$MAGIC.snp.sorted.filtered -u -runList  tmp/SNPH/s13.runs_groupsList -runAce tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace -pA -snpCompare >   tmp/SNPH/$zone/$MAGIC.snpCompare
  endif
end
  
echo "phase s13 done"
goto phaseLoop

# hand test somatic snps
# cat ~/NBE/tmp/SNPH/*/NBE.snp.sorted.filtered.filtered | gawk '{if($6=="Ghs3987"&& $7==1)g1[$1 $2 $3]=2;if($6=="Ghs3988" && $7==1 && g1[$1 $2 $3]==1)print}' | head

###############################################################################################
## s14: Prediction analysis via selected SNPs

phases14: 
phasesnp4:
echo "phase s14: Prediction using the SNPs"


touch tmp/SNPH/_s13
cat MetaDB/$MAGIC/compares.ace | gawk '{gsub(/\"/,"",$0);}/^Compare/{r1=$2;}/^SNP/{printf("%s\n",r1);}' > tmp/SNPH/_s13
set n=`cat tmp/SNPH/_s13 | wc -l`
if (0 && $n == 0) then
  echo "To make class predictions using SNPs, please add the tag Compare_SNP to some runs of project $MAGIC"
  goto phaseLoop
endif
#cat  tmp/SNPH/_s13

scripts/geneindex.tcsh snp4 

echo "phase s14 done"
goto phaseLoop

###############################################################################################
## s20: Collect and Translate the SNPs

phases20: 
if (! -d tmp/SNPH) goto phaseLoop

echo -n  "phase s20:  parse the SNP into tmp/SNP_DB, Translate the SNPs using snp.parse_remap : start "
date
set n=`cat MetaDB/$MAGIC/RunsList  MetaDB/$MAGIC/GroupSnpAdditiveList  | wc | gawk '{print $1}'`
if ($n < 1) then
  echo "No run or group in this project has the tag SNP,  phase s20 cannot proceed"
  goto phaseLoop
endif

#### prepare the data
if (! -d tmp/SNP_DB) mkdir tmp/SNP_DB

# grep the product qualities
if (0 && $species == hs && ! -e TARGET/MRNAS/good_product.ace ) then
  bin/tacembly ~/37lm5 <<EOF
    query find gene transcribed_gene && ! cloud_gene
    follow product very_good_product || (best_product && good_product)
    show -a -f TARGET/MRNAS/good_product.ace best_product
    show -a -f TARGET/MRNAS/very_good_product.ace very_good_product
    quit
EOF
endif

# retrofit the mRNA class name into the mRNA fasta file
foreach target ( mito SpikeIn $Etargets $Ttargets)
  if (-e TARGET/Targets/$species.$target.fasta.gz && ! -e tmp/SNP_DB/$species.$target.mrna.fasta.gz) then
    gunzip -c TARGET/Targets/$species.$target.fasta.gz | gawk '/^>/{i=index($1,"|");if(i>0)s=substr($1,2,i-2);else s=substr($1,2);printf(">mRNA:%s\n",s);next;}{print}' | gzip >  tmp/SNP_DB/$species.$target.mrna.fasta.gz
  endif
end
# grab the CDS location, should be done from the GTF file in metaData
if (-e TARGET/MRNAS/RefSeqStructure.txt  && ! -e tmp/SNP_DB/RefSeq.cds.ace.gz) then
  cat TARGET/MRNAS/RefSeqStructure.txt  | gawk -F '\t' '{gsub(/\"/,"",$0);m=$1;if(m!=old){if(x2>x1)printf("mRNA %s\nCDS %d %d\n\n", old, x1,x2);x1 = 1; x2 = 1 ; }old=m ;}/UTR_5prime/{x1 += $6-$5+1;x2=x1;next;}/Exon/{x2 += $6-$5+1;next;}END{if(x2>x1)printf("mRNA %s\nCDS %d %d\n\n", old, x1,x2);}' | gzip > tmp/SNP_DB/RefSeq.cds.ace.gz
endif

# grab the geometry of the mRNAs (exon/intron structure and IntMap)
if (-e TARGET/MRNAS/mrnaStructure.txt && ! -e  TARGET/MRNAS/mrnaStructure.ace) then
  cat TARGET/MRNAS/mrnaStructure.txt | gawk -F '\t' '{if ($1 != old){old=$1;printf ("\nmRNA %s\nGene %s\nIntMap %s %s %s\n",$1,$12,$2,$3,$4);}printf ("Splicing %s %s %s %s %s  %s\n",$5,$6,$7,$8,$9,$10);}END{printf("\n");}' >   TARGET/MRNAS/mrnaStructure.ace
  cat TARGET/MRNAS/mrnaStructureCDS.txt | cut -f 1,2,10,11 | $tab_sort -u | gawk '{printf("mRNA %s\nProduct %s %s %s\n\n",$1,$2,$3,$4);}' >>  TARGET/MRNAS/mrnaStructure.ace
endif

### actual work

foreach zone ( `cat tmp/SNP_ZONE/ZoneList` )
  # echo "aa: $zone "
  if (! -e tmp/SNPH/$zone/$MAGIC.snp.sorted) continue
  echo "bb: $zone "
  if (! -d tmp/SNP_DB/$zone) mkdir  tmp/SNP_DB/$zone
    echo "cc: $zone "
    scripts/submit tmp/SNP_DB/$zone/parse "scripts/snp.parse_remap.tcsh $Strategy $zone" 
  if (  -e tmp/SNP_DB/$zone/dim_dup.done) \rm tmp/SNP_DB/$zone/dim_dup.done
end
foreach zone ( `cat tmp/SNP_ZONE/ZoneList` )
  echo "bb: $zone "
  if ( -d tmp/SNP_DB/$zone && -d tmp/SNP_DB/$zone/database && ! -e tmp/SNP_DB/$zone/dim_dup.done) then
    bin/tacembly tmp/SNP_DB/$zone << EOF
      query find Variant dima OR dimt OR dimC OR dimg OR dupa OR dupt OR dupC OR dupG
      edit in_repeat
      save
      quit
EOF

  touch tmp/SNP_DB/$zone/dim_dup.done
  endif
end


if (-d tmp/Transloc) then
  echo '// ' > tmp/Transloc/$MAGIC.transloc.txt
  foreach run (`cat MetaDB/$MAGIC/RunsList MetaDB/$MAGIC/GroupAdditiveList`)
    # cat tmp/Transloc/$run.transloc.txt   >> tmp/Transloc/$MAGIC.transloc.txt   
  end
endif

echo "phase s20 done"
goto phaseLoop

###############################################################################################
## s21 : report the SNPs

phases21: 
if (! -d tmp/SNPH) goto phaseLoop
if (! -d RESULTS/SNV) mkdir RESULTS/SNV

echo -n  "phase s21:  Report the SNP into RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt\t"
date

set toto=RESULTS/SNV/$MAGIC.SNPs_per_gene.txt
echo -n "## $toto : " > $toto
date >> $toto
echo "## For each gene, we count all SNPs affecting this gene and report the number of observations as wild-type, low, mid, high, pure and the number of samples with at least 0 to 10 doses of any of these SNPs" >> $toto
cat tmp/SNP_DB/zone*/$MAGIC.snp_prevalence_per_gene.txt | head -2 >> $toto
cat tmp/SNP_DB/zone*/$MAGIC.snp_prevalence_per_gene.txt | gawk '/^#/{next;}{print}' | scripts/tab_sort -k  18,18nr -k 17,17nr >> $toto

set toto=RESULTS/SNV/$MAGIC.differential_SNPs_per_gene.txt
echo -n "## $toto : " > $toto
date >> $toto
echo "## For each gene, we count all SNPs affecting this gene and report the number of observations as wild-type, low, mid, high, pure and the number of samples with at least 0 to 10 doses of any of these SNPs" >> $toto
cat tmp/SNP_DB/zone*/$MAGIC.differential.snp_prevalence_per_gene.txt | head -2 >> $toto
cat tmp/SNP_DB/zone*/$MAGIC.differential.snp_prevalence_per_gene.txt | gawk '/^#/{next;}{print}' |  $tab_sort -k 18,18nr -k 17,17nr >> $toto


set toto=RESULTS/SNV/$MAGIC.chi2_distrb.txt
echo -n "## $toto : " > $toto
date >> $toto
echo "## For each SNP, the sum of all reads across the whole project supporting the variant or the reference, read in sense or antisense, are cumulated, and the corresponding 1 degree of freedom chi-square is reported" >> $toto
echo "## 95% of the cases should have chi^2 < 1.96, 99.9% should be below 2.96; but we usually observe 10% cases with chi^2 >= 100, and 20% with chi^2 >= 10" >> $toto
echo "# x\tNumber of SNPs with chi2 < n\tNumber of SNPs with chi2 < n/10" >> $toto
cat tmp/SNP_DB/zoner.*/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{if(chi2==0){for(i=1;i<=NF;i++)if($i=="chi2")chi2=i;}next}{if($chi2<0)next;for(i=0;i<200;i+=10){if($chi2<i)n[i]++;if($chi2<i/10)n2[i]++;}}END{for(i=0;i<200;i+=10)printf("%d\t%d\t%d\n",i,n[i],n2[i]);}' >> $toto



cat  tmp/SNP_DB/*/$MAGIC.differential_snp2gene.Gained.list >  tmp/SNP_DB/$MAGIC.differential_snp2gene.Gained.list2
cat  tmp/SNP_DB/*/$MAGIC.differential_snp2gene.Up.list >  tmp/SNP_DB/$MAGIC.differential_snp2gene.Up.list2
cat  tmp/SNP_DB/*/$MAGIC.differential_snp2gene.Down.list >  tmp/SNP_DB/$MAGIC.differential_snp2gene.Down.list2
cat  tmp/SNP_DB/*/$MAGIC.differential_snp2gene.Lost.list >  tmp/SNP_DB/$MAGIC.differential_snp2gene.Lost.list2


# construct the global table and evaluate the statistics
if (1) then
  #  ($MAGIC $MAGIC.differential)
  foreach MAGICdiff ($MAGIC)
    set toto=RESULTS/SNV/$MAGICdiff.snp_list_with_allele_frequency_per_sample.txt
    set totoC=RESULTS/SNV/$MAGICdiff.snp_list_with_allele_counts_per_sample.txt
    echo -n "## $toto : " > $toto
    date >> $toto
    echo -n "## $totoC : " > $totoC
    date >> $totoC
    set n=0
    echo > $toto.2 
    echo > $toto.5
    echo > $totoC.5
    set noDrop=1
    foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
      if (! -e tmp/SNP_DB/$zone/$MAGICdiff.snp_list_with_allele_frequency_per_sample.txt) continue
      if ($n == 0) then
        cat tmp/SNP_DB/$zone/$MAGICdiff.snp_list_with_allele_frequency_per_sample.txt | head -5 | gawk '/^# /{printf("#\t");print;}' > $toto.1
        set n=1
      endif
      cat tmp/SNP_DB/$zone/$MAGICdiff.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^# /{next;}/^##/{if(NF > 5)print}'    >> $toto.2
      cat tmp/SNP_DB/$zone/$MAGICdiff.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{next;}{if(NF > 5 && $2 > 0 && $1 != "" && $19 != "" && (noDrop==1||substr($23,1,1)!="+"))print}' noDrop=$noDrop | scripts/tab_sort -V -k 1,1 -k 2,2   >> $toto.5
      cat tmp/SNP_DB/$zone/$MAGICdiff.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{next;}{if(NF > 5 && $2 > 0 && $1 != "" && $19 != "" && (noDrop==0&&substr($23,1,1)=="+"))print}' noDrop=$noDrop | scripts/tab_sort  -V -k 1,1 -k 2,2   >> $toto.5b
      cat tmp/SNP_DB/$zone/$MAGICdiff.snp_list_with_allele_counts_per_sample.txt | gawk -F '\t' '/^#/{next;}{if(NF > 5 && $2 > 0 && $1 != "" && $19 != "" && (noDrop==1||substr($23,1,1)!="+"))print}' noDrop=$noDrop | scripts/tab_sort  -V -k 1,1 -k 2,2   >> $totoC.5
      cat tmp/SNP_DB/$zone/$MAGICdiff.snp_list_with_allele_counts_per_sample.txt | gawk -F '\t' '/^#/{next;}{if(NF > 5 && $2 > 0 && $1 != "" && $19 != "" && (noDrop==0&&substr($23,1,1)=="+"))print}' noDrop=$noDrop| scripts/tab_sort  -V -k 1,1 -k 2,2  >> $totoC.5b
    end

    cat $toto.2 | head -4 | gawk '{printf("##\t");print;}' > $toto.3
    cat $toto.2 | tail -n +5 | gawk -F '\t' '/^##/{t=$34;if(substr(t,1,1)=="%")next ; if(t == "Sample" || t == "Title" || t == "Sorting title")next;i=t2i[t];if(i<1){n++;t2i[t]=n;i2t[n]=t;i=n;}for(j=34;j<=NF;j++)z[i,j]+=$j;nf=NF;}END{for(i=1;i<=n;i++){printf("\n##\t##");for(j=1;j<=31;j++)printf("\t");printf("\t%s",i2t[i]);for(j=34;j<=nf;j++)printf("\t%d",z[i,j]);}for(i=1;i<=n;i++){printf("\n##\t##");for(j=1;j<=31;j++)printf("\t");printf("\t%% %s",i2t[i]);for(j=34;j<=nf;j++){if(i==1 || i==2)z0=z[1,34];else if (i<5)z0=z[1,j];else z0=z[4,j];if(z0<=0)z0=1;printf("\t%.2f",100.0*z[i,j]/z0);}}printf("\n");}' > $toto.4

    cat $toto.1 >> $toto
    cat $toto.3 >> $toto
    cat $toto.4 >> $toto
    cat $toto.1 >> $totoC
    cat $toto.3 >> $totoC
    cat $toto.4 >> $totoC
    cat $toto.1 >> $toto
    cat $toto.1 >> $totoC
    cat $toto.5 | scripts/tab_sort -V -k 1,1  -k 2,2n  -k 3,3 | gawk '{if($4) { n++; printf("%d\t", n);print;}}' > $toto.6
    cat $toto.6 >> $toto
    cat $totoC.5 | scripts/tab_sort -V -k 1,1  -k 2,2n  -k 3,3 | gawk '{if($4) { n++; printf("%d\t", n);print;}}' > $totoC.6
    cat $totoC.6 >> $totoC
    cat $toto.1 > $toto.b
    cat $toto.3 >> $toto.b
    cat $toto.4 >> $toto.b
    cat $toto.1 > $totoC.b
    cat $toto.3 >> $totoC.b
    cat $toto.4 >> $totoC.b
    cat $toto.5b | scripts/tab_sort -V -k 1,1  -k 2,2n  -k 3,3 | gawk '{if($4) { n++; printf("%d\t", n);print;}}' > $toto.6b
    cat $toto.6b >> $toto.b
    cat $totoC.5b | scripts/tab_sort -V -k 1,1  -k 2,2n  -k 3,3 | gawk '{if($4) { n++; printf("%d\t", n);print;}}' > $totoC.6b
    cat $totoC.6b >> $totoC.b
    
    if ($MAGICdiff == $MAGIC) then
      cat $toto.1 $toto.4 | gawk -F '\t' '{printf("%s",$34);for (i=36;i<=NF;i++)printf("\t%s",$i);printf("\n");}' > $toto.preace

     cat $toto.preace | gawk -F '\t' -f scripts/s21.snp2ace.awk > tmp/SNP_DB/$MAGIC.s21.stats.ace
      echo "pparse tmp/SNP_DB/$MAGIC.s21.stats.ace" | bin/tacembly MetaDB -noprompt
     \rm  $toto.preace
    endif
  end
endif


cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | head -100 |  gawk -F '\t' '/^#/{print;}' | scripts/transpose | gawk -F '\t' '{k++;if(k==1)print $1;else if (k>2&&$7 != "") print;}'  | scripts/transpose  > RESULTS/SNV/$MAGIC.snp_stats_per_run.txt
echo "\n\n\n\n" >> RESULTS/SNV/$MAGIC.snp_stats_per_run.txt
cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | head -100 |  gawk -F '\t' '/^#/{print;}' | scripts/transpose | gawk -F '\t' '{k++;if(k==1)print $1;else if (k>2&&$7 != "") print;}' >> RESULTS/SNV/$MAGIC.snp_stats_per_run.txt


cat ZZZZZ RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt ZZZZZ RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt.b | gawk -F '\t' -f scripts/s21.snp_profile.awk magic=$MAGIC | scripts/tab_sort -V -k 1,1 -k 2,2nr  >  RESULTS/SNV/$MAGIC.snp_profile.preace
cat RESULTS/SNV/$MAGIC.snp_profile.preace | gawk -F '\t' '{if($1 != old){printf("\nAli %s\n-D SNP_profile\n",$1);old=$1;}if($2+$4 >0)printf("SNP_profile any %s %s %s\n",$3,$2, $4);}END{printf("\n");}' > RESULTS/SNV/$MAGIC.snp_profile.ace

echo "... pparse RESULTS/SNV/$MAGIC.snp_profile.ace"
echo "pparse RESULTS/SNV/$MAGIC.snp_profile.ace" | bin/tacembly MetaDB -noprompt
\rm   RESULTS/SNV/$MAGIC.snp_profile.preace RESULTS/SNV/$MAGIC.snp_profile.ace 
\rm   RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt.b
\rm   RESULTS/SNV/$MAGIC.snp_list_with_allele_counts_per_sample.txt.b

########## SNPs over 80 and over 98
  \rm RESULTS/SNV/$MAGIC.snp_over_*_in_cohort.*


set toto=RESULTS/SNV/$MAGIC.snp_over_80_in_cohort.frequency.txt
echo -n "### $toto : " > $toto
date >> $toto
  cat  RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | head -100 |  gawk -F '\t' '/^#/{print;if(col==0){for(i=1;i<=NF;i++)if($i=="Maximal allele frequency in any run")col=i;}next;}' >> $toto
 cat  RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{if(col==0){for(i=1;i<=NF;i++)if($i=="Maximal allele frequency in any run")col=i;}next;}{if($col>80)print}' | sort -V -k 2,2 -k 3,3 >> $toto

set toto=RESULTS/SNV/$MAGIC.snp_over_98_in_cohort.frequency.txt
echo -n "### $toto : " > $toto
date >> $toto
  cat  RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | head -100 |  gawk -F '\t' '/^#/{print;if(col==0){for(i=1;i<=NF;i++)if($i=="Maximal allele frequency in any run")col=i;}next;}' >> $toto
 cat  RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{if(col==0){for(i=1;i<=NF;i++)if($i=="Maximal allele frequency in any run")col=i;}next;}{if($col>98)print}' | sort -V -k 2,2 -k 3,3 >> $toto

set toto=RESULTS/SNV/$MAGIC.snp_over_80_in_cohort.counts.txt
echo -n "### $toto : " > $toto
date >> $toto
  cat  RESULTS/SNV/$MAGIC.snp_list_with_allele_counts_per_sample.txt | head -100 |  gawk -F '\t' '/^#/{print;if(col==0){for(i=1;i<=NF;i++)if($i=="Maximal allele frequency in any run")col=i;}next;}' >> $toto
 cat  RESULTS/SNV/$MAGIC.snp_list_with_allele_counts_per_sample.txt | gawk -F '\t' '/^#/{if(col==0){for(i=1;i<=NF;i++)if($i=="Maximal allele frequency in any run")col=i;}next;}{if($col>80)print}' | sort -V -k 2,2 -k 3,3 | sed -e 's/0\/0/-10/g' >> $toto

set toto=RESULTS/SNV/$MAGIC.snp_over_98_in_cohort.counts.txt
echo -n "### $toto : " > $toto
date >> $toto
  cat  RESULTS/SNV/$MAGIC.snp_list_with_allele_counts_per_sample.txt | head -100 |  gawk -F '\t' '/^#/{print;if(col==0){for(i=1;i<=NF;i++)if($i=="Maximal allele frequency in any run")col=i;}next;}' >> $toto
 cat  RESULTS/SNV/$MAGIC.snp_list_with_allele_counts_per_sample.txt | gawk -F '\t' '/^#/{if(col==0){for(i=1;i<=NF;i++)if($i=="Maximal allele frequency in any run")col=i;}next;}{if($col>98)print}' | sort -V -k 2,2 -k 3,3  | sed -e 's/0\/0/-10/g' >> $toto
###########

## histogram de la frequence observee des sSNPs par run, 
if (0) then
  #create an external file for qc summary
  cat  RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' -f scripts/s21.snpFrequencyPerRun.awk > tmp/SNP_DB/s21.snpFrequencyPerRun.txt
  #export
  bin/qcsummary -db MetaDB -project $MAGIC -export TE -externalFiles  snp_frequency:tmp/SNP_DB/s21.snpFrequencyPerRun.txt > RESULTS/SNV/$MAGIC.snpFrequencyPerRun.txt
endif


set PART=SNP_LISTS_per_sample_per_chrom
if (! -d RESULTS/SNV/$PART) mkdir RESULTS/SNV/$PART
\rm RESULTS/SNV/snp_list_with_allele_%s_per_sample.*chrom.*.part*.txt
\rm RESULTS/SNV/$PART/snp_list_with_allele_%s_per_sample.*chrom.*.part*.txt

# good bad
foreach bb (good)
  foreach MAGICdiff ($MAGIC)
  end
  
  if ($bb == good) then
    set toto=RESULTS/SNV/$MAGICdiff.snp_list_with_allele_frequency_per_sample.txt
    \rm $toto.Z.*
    cat $toto.6 |  gawk -F '\t' '{split($2,aa,"|");print >> toto".Z."aa[1]}' toto=$toto
    mv $toto.Z.' ' $toto.Z.xxx
    set totoC=RESULTS/SNV/$MAGICdiff.snp_list_with_allele_counts_per_sample.txt
    \rm $totoC.Z.*
    cat $totoC.6 |  gawk -F '\t' '{split($2,aa,"|");print >> toto".Z."aa[1]}' toto=$totoC
    mv $totoC.Z.' ' $totoC.Z.xxx
  else
    set toto=RESULTS/SNV/$MAGICdiff.snp_list_with_allele_frequency_per_sample.txt
    \rm $toto.rejected.Z.*
    cat $toto.6b |  gawk -F '\t' '{split($2,aa,"|");print >> toto".Z."aa[1]}' toto=$toto.rejected
    mv $toto.rejected.Z.' ' $toto.rejected.Z.xxx
    set totoC=RESULTS/SNV/$MAGICdiff.snp_list_with_allele_counts_per_sample.txt
    \rm $totoC.rejected.Z.*
    cat $totoC.6b |  gawk -F '\t' '{split($2,aa,"|");print >> toto".Z."aa[1]}' toto=$totoC.rejected
    mv $totoC.rejected.Z.' ' $totoC.rejected.Z.xxx
  endif

  foreach chrom (xxx $chromSetAll)
    # if ($chrom != 22) continue
    if ($bb == good) then
      set totoA=$toto.Z.$chrom
      set totoCA=$totoC.Z.$chrom
    else
      set totoA=$toto.rejected.Z.$chrom
      set totoCA=$totoC.rejected.Z.$chrom
    endif
    if ( ! -e $totoA) continue
    set m=`wc $totoA | gawk '{print $1;}'`
    set n=`echo $m | gawk '{n= int($1/60000); j=$1 % 10000 ; if (n == 0 || j > 30000) n++ ; k= int(1+$1/n); print n ;}'`
    set k=`echo $m | gawk '{n= int($1/60000); j=$1 % 10000 ; if (n == 0 || j > 30000) n++ ; k= int(1+$1/n); print k;}'`
    
      foreach i (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)
        set debut=`echo "$i $k"  | gawk '{print ($1-1)*$2;}'`
        if ($debut < $m) then
          if ($bb == good) then
            set toto1=RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.chrom.$chrom.part$i.txt
            set totoC1=RESULTS/SNV/$MAGIC.snp_list_with_allele_counts_per_sample.chrom.$chrom.part$i.txt
          else
            set toto1=RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.rejected.chrom.$chrom.part$i.txt
            set totoC1=RESULTS/SNV/$MAGIC.snp_list_with_allele_counts_per_sample.rejected.chrom.$chrom.part$i.txt
          endif
          echo "## $toto1 : start line $debut length $k" 
          cat $toto.1  > $toto1
          echo -n "## $toto1 : start line $debut length $k" >> $toto1
          date >>  $toto1
          cat $toto.3  >> $toto1
          cat $toto.4  >> $toto1
          echo >> $toto1
          cat $toto.1  >> $toto1
          cat $totoA  | tail -n +$debut | gawk '/^#/{next;}{print}' | head -$k >> $toto1
          cat $toto.1  > $totoC1
          echo -n "## $totoC1 : start line $debut length $k" >> $totoC1
          date >>  $totoC1
          cat $toto.3  >> $totoC1
          cat $toto.4  >> $totoC1
          echo >> $totoC1
          cat $toto.1  >> $totoC1
          cat $totoCA  | tail -n +$debut | gawk '/^#/{next;}{print}' | head -$k >> $totoC1
        endif
      end

  end


end
 \rm RESULTS/SNV/*.Z.* RESULTS/SNV/*.[1-6] RESULTS/SNV/*.[5-6]b RESULTS/SNV/*.b
\mv RESULTS/SNV/*.part* RESULTS/SNV/$PART


if ($MAGIC == Retina) then
  # Retina export all SNPs corresponding to a genomic zone

  set toto=RESULTS/SNV/$MAGIC.selected_zone.snp_list_with_allele_frequency_per_sample.txt
  cat tmp/SNP_DB/*/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | head -100 | gawk '/^#/{print}' > $toto
  cat tmp/SNP_DB/*/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{next;}{m=$42;if(0 && (m==$44 || m==$45 || m==$46 || m==$47 || m==$48))next;c=$1;x=0+$2;if(c==chr && x >= a1 && x <= a2)print}' chr=6 a1=99770000 a2=100430000 >> $toto

endif

####################
####################

### export SNP counts per types in all run
### Try to identify samples from same individuals
# grab SNPs seen at least twice as reference and twice as homozygous an measured in 80% of the cohort

set nRuns=`cat MetaDB/$MAGIC/RunsList | wc | gawk '{print $1}'`

foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
  # echo "#########... $zone"
  if (! -d tmp/SNP_DB/$zone || -e tmp/SNP_DB/$zone/$MAGIC.characteristic_snp.txt) continue
  scripts/submit tmp/SNP_DB/$zone/s21 "scripts/s21.select_characteristic_snps.tcsh $zone $nRuns $Strategy"
end

scripts/submit wait
gunzip -c tmp/SNP_DB/*/$MAGIC.characteristic_substitutions.snp.gz > tmp/SNP_DB/$MAGIC.characteristic_substitutions.pre_snp
cat tmp/SNPH/zone*/$MAGIC.snp.sorted.homozygous | gzip > tmp/SNP_DB/$MAGIC.snp.sorted.homozygous.gz

# filter against the 'filtered' snps 
if ($Strategy != RNA_seq) then
  cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | cut -f 2,3,5 | sort -u >  tmp/SNP_DB/$MAGIC.filtered_mRNA_snps.list
  cat  tmp/SNP_DB/$MAGIC.filtered_mRNA_snps.list ZZZZZ  tmp/SNP_DB/$MAGIC.characteristic_substitutions.pre_snp | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{z=$1 ":c." $2 $3 ;}{if(zz<1){ok[z]=1;next;}}{if(ok[z]==1)print}' | gzip  > tmp/SNP_DB/$MAGIC.characteristic_substitutions.snp.gz 
else
  # 2020_02_14 j'elimine ces 2 lignes que ne marchent pas, je vois [pas a quoi elles servent
  # cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | cut -f 10 | sort -u >  tmp/SNP_DB/$MAGIC.filtered_mRNA_snps.list
  # cat  tmp/SNP_DB/$MAGIC.filtered_mRNA_snps.list ZZZZZ  tmp/SNP_DB/$MAGIC.characteristic_substitutions.pre_snp | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;next;}}{z=$1 ":c." $2 $3 ;}{if(ok[z]==1)print}' | gzip  > tmp/SNP_DB/$MAGIC.characteristic_substitutions.snp.gz 
  cat  tmp/SNP_DB/$MAGIC.characteristic_substitutions.pre_snp  | gzip  > tmp/SNP_DB/$MAGIC.characteristic_substitutions.snp.gz 
  \rm  tmp/SNP_DB/$MAGIC.characteristic_substitutions.pre_snp 
endif

## hack a who is who CORONA
if (0) then
  zcat  tmp/SNP_DB/$MAGIC.characteristic_substitutions.snp.gz | gawk '{printf("%s",$1);for(i=1;i<=NF;i++)printf("\t%s",$i);printf("\n");}' > toto
  cat toto | gawk -F '\t' '{z=$1":"$3":"$4;mm[z]=1;rr[$7]=1;n[z,$7]=$9;}END{for(m in mm){printf("\t%s",m);}for(r in rr){printf("\n%s", r);for(m in mm){printf("\t%s",n[m,r]);}}printf("\n");}' | sort -k 2,2n -k 3,3n -k 4,4n -k 5,5n -k 6,6n -k 7,7n -k 8,8n -k 9,9n -k 10,10n -k 11,11n -k 12,12n -k 13,13n -k 14,14n -k 15,15n -k 16,16n -k 17,17n -k 18,18n -k 19,19n
endif

## 2016_08_30 more stats on the big snp table
set toto=RESULTS/SNV/$MAGIC.snp.stats.txt
echo -n "## $toto : " > $toto
date >> $toto
echo -n "Total number of SNPs : "
cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk '/^#/{next;}{if($1)n++}END{print n}' >> $toto
echo "SNV/Chromosomes" >> $toto
cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | cut -f 2 | gawk -F '\t' '/^#/{next;}{z=$1;if(substr(z,1,3)=="chr")z=substr(z,4);if(z=="")next;if(z+0>0)printf("chr%02d\n",z);else printf("chr%s\n",z);}' | tags | sort  | sed -e 's/chr0/chr/' | gawk '/^#/{next;}{if(length($1)>0)print}' >> $toto
echo "SNV type" >> $toto
cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | cut -f 13 | tags | sort >> $toto
echo "snv type\ton plus strand of the genome\ton plus strand of transcript\tsliding"  >> $toto
cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{next}{a=$5;b=$14;if(substr(b,1,1)=="*"){b=substr(b,2);tc[b]++;}else tb[b]++; t[a]=1;t[b]=1;ta[a]++;}END{for(k in t)printf("%s\t%d\t%d\t%d\n",k,ta[k],tb[k],tc[k]);}' | sort  | gawk '/^#/{next;}{if(length($1)>0)print}' > $toto.1 
cat $toto.1 | grep 'A>G'  >> $toto
cat $toto.1 | grep 'T>C'  >> $toto 
cat $toto.1 | grep 'G>A'  >> $toto
cat $toto.1 | grep 'C>T'  >> $toto
cat $toto.1 | grep 'A>T'  >> $toto
cat $toto.1 | grep 'T>A'  >> $toto
cat $toto.1 | grep 'G>C'  >> $toto
cat $toto.1 | grep 'C>G'  >> $toto
cat $toto.1 | grep 'A>C'  >> $toto
cat $toto.1 | grep 'T>G'  >> $toto
cat $toto.1 | grep 'G>T'  >> $toto
cat $toto.1 | grep 'C>A'  >> $toto

cat $toto.1 | grep 'DelA' | sort >> $toto
cat $toto.1 | grep 'DelT' | sort >> $toto
cat $toto.1 | grep 'DelG' | sort >> $toto
cat $toto.1 | grep 'DelC' | sort >> $toto
cat $toto.1 | grep 'InsA' | sort >> $toto
cat $toto.1 | grep 'InsT' | sort >> $toto
cat $toto.1 | grep 'InsG' | sort >> $toto
cat $toto.1 | grep 'InsC' | sort >> $toto
\rm $toto.1

echo -n "number of affected genes " >> $toto
cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{next;}{gg[$8]++;if(gg[$8]==1)n++;}END{print n}' >> $toto


echo "protein changing snv type\ton plus strand of the genome\ton plus strand of transcript\tsliding"  >> $toto
cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '{split($13,aa," ");t=aa[1];if(index("AA_subAA_to_StopFrame_preserving_indelFrameshiftMet1_gainedMet1_lostStop_to_AA",t)<1)next;a=$5;b=$11;if(substr(b,1,1)=="*"){b=substr(b,2);tc[b]++;}else tb[b]++; tt[a]=1;tt[b]=1;ta[a]++;}END{for(k in tt)printf("%s\t%d\t%d\t%d\n",k,ta[k],tb[k],tc[k]);}' | sort  | gawk '/^#/{next;}{if(length($1)>0)print}' > $toto.1 

cat $toto.1 | grep 'A>G'  >> $toto
cat $toto.1 | grep 'T>C'  >> $toto 
cat $toto.1 | grep 'G>A'  >> $toto
cat $toto.1 | grep 'C>T'  >> $toto
cat $toto.1 | grep 'A>T'  >> $toto
cat $toto.1 | grep 'T>A'  >> $toto
cat $toto.1 | grep 'G>C'  >> $toto
cat $toto.1 | grep 'C>G'  >> $toto
cat $toto.1 | grep 'A>C'  >> $toto
cat $toto.1 | grep 'T>G'  >> $toto
cat $toto.1 | grep 'G>T'  >> $toto
cat $toto.1 | grep 'C>A'  >> $toto

cat $toto.1 | grep 'DelA' | sort >> $toto
cat $toto.1 | grep 'DelT' | sort >> $toto
cat $toto.1 | grep 'DelG' | sort >> $toto
cat $toto.1 | grep 'DelC' | sort >> $toto
cat $toto.1 | grep 'InsA' | sort >> $toto
cat $toto.1 | grep 'InsT' | sort >> $toto
cat $toto.1 | grep 'InsG' | sort >> $toto
cat $toto.1 | grep 'InsC' | sort >> $toto
\rm $toto.1

##
set n=`cat MetaDB/$MAGIC/ccc_pair.list | wc -l`
if ($n == 0) then
    \rm RESULTS/SNV/$MAGIC.*differential**
    \rm RESULTS/Expression/*/$MAGIC.*DEG*
    \rm RESULTS/Expression/*/$MAGIC.*differential*
endif

# histogram of observed SNP frequencies
set toto=RESULTS/SNV/$MAGIC.substitutions.raw_frequency_histo.txt
echo -n "## $toto : " > $toto
date >> $toto
echo "# Raw observed minor allele frequency in each run\tNumber of substitutions" >> $toto
cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{n++;if(n==2){i0=35;for(i=1;i<=NF;i++)if($i=="Maximal allele frequency in any run")i0=i+1;}next;}{if(substr($5,1,3)!="Sub")next;for(i=i0;i<=NF;i++){x=$i;if(x>=0)print .10*int(.5+x/.10);}}' | tags | sort -k 1n >> $toto

if (-e RESULTS/SNV/$MAGIC.snp.SNP.u.done) \rm RESULTS/SNV/$MAGIC.snp.SNP.u.done

echo "phase s21 done"
goto phaseLoop
3
###############################################################################################
## s22 : SNP per gene

phases22: 
if (! -d tmp/SNPH) goto phaseLoop
if (! -d RESULTS/SNV) mkdir RESULTS/SNV

if (-e RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt && ! -e tmp/GENEINDEX/$MAGIC.snp_per_gene.protein.ace) then
  cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' -f scripts/s22.snp_per_gene.awk protein=1 aceOut=1  > tmp/GENEINDEX/$MAGIC.snp_per_gene.protein.ace
endif

if (-e RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt && ! -e tmp/SNP_DB/$MAGIC.snp.selected.list) then
  cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{next;}{if(NF >3){gsub(">","2",$5);printf("Variant \"%s:%s:%s\"\n",$2,$3,$5);}}' > tmp/SNP_DB/$MAGIC.snp.selected.list 
endif

touch  tmp/SNP_DB/$MAGIC.snp.selected.list
if (-e tmp/SNP_DB/$MAGIC.snp.selected.list) then
  foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
    if (! -e  tmp/SNP_DB/$zone/all_snp.ace && -e tmp/SNP_DB/$zone/database && ! -e  tmp/SNP_DB/$zone/database/lock.wrm) then
       scripts/submit  tmp/SNP_DB/$zone/s22 "scripts/snp.parse_remap.tcsh s22 $zone"
    endif
  end
endif

if (! -d RESULTS/SNV/Rejected)   mkdir  RESULTS/SNV/Rejected
if (! -e RESULTS/SNV/Rejected/$MAGIC.rejected.done) then
  foreach chrom ($chromSetAll)
    cat RESULTS/SNV/SNP_LISTS_per_sample_per_chrom/$MAGIC.snp_list_with_allele_frequency_per_sample.rejected.chrom.$chrom.part*.txt | gawk -F '\t' '/^#/{next;}{printf ("%s\t%s\t%s\n",$2,$3,$5);}' | sort -u > RESULTS/SNV/Rejected/$MAGIC.rejected.$chrom.txt
  end
  touch RESULTS/SNV/Rejected/$MAGIC.rejected.done
endif
\rm RESULTS/SNV/*.txt.*

echo "phase s22 done"
goto phaseLoop

# 2017_08_31
# Remapping for transfer from 38 back to 37, i.e. from NicoExome back to FDA challenge
 
if (! -d RESULTS/SNV/Remapping)   mkdir  RESULTS/SNV/Remapping
foreach chrom ($chromSetAll)
  cat RESULTS/SNV/Rejected/$MAGIC.rejected.$chrom.txt | gawk -F '\t' '{gsub(">","2",$3);if ($2 > 100)printf ("%s:%s:%s\t1\t201\t%s\t%d\t%d\n",$1,$2,$3,$1,$2-100,$2+100);}' >  RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom.shadow
end
foreach chrom ($chromSetAll)
  dna2dna -i TARGET/CHROMS/$species.chrom_$chrom.fasta.gz -shadow  RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom.shadow -O fasta -o  RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom.pre
  cat RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom.pre.fasta | gawk '/^>/{print;next;}{printf("%sN%s\n",substr($1,1,100),substr($1,102));}' >  RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom.fasta 
end
foreach chrom ($chromSetAll)
  set chrom2=`echo $chrom | sed -e 's/chr//'`
  set chrom2=`echo $chrom | sed -e 's/chr//'`
  clipalign -t ~/FDA/TARGET/CHROMS/$species.chrom_$chrom2.fasta.gz -i RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom.fasta -minAli 150 -maxHit 10 -o  RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom2 -strategy Exome -best
end
# as a control map on self, all sequences shoud remap
foreach chrom ($chromSetAll)
  clipalign -t TARGET/CHROMS/$species.chrom_$chrom.fasta.gz -i RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom.fasta -minAli 150 -maxHit 10 -o  RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom -strategy Exome -best
  cat RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom | gawk '/^chr/{print $1}' | sort -u | wc | gawk "{print toto > read.$1}' 
end
# reexport the snp list in the 37 coordinates, verify that the first letter is ok
# it must match the 101 g>n
foreach chrom ($chromSetAll)
  set chrom2=`echo $chrom | sed -e 's/chr//'`
  cat RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom2.hits  | gawk -F '\t' '{if($14 != 1 || $15 > 3) next;n=split($16,aa,",");for(i=1;i<=n;i++)if (substr(aa[i],1,4)=="101:"&&substr(aa[i],6,2)==">n"){k=toupper(substr(aa[i],5,1));split($1,bb,":");typ=bb[3];if(substr(typ,1,2)==k"2" || substr(typ,1,4)=="Del"k || substr(typ,1,3)=="Ins"){split($17,aa,",");split(aa[i],cc,":");z=cc[1];gsub(">","",typ);printf("%s:%s:%s\n",$11,z,typ);}}}' > RESULTS/SNV/Remapping/$MAGIC.rejected.$chrom2.txt
end
cat RESULTS/SNV/Remapping/$MAGIC.rejected.*.txt | gawk '{printf("Variant \"%s\"\n",$1);}' >  RESULTS/SNV/Remapping/$MAGIC.rejected.list 



###############################################################################################


,ace
# merge NB_RNA_seq and NB_exome

cat RESULTS/SNV/$MAGIC.selected_zone.snp_list_with_allele_frequency_per_sample.txt ZZZZZ ~/NBE/RESULTS/SNV/NBE.selected_zone.snp_list_with_allele_frequency.txt | gawk -F '\t' '/^ZZZZZ/{zz++;nnf=nf;nti=0;}/^##/{print;next;}{isTi=0;}/^#/{nti++;isTi=1;}{nf=NF;dx=(zz+0)*nnf;if(isTi==1)z=nti "\t\t\t";else z=$1 "\t" $2 "\t" $3 "\t" $4; snp[z]=1; for(i=5;i<=NF;i++)xx[z,i+dx]=$i;nf=NF;}END{for (z in snp){printf("%s",z);for(i=5;i<=nf+nnf;i++)printf("\t%s",xx[z,i]);printf("\n");}}' | $tab_sort -k 1,1 -k 2,2n -k 4,4  >  RESULTS/SNV/$MAGIC.selected_zone.merged_snp_list_with_allele_frequency.txt

 cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{print;next;}{if($17 > 100 && ($22 + $23) * 100 > 50 * $17){z=$2 ":" $3 ":" $4 ":" $5 ":" $8; if(0 && z==old)next;old=z;print;}}' > RESULTS/SNV/$MAGIC.8000_homozygous_snp_list_with_allele_frequency_per_sample.txt

cat RESULTS/SNV/$MAGIC.snp_list_with_allele_frequency_per_sample.txt | gawk -F '\t' '/^#/{print;next;}{mes=$17;ref=$19;low=$20;mid=$21;high=$22;pure=$23; nallele = 2*pure + 1.5 * high + mid; if(mes > 100 && 100 * nallele > 50 * 2 * mes){z=$2 ":" $3 ":" $4 ":" $5 ":" $8; if(0 && z==old)next;old=z;print;}}' > RESULTS/SNV/$MAGIC.8000_homozygous_snp_list_with_allele_frequency_per_sample.txt
cat  RESULTS/SNV/$MAGIC.8000_homozygous_snp_list_with_allele_frequency_per_sample.txt | cut -f 2,3,4,5 | $tab_sort -u | wc

###############################################################################################
## s13xx: histo-analysis of the SNPs

phases13xx: 

if (! -d tmp/SNP2) mkdir tmp/SNP2
foreach zone (`cat tmp/SNP_ZONE/ZoneList`)
  if (! -e  tmp/SNPH/$zone/$MAGIC.snp.best_snps) continue
  foreach run (`cat MetaDB/$MAGIC/RunsList MetaDB/$MAGIC/groupSnpList`)
    if (! -d tmp/SNP2/$run) $mkDir SNP2 $run
    if (-e tmp/SNP2/$run/s13.$run.$zone.extend_snp) continue
    # scripts/submit tmp/SNP2/$run/s13.$zone "scripts/s13.aliextend.tcsh $run $zone"
  end  
end

echo "phase s13 done"
goto phaseLoop

###############################################################################################
## s14xxx: histo-analysis of the SNPs

phases14xxx: 

if (! -d RESULTS/SNV) mkdir RESULTS/SNV

## Report the number of supports in the selected and rejected sets

set toto=RESULTS/SNV/$MAGIC.coverage_of_observed_snps_per_chromosomes.txt
  date > $toto
  echo "$selectReject variants. The types are counted in the union of all groups in $MAGIC" >> $toto

  echo >> $toto
  echo "$selectReject variants (the selected Incompatible are later moved to rejected)"  >> $toto
  echo "\tType\tCount\tCount per variant" >> $toto

  cat   tmp/SNPH/*/AmishExome.snp.sorted | gawk '/^#/{next}{nn++;n["1\tNumber of observations"]++;n["4\tCoverage"]+=$9;n["2\tReads supporting the variants"]+=$10;n["3\tReads supporting the reference"]+=$11;n["5\t" $19]++;n["6\t" $21]++;}END{for (k in n) printf("%s\t%d\t%.2f\n", k,n[k],n[k]/nn);}' | grep -v \- | $tab_sort >> $toto

echo "phase s14 done"
goto phaseLoop

## best SNP
set toto=RESULTS/$MAGIC.coverage_of_main_SNPs.txt
echo -n # " > $toto
date >> #toto
 gunzip -c tmp/GENEINDEX/Results/$MAGIC.snp..u.reads_aligned_per_gene.txt.gz | head -20 >> $toto
echo " Coverage of the main $MAGIC SNps" >> $toto
foreach g (MYL12A.cAug10:69T2G HLA-BandHLA-C.bAug10:1388G2C HCG27.cAug10:807A2G HLA-BandHLA-C.bAug10:1611C2T HLA_.aAug10:349C2G HLA_.eAug10:1296C2T LIMD2.aAug10:384T2G HLA_.bAug10:1019C2T IL6R.aAug10:1510A2C LILRA6andLILRB3.aAug10:562C2A  HMGN2.aAug10:940G2T HBD.aAug10:224T2C SERPINA1.hAug10:609C2T HCLS1.aAug10)
  gunzip -c tmp/GENEINDEX/Results/$MAGIC.snp..u.reads_aligned_per_gene.txt.gz | grep $g >> $toto
end

cat  TSV/Main*/Main.*SQW_C_1_t1*.tsv | sed -e 's/Main\.//g' | scripts/aliqc.py --view html -o ~/MAC/Desktop/SQW


######################################################################
# Multi Venn diagram by error types by runs
# set minSnpCount=3
# set minSnpCover=5
set toto=RESULTS/SNV/$MAGIC.snp_s590_counts.txt
date > $toto
echo "Number of variant per run after de Bruijn realignment seen at frequency at least $minSnpFrequency %, coverage at least $minSnpCover, with at least $minSnpCount sequences supporting the variant" >> $toto 
cat  tmp/SNPH/s13.runs_groupsList ZZZZZ  MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/NEWHITS_snp/*/s590.multi.countEdited  | gawk -F '\t' -f scripts/snpSupportStat.awk group=$group format=txt minMut=$minSnpCount minCover=$minSnpCover minF=$minSnpFrequency >> $toto

cat tmp/NEWHITS_snp/*/s590.multi.countEdited |  gawk -F '\t' '/^#/{next}{if ($8 > 10 && $9 >= minCover && $10 >= 0) print $9,$10;}' minMut=$minSnpCount minCover=$minSnpCover minF=$minSnpFrequency | bin/histo -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -plot -o RESULTS/SNV/$MAGIC.snp_s590_plot

######################################################################
# Multi Venn diagram by error types by groups
set toto=RESULTS/SNV/$MAGIC.snp_confirmed_counts_by_group_in_selected_snp.txt
date > $toto
echo >> $toto
echo "Number of variant per group, rejecting the low monomodals, after de Bruijn realignment seen at frequency at least $minSnpFrequency %, coverage at least $minSnpCover, with at least $minSnpCount sequences supporting the variant" >> $toto 

  cat  tmp/SNPH/s13.runs_groupsList ZZZZZ  MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/KL.$MAGIC/*/*selected.txt | gawk -F '\t' -f scripts/snpSupportStat.awk format=txt minMut=$minSnpCount minCover=$minSnpCover minF=$minSnpFrequency >> $toto

# export the corresponding histo
cat tmp/KL.$MAGIC/*/selected.txt | gawk -F '\t' '/^#/{next}{if ($8 > 10 && $9 >= minCover && $10 >= 0) print $9,$10;}' minMut=$minSnpCount minCover=$minSnpCover minF=$minSnpFrequency | bin/histo -smooth -plot -o RESULTS/SNV/$MAGIC.snp_selected_by_group_plot

######################################################################
# SNV density histogram genome wide per 100kb
set toto=RESULTS/SNV/SNV.density.genome_wide.txt
date > $toto
echo "Density of selected SNV along the chromosomes, each SNV is counted once per individual where it is seen at frequency at least $minSnpFrequency %, coverage at least $minSnpCover, with at least $minSnpCount sequences supporting the variant" >> $toto
echo "Chromosome\tkb\tNUmber of SNP" >> $toto
cat tmp/KL.$MAGIC/*/selected.txt | gawk -F '\t' '/^#/{next;}{if ($2 > 0 && $8 > minF && $9 >= minCover && $10 >= minMut) printf("%d\t%s\t%d\n",0+$1,$1,$2);}'  minMut=$minSnpCount minCover=$minSnpCover minF=$minSnpFrequency |  $tab_sort -k 1,1n -k 2,2 -k 3,3n | gawk '{if($2 != old)n++;z=int($3/100000);if(z!=oldz)n++;old=$2;oldz=z;uu[n]=old "\t" 100*oldz;nn[n]++;}END{for(i=1;i<n;i++)if(uu[i])printf("%s\t%d\n",uu[i],nn[i]);}' >> $toto

scripts/submit tmp/SNPH/$chrom/snp4 "scripts/geneindex.tcsh snp4 $chrom"

###############################################################################################
## s3: prepare the edited sequence for confirmation

phases3: 
  set justMito=0
  goto phases3any
phases3m:
  set justMito=1 
  goto phases3any

phases3any:

echo "prepare the edited sequence for confirmation"


foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (-e Fastc/$run/Max_probe_length) then
    set ln=`cat Fastc/$run/Max_probe_length`
    if ($n == 0) \rm  Fastc/$run/Max_probe_length
  endif
  if (! -e Fastc/$run/Max_probe_length) then
    cat Fastc/$run/*.count  | gawk '/^Max_probe_length/{x=$2;if(n<x)n=x;}END{printf("%d\n",n);}' >  Fastc/$run/Max_probe_length
  endif
end


foreach zone (mito  SpikeIn rrna `ls tmp/SNP_ZONE/zone*.txt | sed -e 's/tmp\/SNP_ZONE\///' -e 's/\.txt//'  | $tab_sort -k 1n`)
  echo $zone

  if (! -e  tmp/SNP/$zone.edited_sequence.snp.fasta.gz) then
    scripts/submit tmp/SNP/$zone.edited_sequence "scripts/snp.export_edited_sequence.tcsh $zone $minSnpCount $minSnpCover $minSnpFrequency"
  endif

end

goto phaseLoop

#

## ERCC

set toto=toto.snp
date > $toto
echo "Intersect counts and frequecies of SNPs detected in the ERCC by BRS analysis" >> $toto
if (-e $toto.tmp) \rm $toto.tmp
foreach run (`cat MetaDB/$MAGIC/RunList`)
  set isSolid=0
  foreach run2 (`cat MetaDB/$MAGIC/RunSolidList`)
    if ($run2 == $run) set isSolid=1
  end
  gunzip -c tmp/SNP/$run/SpikeIn.detect.u.snp.gz  >> $toto.$isSolid.tmp
end

foreach isSolid (0 1)
  cat $toto.tmp | $tab_sort > $toto.sorted.tmp
  cat $toto.$isSolid.tmp | bin/snp -db MetaDB -minFrequency 90 -minCover 6 -merge -title "$MAGIC variants detected in the ERCC by BRS analysis" > $toto.merged.$isSolid.90.6
  cat $toto.$isSolid.tmp | grep ERCC-00071| bin/snp -db MetaDB -merge |  bin/snp -db MetaDB -minFrequency 10 -minCover 1000 -merge -title "$MAGIC variants detected in the ERCC by BRS analysis" > $toto.merged.$isSolid.10.1000
end

## analyse the compatibility ILM/SOLID
goto belowAnalysis

cat $toto.merged.0.10.1000 | gawk -F '\t' '{if(index($4,"N")>=1)next;if ($8>=40 && $9>1000)print}' > $toto.4
cat $toto.merged.1.10.1000 | gawk -F '\t' '{if(index($4,"N")>=1)next;if ($8>=40 && $9>1000)print}' >> $toto.4
cat $toto.4 ZZZZZ $toto.merged.0.10.1000  ZZZZZ $toto.merged.1.10.1000 | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1 "\t" $2]=1; next;}if(index($4,"N")>=1)next;if (ok[$1 "\t" $2] == 1) { m="ILM" ; if(zz == 2) m="SOLiD" ; $6 = m ; printf("%s", $1);for (i=2;i<=NF;i++)printf("\t%s",$i);printf("\n");}}' | $tab_sort | grep ERCC-00134 


foreach run (`cat MetaDB/$MAGIC/RunSolidList`)
   gunzip -c tmp/SNP_BRS/Rhs1250/SpikeIn.snp.u.gz | gawk -F '\t' '{if($1 !="~")ok=0;}/^ERCC-00071/{ok=1;}{if(ok==1 && $2 > 230 && $2 < 240){printf ("%s\t",r);print}}' r=$run >> toto.mysnp
end

gunzip -c tmp/COUNT/Rhs2015/f2.1.mito.gz | grep ERCC-00071
# there are 119 hits on ERCC-00071 in Rhs2013, only 2 reads in one pair give the mutation g>a at position 236
# but the detect code says 195 (probably 1.00 + .95 from quality factors and zero wild type, which is stupid
# there is one wildtype 264/233 (ok too close) and one 199-248
gunzip -c tmp/COUNT/Rhs2013/f2.*.mito.gz | grep ERCC-00071 | gawk -F '\t' '{a1=$12;a2=$13;if (a1<236 && a2 > 236 || a1 > 236 && a2 < 236) print}' > toto.hits
# similar problem with run 2015
cat toto.hits | bin/snp -detect -run Rhs2013
# ok, run_quality is used and the BRS does not report the wild types, one must find them using -extend

 gunzip -c tmp/SNP/Rhs2015/SpikeIn.detect.u.snp.gz | grep ERCC-00071 | gawk '{if($2==236)print}' | gawk '{gsub(/>/,"2",$3);printf("%s:%s%s\n",$1,$2,$3);}' > toto.snpList

# following program crashes but is a good example to debug -aliExtend
cat toto.hits | bin/snp -aliExtend -snp_list toto.snpList -fasta TARGET/Targets/hs.SpikeIn.fasta.gz

# bin/snp -aliExtend -snp_list toto.snpList -fasta toto.SpikeIn.fasta  < toto1.hits

foreach lane (`cat MetaDB/$MAGIC/LaneList`)
  if (! -e tmp/COUNT/$lane.snp_extend.extend_snp) then
    # scripts/submit tmp/COUNT/$lane.snp_extend "bin/snp  -aliExtend -snp_list tmp/SNP_DB/SpikeIn/Variant.list -fasta TARGET/Targets/hs.SpikeIn.fasta.gz -o tmp/COUNT/$lane.snp_extend -i tmp/COUNT/$lane.hits.gz"
  endif
end

belowAnalysis:

## intersection of mito SNPs
## Intersections : mesures de proximite entre samples
if (! -d RESULTS/SNV) mkdir RESULTS/SNV
set toto=RESULTS/SNV/$MAGIC.mito.intersections.txt
date > $toto
echo "Intersect counts and frequecies among SNPs detected in mitchondria by BRS analysis" >> $toto

cat  tmp/SNPH/mito/Fatigue12.snp.sorted.filtered | bin/snp -db MetaDB -minFrequency 90 -minCover 6 -intersect -title "$MAGIC variants detected in the mitochondria by BRS analysis" -project $MAGIC >> $toto
cat tmp/SNPH/mito/Fatigue12.snp.sorted.filtered | bin/snp -db MetaDB -minFrequency 90 -minCover 6 -merge -title "$MAGIC variants detected in the mitochondria by BRS analysis" >> $toto.merged

if ($justMito == 1) goto phaseLoop


if (! -d tmp/Transloc) mkdir tmp/Transloc
echo '// ' > tmp/Transloc/$MAGIC.transloc.txt
foreach run (`cat MetaDB/$MAGIC/RunsList`)
  if (! -d tmp/Transloc/$run) $mkDir Transloc $run
  if (-e tmp/Transloc/$run/d1.$run.de_uno.txt.gz) then
    gunzip -c tmp/Transloc/$run/d1.$run.de_uno.txt.gz >> tmp/Transloc/$MAGIC.transloc.txt1   
  endif
end

$tab_sort -u  tmp/Transloc/$MAGIC.transloc.txt1    >  tmp/Transloc/$MAGIC.transloc.txt
\rm  tmp/Transloc/$MAGIC.transloc.txt1  

goto phaseLoop

cat _rs35 | gawk '/^Variant/{if(v!=$2){for (r in vv){m=0;c=0;if (ff[r]==v){m=fm[r];c=fc[r];}if (rr[r]==v){m+=rm[r];c+=rc[r];}printf("%s\t%d\t%d\n",v,m,c);}}v=$2;}/fCounts/{vv[$2]=v;if(ff[$2]==v)next;ff[$2]=v;fm[$2]=$3;fc[$2]=$4;}/rCounts/{vv[$2]=v;if(rr[$2]==v)next;rr[$2]=v;rm[$2]=$3;rc[$2]=$4;}'> tmp/SNP_DB/counts.simple.txt

cat tmp/SNP_DB/counts.simple.txt | gawk '{if($3 > 1000)printf("%d\t%d\n",$2,$3);}' | bin/histo -smooth -plot -o tmp/SNP_DB/counts.simple.plot

### 

cat tmp/VariantDB.*/snp.genotype.run.* | gawk -F '\t' '/\"/{gsub(/\"/,"",$0);if($7=="mm" && mm[$1]<3)mm[$1]=3;if($7=="wm" && mm[$1]<2)mm[$1]=2;if(mm[$1]==0)mm[$1]=1;v[$1]++;if(v[$1]==1){nv++;if($5!="NULL")inG++;if($6 !="NULL")coding++;if($6 !="NULL")ct[$6]++;typ[$4]++;gg[$7]++;}}END{for(k in mm)z[mm[k]]++;printf("01\tTotal\t%d\n02\tIn_gene\t%d\n03\tCoding\t%d\n", nv, inG, coding);printf("04\tmm\t%d\n",z[3]);printf("04\twm\t%d\n",z[2]);printf("04\tnot_ww\t%d\n",z[1]);for(k in ct)printf("05\t%s\t%d\n",k,ct[k]);for(k in typ)printf("%02d\t%s\t%d\n",6+length(k),k,typ[k]);}' | $tab_sort > RESULTS/$MAGIC.snp2genotype.txt

cat tmp/VariantDB.*/snp.genotype.run.* | gawk -F '\t' '/\"/{gsub(/\"/,"",$0);if($8!="Ghs50")next;if($7=="mm" && mm[$1]<3)mm[$1]=3;if($7=="wm" && mm[$1]<2)mm[$1]=2;if(mm[$1]==0)mm[$1]=1;v[$1]++;if(v[$1]==1){nv++;if($5!="NULL")inG++;if($6 !="NULL")coding++;if($6 !="NULL")ct[$6]++;typ[$4]++;gg[$7]++;}}END{for(k in mm)z[mm[k]]++;printf("01\tTotal\t%d\n02\tIn_gene\t%d\n03\tCoding\t%d\n", nv, inG, coding);printf("04\tmm\t%d\n",z[3]);printf("04\twm\t%d\n",z[2]);printf("04\tnot_ww\t%d\n",z[1]);for(k in ct)printf("05\t%s\t%d\n",k,ct[k]);for(k in typ)printf("%02d\t%s\t%d\n",6+length(k),k,typ[k]);}' | $tab_sort > RESULTS/$MAGIC.snp2genotype.Ghs50.txt


###############################################################################################
## s4 confirm the SNPs and translocation by realigning on the edited sequences

phases4: 
# integrated in snp.parse_remap.tcsh
if (! -d RESULTS/SNV) mkdir RESULTS/SNV
if (! -d tmp/NEWHITS_snp) mkdir tmp/NEWHITS_snp

if (! -e tmp/NEWHITS_snp/all.edited_sequence.w.fasta.gz) then

# ATTENTION
# we need to sort twice
#   A: sort by id, and eliminate doublets with the same DNA keep ing the top one
#      the effect here is to eliminate double definitions of the same SNP attributed to different zones
#      because the progam export edited sequence is greedy
#   B: sort by DNA content to accelerate the code as usual
#      may be a single sort is sufficient

  if (0) then
    gunzip -c tmp/SNP/*.edited_sequence.brk.fasta.gz | gawk '/^>M:/{id=$1;ok=1;next;}{if(ok==1)s[id]=$1;ok=0;}END{for(id in s)printf("%s\t%s\n",id,s[id]);}'  | $tab_sort | gawk -F '\t' '{id=$1;seq=$2;n[seq]++;if(n[seq] == 1)printf("%s\t%s\n",seq,id);}'  | $tab_sort | gawk -F '\t' '{id=$1;seq=$2;printf("%s\n%s\n", $2,$1);}'| gzip -1 > tmp/NEWHITS_snp/all.edited_sequence.m.brk.fasta.gz
    gunzip -c tmp/SNP/*.edited_sequence.snp.fasta.gz | gawk '/^>M:/{id=$1;ok=1;next;}{if(ok==1)s[id]=$1;ok=0;}END{for(id in s)printf("%s\t%s\n",id,s[id]);}' | $tab_sort | gawk -F '\t' '{id=$1;seq=$2;n[seq]++;if(n[seq] == 1)printf("%s\t%s\n",seq,id);}'  | $tab_sort | gawk -F '\t' '{id=$1;seq=$2;printf("%s\n%s\n", $2,$1);}'| gzip -1 > tmp/NEWHITS_snp/all.edited_sequence.m.snp.fasta.gz
  
    gunzip -c tmp/SNP/*.edited_sequence.brk.fasta.gz | gawk '/^>W:/{id=$1;ok=1;next;}{if(ok==1)s[id]=$1;ok=0;}END{for(id in s)printf("%s\t%s\n",id,s[id]);}'  > tmp/NEWHITS_snp/all.edited_sequence.w.fasta1
    gunzip -c tmp/SNP/*.edited_sequence.snp.fasta.gz | gawk '/^>W:/{id=$1;ok=1;next;}{if(ok==1)s[id]=$1;ok=0;}END{for(id in s)printf("%s\t%s\n",id,s[id]);}' >> tmp/NEWHITS_snp/all.edited_sequence.w.fasta1
  
  # eliminate doubles and $tab_sort alphabetically by DNA content 
    cat tmp/NEWHITS_snp/all.edited_sequence.w.fasta1 | $tab_sort | gawk -F '\t' '{id=$1;seq=$2;n[seq]++;if(n[seq] == 1)printf("%s\t%s\n",seq,id,seq);}'  | $tab_sort | gawk -F '\t' '{id=$1;seq=$2;printf("%s\n%s\n", $2,$1);}' > tmp/NEWHITS_snp/all.edited_sequence.w.fasta
    gzip -1 tmp/NEWHITS_snp/all.edited_sequence.w.fasta
  
  else
  ## simpler method, verified to be absolutelly equivalent 2011_06_29
  # somehow the sorted gzip fasta file is longer because the identifier are heavier than the DNA
  
## ATTENTION to debug i have put mito, i should be * in the 4 gunzip -c tmp/SNP/mito.edited lines
    gunzip -c tmp/SNP/*.edited_sequence.brk.fasta.gz  | gawk '/^>M:/{id=$1;ok=1;next;}{if(ok==1)s[id]=$1;ok=0;}END{for(id in s)printf("%s\t%s\n",s[id], id);}' | $tab_sort | gawk -F '\t' '{id=$2;seq=$1;if(seq == oldseq)next; oldseq = seq ; printf("%s\n%s\n", id,seq);}' | gzip -1 > tmp/NEWHITS_snp/all.edited_sequence.m.brk.fasta.gz
   gunzip -c tmp/SNP/*.edited_sequence.snp.fasta.gz  | gawk '/^>M:/{id=$1;ok=1;next;}{if(ok==1)s[id]=$1;ok=0;}END{for(id in s)printf("%s\t%s\n",s[id], id);}'  | $tab_sort | gawk -F '\t' '{id=$2;seq=$1;if(seq == oldseq)next; oldseq = seq ; printf("%s\n%s\n", id,seq);}' | gzip -1 > tmp/NEWHITS_snp/all.edited_sequence.m.snp.fasta.gz
  
  
    gunzip -c tmp/SNP/*.edited_sequence.brk.fasta.gz | gawk '/^>W:/{id=$1;ok=1;next;}{if(ok==1)s[id]=$1;ok=0;}END{for(id in s)printf("%s\t%s\n",s[id], id);}'  > tmp/NEWHITS_snp/all.edited_sequence.w.fasta2
    gunzip -c tmp/SNP/*.edited_sequence.snp.fasta.gz  tmp/SNP/SpikeIn.edited_sequence.snp.fasta.gz  | gawk '/^>W:/{id=$1;ok=1;next;}{if(ok==1)s[id]=$1;ok=0;}END{for(id in s)printf("%s\t%s\n",s[id],id);}' >> tmp/NEWHITS_snp/all.edited_sequence.w.fasta2
  
    cat tmp/NEWHITS_snp/all.edited_sequence.w.fasta2 | $tab_sort | gawk -F '\t' '{id=$2;seq=$1;if(seq == oldseq)next; oldseq = seq ; printf("%s\n%s\n", id,seq);}' | gzip -1 >  tmp/NEWHITS_snp/all.edited_sequence.w.fasta.gz
  
  endif

endif


foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -d tmp/NEWHITS_snp/$run) then
    $mkDir NEWHITS_snp $run
    mkdir tmp/NEWHITS_snp/$run/PRE
    gunzip -c tmp/COUNT/$run/f.*.too_many_hits.gz | gzip -1 >  tmp/NEWHITS_snp/$run/too_many_hits.list.gz
    gunzip -c tmp/COUNT/$run/f.*.too_many_hits.gz | gawk '{if ($2=="Multi")print;}' | $tab_sort -u | gzip -1 >  tmp/NEWHITS_snp/$run/too_many_hits.list8.gz
  endif

  foreach lane (`cat Fastc/$run/LaneList`)
    if (! -e tmp/NEWHITS_snp/$lane.m.hits.gz) then
      if (-e tmp/NEWHITS_snp/$run/edited.countEdited) \rm tmp/NEWHITS_snp/$run/edited.*
      scripts/submit tmp/NEWHITS_snp/$lane "scripts/snp.confirmation.tcsh $run $lane"
    endif
  end
end

goto phaseLoop

###############################################################################################
## s5: Using the realigned sequences, count the support to the SNPs
## this time we need to reclip by 4 bp to match the measured wild type
## in reality we should realign against both and then measure the plain values
## we need in this case to have score >= previous best score and automatically
## the sequences will choose there softer container
## we just look at position 61, we should not have an error
## then we look if we have an oo

phases5: 
echo "phase s5 analyse the alignments to the variome and export the counts"

# export the mismatch count per position

# use lower case zzzzz because of the sort
echo zzzzz | gzip > zzzzz.gz

set ln=`gunzip -c tmp/NEWHITS_snp/all.edited_sequence.w.fasta.gz | head -2 | tail -1 | gawk '{ln=int(1+length($1)/2);print ln;}'`
foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -e tmp/NEWHITS_snp/$run/s590.multi.countEdited) then
    echo $run
    # position of edited base
    scripts/submit tmp/NEWHITS_snp/$run/s5.multi "scripts/s5.countEdited.tcsh run $run $ln"
  endif
end

## look for multiply mapping SNPS
   scripts/submit  tmp/NEWHITS_snp/ambiguities "scripts/s5.ambiguities.tcsh"

goto phaseLoop

###############################################################################################
## skl: Analyse the modes of the distribution accross the population, previously using Karuhnen Loeve

phases6: 

echo "phase Post analysis of the SNPs: open problem, please study the script and help improve it"

set n=`cat MetaDB/$MAGIC/GroupSnpList MetaDB/$MAGIC/RunSnpList | gawk '{n++}END{print n+0}'`
if ($n == 0) then
  echo "Please add the tag SNP to some groups in MetaDB"
  exit 0
endif

####################
#### export the stats of the confirmed SNPs
####
#### among the edited sequences, gather those passing the filter: above $minSnpFrequency % and mutant >= $minSnpCount coverage $minSnpCover or more in at least one person
## ventilate per chromosome as count/cover
mkdir tmp/KL.$MAGIC
# \rm tmp/KL.$MAGIC/confirmed.*

set ok=1
  foreach group (`cat MetaDB/$MAGIC/GroupSnpList MetaDB/$MAGIC/RunSnpList`)
    if (-e tmp/KL.$MAGIC/$group/s6.ventilate.done) continue
    if (! -d tmp/KL.$MAGIC/$group) mkdir tmp/KL.$MAGIC/$group
    set ercc=0
    if ($MAGIC == ERCC) set ercc=1
    echo hello
      set ok=0
      scripts/submit tmp/KL.$MAGIC/$group/s6.ventilate "scripts/s6.ventilate.tcsh $MAGIC $group $minSnpCover $ercc "
  end

if ($ok == 0) scripts/submit wait

## Mendel analysis of the modal type of the smoothed histo of the observed frequency accross the population
## limited in histo.c to snps at least one sample frequency >=20 && count >=10 && mutant >= 5

set ok=1
foreach group (`cat MetaDB/$MAGIC/GroupSnpList MetaDB/$MAGIC/RunSnpList`)
  if (! -d tmp/KL.$MAGIC/$group) continue
  if (! -e tmp/KL.$MAGIC/$group/_toto) then
    set ok=0
    scripts/submit tmp/KL.$MAGIC/$group/s6.ventcount "ls tmp/KL.$MAGIC/$group/confirmed.*.gz > tmp/KL.$MAGIC/$group/_toto" MULTICORE
  endif
end

if ($ok == 0) scripts/submit wait MULTICORE

if (-e  tmp/KL.$MAGIC/_toto) \rm tmp/KL.$MAGIC/_toto
foreach group (`cat MetaDB/$MAGIC/GroupSnpList MetaDB/$MAGIC/RunSnpList`)
  if (! -d tmp/KL.$MAGIC/$group) continue
  cat  tmp/KL.$MAGIC/$group/_toto >>  tmp/KL.$MAGIC/_toto
end
cat tmp/KL.$MAGIC/_toto | gawk -F '/' '{gsub (/\.gz/,"",$4);print $4}' | $tab_sort -u > tmp/KL.$MAGIC/templateList

mkdir tmp/KL.$MAGIC/Histo
foreach template (`cat  tmp/KL.$MAGIC/templateList`)
  if (! -e tmp/KL.$MAGIC/Histo/$template.smoothed_profiles.gz) then
    scripts/submit $template "gunzip -c tmp/KL.$MAGIC/*/$template.gz | bin/histo -KL $minSnpFrequency -gzo -o  tmp/KL.$MAGIC/Histo/$template"  MULTICORE
  endif
end

scripts/submit wait MULTICORE
if (! -d RESULTS/SNV) mkdir RESULTS/SNV
# export the top of the piles
foreach type (2 3 4 5 )
 echo -n "nMode=$type "
 gunzip -c tmp/KL.$MAGIC/Histo/confirmed.*.smoothed_profiles.gz | gawk '{if($2==type)print}' type=$type >  tmp/KL.$MAGIC/all.population_profiles.$type.modes
 wc tmp/KL.$MAGIC/all.population_profiles.$type.modes
echo -n "# " > RESULTS/SNV/$MAGIC.population_profiles.$type.modes.first225.txt
date >> RESULTS/SNV/$MAGIC.population_profiles.$type.modes.first225.txt
echo "# $MAGIC all.population_profiles.$type.modes" >>  RESULTS/SNV/$MAGIC.population_profiles.$type.modes.first225.txt
 head -225  tmp/KL.$MAGIC/all.population_profiles.$type.modes >> RESULTS/SNV/$MAGIC.population_profiles.$type.modes.first225.txt
end

gunzip -c tmp/KL.$MAGIC/Histo/confirmed.*.smoothed_profiles.gz | gawk '{if($2==1){split ($3,aa,":");if(aa[1]>=90)print}}' >  tmp/KL.$MAGIC/all.population_profiles.high_monomodal
wc tmp/KL.$MAGIC/all.population_profiles.high_monomodal
date > RESULTS/SNV/$MAGIC.population_profiles.high_monomodal.first225.txt
echo "# $MAGIC all.population_profiles.high_monomodal" >>  RESULTS/SNV/$MAGIC.population_profiles.high_monomodal.first225.txt
head -225 tmp/KL.$MAGIC/all.population_profiles.high_monomodal >>  RESULTS/SNV/$MAGIC.population_profiles.high_monomodal.first225.txt

gunzip -c tmp/KL.$MAGIC/Histo/confirmed.*.smoothed_profiles.gz | gawk '{if($2==1){split ($3,aa,":");if(aa[1]<20)print}}' >  tmp/KL.$MAGIC/all.population_profiles.low_monomodal
wc tmp/KL.$MAGIC/all.population_profiles.low_monomodal
date > RESULTS/SNV/$MAGIC.population_profiles.low_monomodal.first225.txt
echo "# $MAGIC all.population_profiles.low_monomodal" >>  RESULTS/SNV/$MAGIC.population_profiles.low_monomodal.first225.txt
head -225 tmp/KL.$MAGIC/all.population_profiles.low_monomodal >>  RESULTS/SNV/$MAGIC.population_profiles.low_monomodal.first225.txt

gunzip -c tmp/KL.$MAGIC/Histo/confirmed.*.smoothed_profiles.gz | gawk '{if($2==1){split ($3,aa,":");if(aa[1]>=20 && aa[1]<90)print}}' >  tmp/KL.$MAGIC/all.population_profiles.mid_monomodal
wc tmp/KL.$MAGIC/all.population_profiles.mid_monomodal
date > RESULTS/SNV/$MAGIC.population_profiles.mid_monomodal.first225.txt
echo "$# MAGIC all.population_profiles.mid_monomodal" >>  RESULTS/SNV/$MAGIC.population_profiles.mid_monomodal.first225.txt
head -225 tmp/KL.$MAGIC/all.population_profiles.mid_monomodal >>  RESULTS/SNV/$MAGIC.population_profiles.mid_monomodal.first225.txt

set toto=RESULTS/SNV/$MAGIC.population_profiles.count_modes.txt
date > $toto
echo "# $MAGIC Partition of candidate variants as a  function of their frequency in the population" >>  $toto
echo "# Nodes limited to sites where at least one group has 20% variant measured" >>  $toto
echo "# with at least 5 variants and at least coverage 10. Then the mode graph " >>   $toto
echo "# is computed over thse sites by using only the groups with coverage at least 10." >>   $toto
echo "# Type\tNumber of sites" >> $toto
wc tmp/KL.$MAGIC/all.population_profiles.low_monomodal tmp/KL.$MAGIC/all.population_profiles.mid_monomodal tmp/KL.$MAGIC/all.population_profiles.high_monomodal tmp/KL.$MAGIC/all.population_profiles.*.modes | gawk '{n=$1;i=index($4,"profiles"); printf("%s\t%d\n",substr($4,i+9),n);}' >>    $toto

# reexport the categories into the 'mix' format
\rm  tmp/KL.$MAGIC/all.confirmed.types.txt
foreach type (5.modes 4.modes 3.modes 2.modes high_monomodal mid_monomodal low_monomodal)
  cat tmp/KL.$MAGIC/all.population_profiles.$type | gawk  '{split ($1,aa,":");chr="";if(0 && index(aa[1],"chr")!=1)chr="chr";printf("%s%s:%s:%s\t%s\n",chr,aa[1],aa[2],aa[3],type);}' type=$type >> tmp/KL.$MAGIC/all.confirmed.types.txt
end
cat  tmp/KL.$MAGIC/all.confirmed.types.txt | $tab_sort -u | gawk '{n[$2]++;}END{for (k in n)print k, n[k];}' | $tab_sort -k 1n

# select the non-monomodals
cat  tmp/KL.$MAGIC/all.confirmed.types.txt | grep -v low_monomodal | cut -f 1 | $tab_sort -u | gzip >  tmp/KL.$MAGIC/tri.selected.gz
cat  tmp/KL.$MAGIC/all.confirmed.types.txt | grep  low_monomodal | cut -f 1 | $tab_sort -u | gzip >  tmp/KL.$MAGIC/tri.rejected.gz

gunzip -c  tmp/KL.$MAGIC/tri.selected.gz | wc
gunzip -c  tmp/KL.$MAGIC/tri.rejected.gz | wc

#########
## not used in non amish case $Strategy == Exome

if (! -d tmp/KL.$MAGIC/s6) mkdir  tmp/KL.$MAGIC/s6

  # 
  # export the new support 
  echo ZZZZZ | gzip > ZZZZZ.gz
  
  # the code on human takes 10s per run per template
  # to lower the number of submissions to around 1000, we compute the number of template per block
  set n1=`cat tmp/KL.$MAGIC/templateList | gawk '{n++}END{n1=int((n+999)/1000);if(n1<1)n1=1;print n1}'`
  set n2=`cat tmp/KL.$MAGIC/templateList | gawk '{n++}END{print n}'`

  set n=0
  while ($n < $n2)
    scripts/submit tmp/KL.$MAGIC/s6/s6.selected.$n  "scripts/s6.all.template.tcsh selected $n $n1" 
    @ n = $n + $n1
  end

scripts/submit wait

goto phaseLoop

#####################################################################
######################################################################
## Heat map analysis of the SNP
## Construct a table for RXb
##   x   run1 run2 run3
##  snp   %    %    %
## limited to SNPs where all counts are above limit

## Histogram of least support per snp
cat  tmp/KL.$MAGIC/s6/confirmed._[A-G]*/selected.txt | head -10000000 | gawk -F '\t' '{snp= $1 ":" $2 $3 ; cover=$9; x=cc[snp]+0;if(x==0 || x > cover)cc[snp]=cover;}END{for(snp in cc)printf("%s\t%d\n",snp,cc[snp]);}' | $tab_sort -k 2nr > tmp/KL.$MAGIC/low_cover.txt
## find the good range, drop 10%, then take 1000 values
set n0=`wc  tmp/KL.Primates/low_cover.txt | gawk '{print $1}'`
cat  tmp/KL.Primates/low_cover.txt | gawk '{n++;if (n==1){n1=int(n0/10);n2=n1+1000;}if(n==n1 || n==n2)print}' n0=$n0
## prepare the table
# cat  tmp/KL.Primates/s6/confirmed._*/selected.txt | head -10000000 | gawk -F '\t' '{snp= $1 ":" $2 $3 ;run=$6;p=$8;c=$9;if(c>=c1  && c<=c2){ss[snp]=1;rr[run]=1;srp[snp,run]=p;}else bad[snp]=1;}END{for (run in rr)printf("\t%s",run);for(snp in ss){if(bad[snp]!=1){printf("\n%s",snp);for (run in rr)printf("\t%.1f",srp[snp,run]);}}printf("\n");}' c1=100 c2=200000 > tmp/KL.$MAGIC/highSnp.txt


## prepare the table of the most signifcant signature genes
cat  tmp/KL.$MAGIC/s6/confirmed._*/selected.txt | head -10000000 |  gawk -F '\t' '{snp= $1 ":" $2 $3 ;run=$6;p=$8;c=$9;if(c>=c1  && c<=c2){z="";if(p>90)z=2;else if(p<10)z=0;else z=1;ss[snp]=1;rr[run]=1;srp[snp,run]=z;}}END{for (run in rr)printf("\t%s",run);for(snp in ss){if(bad[snp]!=1){printf("\n%s",snp);for (run in rr)printf("\t%s",srp[snp,run]);}}printf("\n");}' c1=10 c2=200000  > tmp/KL.$MAGIC/highSnp.q.txt

# cat 

if (! -e MetaDB/$MAGIC/run2sample.txt) then
  bin/tacembly MetaDB <<EOF 
    query find runs project == $MAGIC
    bql -a  -o MetaDB/$MAGIC/run2sample.txt -active select r,s from r in @, s in r->sample
    quit
EOF
endif

cat tmp/KL.Primates/highSnp.q.txt | head -1 > RESULTS/highSnp.q.300.txt
cat MetaDB/$MAGIC/run2sample.txt ZZZZZ RESULTS/highSnp.q.300.txt | gawk -F '\t' '/ZZZZZ/{zz=1;next;}{gsub(/\"/,"",$0);if(zz<1){ss[$1]=$2;next;}printf("Sample");for(i=2;i<=NF;i++)printf("\t%s",ss[$i]);printf("\n");}' > tutu.$$
cat tutu.$$ >> RESULTS/highSnp.q.300.txt
\rm tutu.$$
cat tmp/KL.$MAGIC/highSnp.q.txt | $tab_sort  | gawk '{ss=$1;i=index($1,":");g=substr($1,1,i);n[g]++;z[g]=z[g] "\n" $0 ;ssz[ss]=$0;u=0;v=0;w=0;for(i=2;i<=NF;i++){if($i==2)u++;if($i==0)v++;if($i==1)w++;}if(w<4 && 2*u>v && 2*v>u && 2*(u+v)>NF)ok[ss]=1;}END{for(ss in ok)print ssz[ss]}' | $tab_sort  >> RESULTS/highSnp.q.300.txt

## analyse it in R

R
snps = read.table("tmp/KL.Primates/highSnp.q.txt")
gg=as.matrix(snps)
cc=cor(gg)
# heatmap takes 5 minutes to draw
pdf("highSnp.correl.pdf") ;
hh=heatmap(cc, scale="none")
write(colnames(gg)[hh$rowInd],"highSnp.correl.Legend.txt")
# pp=prcomp(genes,center=TRUE,scale=FALSE)
quit()

#####################################################################
######## From the BRS analysis (SNP/detect and count) extract the signature SNPs

## 1: collect the highly expressed homozygotes
foreach run (`cat MetaDB/$MAGIC/RunList`)
  echo $run
  gunzip -c tmp/SNP/$run/zone*.count.u.txt.gz | gawk -F '\t' '{snp= $1 ":" $2 $3 ; cover=$9; if($8>98 && $9 > 100){x=cc[snp]+0;if(x==0 || x > cover)cc[snp]=cover;}}END{for(snp in cc)printf("%s\t%d\t%s\n",snp,cc[snp],run);}' run=$run | $tab_sort -k 2nr | head -1000 >  tmp/SNP/$run/highest.snps.txt
end
## 2: grab the cream of the pack, 
cat tmp/SNP/*/highest.snps.txt | gawk -F '\t' '{cc[$1]+=$2;}END{for(snp in cc)printf("%s\t%d\n",snp,cc[snp]);}' | $tab_sort -k 2nr | head -10000 | gzip >  tmp/SNP/highest.snps.txt.gz
## measure it in all runs
foreach run (`cat MetaDB/$MAGIC/RunList`)
  echo $run
  gunzip -c tmp/SNP/highest.snps.txt.gz ZZZZZ.gz tmp/SNP/$run/zone*.count.u.txt.gz | gawk -F '\t' '/^ZZZZZ/{zz=1;next;}{if(zz<1){ok[$1]=1;next;}}{snp= $1 ":" $2 $3 ;if(ok[snp]==1 && $9>=10)print}' >  tmp/SNP/$run/highest.snps.counts
end
## export as a table the SNPs with good contrast (seen in 2, 3 or 4 of the 6 runs as m/m or as +/+
set toto=tmp/SNP/$MAGIC.Most_significant_snps.txt
echo -n "# " > $toto
date >> $toto
echo -n "# $MAGIC.Most_significant_snps\n# " >> $toto

cat r2t.txt  | sed -e 's/ /_/g' | $tab_sort -k 2,2 -k 1,1 |  sed -e 's/_/ /g' > tutu
echo ZZZZZ >> tutu
foreach run (`cat MetaDB/$MAGIC/RunList`)
  cat  tmp/SNP/$run/highest.snps.counts >> tutu
end
cat tutu |  gawk -F '\t' '/^ZZZZZ/{zz=1;next;}{if(zz<1){gsub(/\"/,"",$0);r=$1;title[r]=$2;ir=r2ir[r];if(ir<1){irmax++;ir=irmax;r2ir[r]=ir;ir2r[ir]=r;}next;}}{snp= $1 ":" $2 $3 ; p=$8 ; if($9<10) next; cc[snp]+=$9;z=-1;if(p<3){ss[snp]++;z=0;}if(p>97){mm[snp]++;z=1;}r=$6;ir=r2ir[r];if(ir<1){irmax++;ir=irmax;r2ir[r]=ir;ir2r[ir]=r;}nz[ir,snp]=z;}END{printf("SNP\tGlobal cover\tNumber of mutant runs\tNumber of wild type runs\t0");for(ir=1;ir<=irmax;ir++)printf("\t%s",ir2r[ir]);printf("\nSNP\tGlobal cover\tNumber of mutant runs\tNumber of wild type runs\t1");for(ir=1;ir<=irmax;ir++)printf("\t%s",title[ir2r[ir]]);for(snp in mm)if(3*(ss[snp]+mm[snp])>= irmax && 10*ss[snp] >irmax && 10*mm[snp]>irmax){printf("\n%s\t%d\t%d\t%d",snp,cc[snp],mm[snp],ss[snp]);u=-mm[snp]-ss[snp] + 2*irmax;printf("\t%d",u);for(ir=1;ir<=irmax;ir++){v=nz[ir,snp];if(v==-1)v="";printf("\t%s",v);}}printf("\n");}' | $tab_sort -k 5n >> $toto

\cp $toto RESULTS


#####################################################################
######################################################################
## Report the number of supports in the selected and rejected sets

set toto=RESULTS/SNV/$MAGIC.types_of_anomalies_in_the_union_of_all_groups.txt
  date > $toto
  echo "$selectReject variants. The types are counted in the union of all groups in $MAGIC" >> $toto
foreach selectReject (selected rejected)
  echo >> $toto
  echo "$selectReject variants (the selected Incompatible are later moved to rejected)"  >> $toto
  echo "\tType\tCount\tCount per variant" >> $toto

  cat tmp/KL.$MAGIC/*/any.$selectReject.txt | gawk '/^#/{next}{nn++;n["1\tNumber of variants"]++;n["4\tCoverage"]+=$9;n["2\tReads supporting the variants"]+=$10;n["3\tReads supporting the reference"]+=$11;n["5\t" $19]++;n["6\t" $21]++;}END{for (k in n) printf("%s\t%d\t%.2f\n", k,n[k],n[k]/nn);}' | grep -v \- | $tab_sort >> $toto
end

######################################################################
# Multi Venn diagram by error types by runs
# set minSnpCount=3
# set minSnpCover=5
set toto=RESULTS/SNV/$MAGIC.snp_s590_counts.txt
date > $toto
echo "Number of variant per run after de Bruijn realignment seen at frequency at least $minSnpFrequency %, coverage at least $minSnpCover, with at least $minSnpCount sequences supporting the variant" >> $toto 
cat MetaDB/$MAGIC/RunListSorted ZZZZZ  MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/NEWHITS_snp/*/s590.multi.countEdited  | gawk -F '\t' -f scripts/snpSupportStat.awk group=$group format=txt minMut=$minSnpCount minCover=$minSnpCover minF=$minSnpFrequency >> $toto

cat tmp/NEWHITS_snp/*/s590.multi.countEdited |  gawk -F '\t' '/^#/{next}{if ($8 > 10 && $9 >= minCover && $10 >= 0) print $9,$10;}' minMut=$minSnpCount minCover=$minSnpCover minF=$minSnpFrequency | bin/histo -smooth -plot -o RESULTS/SNV/$MAGIC.snp_s590_plot

######################################################################
# Multi Venn diagram by error types by groups
set toto=RESULTS/SNV/$MAGIC.snp_confirmed_counts_by_group_in_selected_snp.txt
date > $toto
echo >> $toto
echo "Number of variant per group, rejecting the low monomodals, after de Bruijn realignment seen at frequency at least $minSnpFrequency %, coverage at least $minSnpCover, with at least $minSnpCount sequences supporting the variant" >> $toto 

  cat MetaDB/$MAGIC/RunListSorted ZZZZZ  MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/KL.$MAGIC/*/*selected.txt | gawk -F '\t' -f scripts/snpSupportStat.awk format=txt minMut=$minSnpCount minCover=$minSnpCover minF=$minSnpFrequency >> $toto

# export the corresponding histo
cat tmp/KL.$MAGIC/*/selected.txt | gawk -F '\t' '/^#/{next}{if ($8 > 10 && $9 >= minCover && $10 >= 0) print $9,$10;}' minMut=$minSnpCount minCover=$minSnpCover minF=$minSnpFrequency | bin/histo -smooth -plot -o RESULTS/SNV/$MAGIC.snp_selected_by_group_plot

######################################################################
# SNV density histogram genome wide per 100kb
set toto=RESULTS/SNV/SNV.density.genome_wide.txt
date > $toto
echo "Density of selected SNV along the chromosomes, each SNV is counted once per individual where it is seen at frequency at least $minSnpFrequency %, coverage at least $minSnpCover, with at least $minSnpCount sequences supporting the variant" >> $toto
echo "Chromosome\tkb\tNUmber of SNP" >> $toto
cat tmp/KL.$MAGIC/*/selected.txt | gawk -F '\t' '/^#/{next;}{if ($2 > 0 && $8 > minF && $9 >= minCover && $10 >= minMut) printf("%d\t%s\t%d\n",0+$1,$1,$2);}'  minMut=$minSnpCount minCover=$minSnpCover minF=$minSnpFrequency |  $tab_sort -k 1,1n -k 2,2 -k 3,3n | gawk '{if($2 != old)n++;z=int($3/100000);if(z!=oldz)n++;old=$2;oldz=z;uu[n]=old "\t" 100*oldz;nn[n]++;}END{for(i=1;i<n;i++)if(uu[i])printf("%s\t%d\n",uu[i],nn[i]);}' >> $toto

# create a .ace file for the selected variant, limited at coverage 10
# sort by variant and reexport in .ace format
if (0) then
  foreach chrom (mito $chromSetAll)
     cat tmp/KL.$MAGIC/all.visible.countEdited | gawk -F '\t' '{if($1==chrom)print}' chrom=$chrom | gawk -F '\t' -f scripts/snp2ace.awk format=txt targetType=IntMap > tmp/KL.$MAGIC/allVisible.chrom$chrom.ace 
  end
endif

# Complete table on with one column per group
cat tmp/KL.$MAGIC/*/selected.txt | gawk -F '\t' '{if($2 < 0)next;if ($9 >= 10 && $2 > 0)print}' > RESULTS/SNV/$MAGIC.variome.details.txt

set toto=RESULTS/SNV/$MAGIC.variome.big_table
cat MetadDB/gtitle[rg].txt ZZZZZ tmp/KL.$MAGIC/*/selected.txt | bin/snp -mergeExportPopulationTable -title "$MAGIC variants measured and not low monomodals, using the variome counts" -o $toto
\rm $toto

#################
## Intersections : mesures de proximite entre samples
set toto=RESULTS/SNV/$MAGIC.variome.non_monomodal.intersections.txt
date > $toto
echo "some kind of intersect" >> $toto
cat   tmp/KL.$MAGIC/*/*selected.txt | bin/snp -db MetaDB -intersect -title "$MAGIC variants measured and non monomodals, using the variome counts" >> $toto

#############

# create a .ace file for the selected variant, accepting very low counts/coverage
# sort by variant and reexport in .ace format
mkdir tmp/KL.$MAGIC/ACE
foreach chrom (mito $chromSetAll)
  cat tmp/KL.$MAGIC/*/*selected.txt | gawk -F '\t' '{if($1==chrom && $2 > 0)print}' chrom=$chrom | gawk -F '\t' -f scripts/snp2ace.awk format=txt targetType=IntMap > tmp/KL.$MAGIC/ACE/allSelected.chrom$chrom.ace
end

goto phaseLoop

################
# phasing of the selected snp
cat tmp/KL.$MAGIC/tri ZZZZZ tmp/KL.$MAGIC/Ghs*/edited.phasing | gawk -F '\t' '/^ZZZZZ/{zz=1;next;}{if(zz<1){i=index($1,"Del");if(i>1)$1=substr($1,1,i+2);i=index($1,"Ins");if(i>1)$1=substr($1,1,i+2);ok[$1]=1;next;}$2+=1;$5+=1;z1=$1 ":" $2 ":" $3;z2=$4 ":" $5 ":" $6; if(ok[z1]==1 && ok[z2]==1){printf("%s",$1);for(i=2;i<=NF;i++)printf("\t%s",$i);printf("\n");}}' | $tab_sort -k 1,1 -k 2,2n -k 3,3 -k 5,5n > tmp/KL.$MAGIC/all.selected.phasing
wc tmp/KL.$MAGIC/all.selected.phasing
cat tmp/KL.$MAGIC/all.selected.phasing | gawk '{nc += $11;nt+=$12;}END{print nc, nt}'
cat tmp/KL.$MAGIC/all.selected.phasing | cut -f 1,2,3,4,5,6 | $tab_sort -u | wc

# select some cases in trans, then at the same positions find pairs in cis
cat tmp/KL.$MAGIC/all.selected.phasing | gawk '{if($12>10*$11 && $12 > 10 && $1 ==22)print;}' > tata1
[mieg@lmem03 ~/Amish]$ cat tata1 ZZZZZ tmp/KL.$MAGIC/all.selected.phasing | gawk '/^ZZZZZ/{zz=1;next;}{z=$1 $2 $3 $4 $5 $6 ;if(zz<1){ok[z]=1;;next;}if(ok[z]==1 && $11 > 5*$12)print}' | head

set group=Ghs103
# add the coordinates of the preudo exon in the Variant
# export a table with 4 col
foreach chrom ($chromSetAll)
  cat  tmp/KL.$MAGIC/ACE/allSelected.chrom$chrom.ace | gawk '/^Variant/{if(w){w=0;printf("\tm/m:m/+:+/+\t%d\t%d\t%d\n",mm,wm,ww);}v=$2;mm=0;wm=0;ww=0;next;}/^IntMap/{w=1;printf("%s\t%d\t%d\tVariant\t%s",$2,$3,$3+1,v);}/^FQ/{if($2=="mm")mm++;else if ($2=="ww")ww++;else wm++;}END{if(w)printf("\t%dmm,%dm+,%d++\n",mm,wm,ww);}' >  tmp/KL.$MAGIC/totovv.$chrom
  cat TARGET/GENES/av.gene.ace  | gawk '/^Genefinder/{next;}/^GeneId/{next;}/^Gene/{g=$2;t="";st="+";next;}/^Title/{t=substr($0,7);next;}/^IntMap/{a=$3;b=$4;if(a>b){a0=a;a=b;b=a0;st="-";}gsub(/\"/,"",$0);if($2==chrom)printf("%s\t%d\t%d\tGene\t%s\t%s\t%s\n",$2,a,b,g,st,t);}' chrom=$chrom >>  tmp/KL.$MAGIC/totovv.$chrom
  cat  tmp/WIGGLE/$chrom/$WnewExon.pseudoexon.$minCoveron.nu.txt | gawk '{n++;printf("%s\t%d\t%d\tPseudoExon\t%s:%d\t%d\t%d\n",$1,$2,$3,$1,n,$3-$2+1,$4);}' >>  tmp/KL.$MAGIC/totovv.$chrom

cat TARGET/mrnaRemap.av.$chrom.txt | gawk -F '\t' '{mrna=$2;x1=$3;x2=$4;chrom=$5;a1=$6;a2=$7;if(a1>a2){a0=a1;a1=a2;a2=a0;x0=x1;x1=x2;x2=x0;}printf("%s\t%d\t%d\tmRNA\t%s\t%d\t%d\n",chrom,a1,a2,mrna,x1,x2);}' >>  tmp/KL.$MAGIC/totovv.$chrom

  $tab_sort -k 1,1 -k 2,2n  tmp/KL.$MAGIC/totovv.$chrom >  tmp/KL.$MAGIC/totovv2.$chrom
end

## associate the variants to the genes
## scan the table, memorize the last gene, find a variant, if we are inside we win
# there is however a C method to do the samething in snp.parse_remap  : snp -remap2gene, -translate, -pheno
foreach chrom ($chromSetAll)
  cat tmp/KL.$MAGIC/totovv2.$chrom | gawk -F '\t' -f scripts/s6.variant2gene.awk > tmp/KL.$MAGIC/variant2gene.$chrom.txt1
  cat tmp/KL.$MAGIC/variant2gene.$chrom.txt1 | sed -e 's/Gene/zGene/' | $tab_sort | sed -e 's/zGene/Gene/' | gawk -F '\t' '{v=$2;if(v==oldv)next;oldv=v;printf("Variant\t%s\t%s\t%s",$2,$3,$4); if ($3 == "mRNA")printf(":%s:%s",$5,$6);printf("\n");}' >  tmp/KL.$MAGIC/variant2gene.$chrom.txt
  cat tmp/KL.$MAGIC/variant2gene.$chrom.txt1 | sed -e 's/Gene/zGene/' | $tab_sort | sed -e 's/zGene/Gene/' | gawk -F '\t' '{v=$2;if(v==oldv)next;oldv=v;printf("Variant %s\n%s %s",$2,$3,$4); if ($3 == "mRNA")printf(" %s %s",$5,$6);printf("\n\n");}' >  tmp/KL.$MAGIC/variant2gene.$chrom.ace

end

# histo des distances entre variants
cat  tmp/KL.$MAGIC/totovv2.* | gawk '{if($4=="Variant"){if($1==chrom){d=$2-old+1;if(d>1000)d=1000;print d;}chrom=$1;old=$3;}}' | bin/histo -plain -title "Distance between variants" -o $MAGIC.distance_between_variants -plot

# Complete table on 120 columns
set toto=~/RESULTS/SNV/$MAGIC.variome.big_table
cat tmp/KL.$MAGIC/all.measured.non_monomodal.countEdited | bin/snp -mergeExportPopulationTable -title "$MAGIC variants measured and not low monomodals, using the variome counts" -o $toto
mv $toto.counts.txt $toto.counts.txt.1
cat $toto.counts.txt.1 | gawk '/^#/{print}' > $toto.counts.txt
cat $toto.counts.txt.1 | gawk '/^#/{next}{print}' | $tab_sort -k 1,1 -k 2,2n -k 3,3 >> $toto.counts.txt

cat tmp/KL.$MAGIC/all.measured.non_monomodal.countEdited | gawk '{if($6 == "Ghs25" || $6 == "Ghs28")print}' |  gawk '{z = $1 "." $2 "." $3 ; if(substr($9,1,1)=="m") {if($8 == "Ghs25")n[z]+=1 ;if($8 == "Ghs28")n[z]+=2;}}END{for(z in n)nn[n[z]]++;for (k in nn)  print k, nn[k];}'


################
## hack add a gene/mrna column in the big table
gunzip -c tmp/METADATA/mrnaRemap.gz  | gawk -F '\t' '/^KT/{s=$2;x1=$3;x2=$4;a1=$6;a2=$7;if(old == s && (a1<a2 && a1 < olda2 || a1>a2 && a1 > olda2))print; old=s;olda2 = a2 ;}' | cut -f 2 | $tab_sort -u > toto_loc_with_knots 
cat  toto_loc_with_knots  ZZZZZ tmp/VariantDB.*/snp2coding.nickname.txt | gawk '/^ZZZZZ/{zz=1;next;}{if(zz<1){bad[$1]=1;bad[substr($1,2)]=1;next;}split($2,aa,":");if(bad[aa[1]]>0)next;print;}' > toto.snp2coding.nickname.txt


cat /home/mieg/RESULTS/SNV/AmishExome.variome.big_table.counts.txt | gawk -F '\t' '/^# Chromo/{printf("%s",$1);for (i=2;i<=8;i++)printf("\t%s",$i);printf("\tIntronic in gene\tExonic:mRNA model,if it is RefSeq based, the name ends with _1... and we give the translation if the variant is in the CDS, all other mRNA names are from AceView and we skip the translation:type if coding:reference DNA:Reference peptide:Modified residue in protein:Variant DNA:Variant peptide else coordinate in mRNA:strand 1 or -1");for (i=9;i<=NF;i++)printf("\t%s",$i);printf("\n");next;}/^#/{print}{nLines++;if(nLines > 10)last;}' | sed -e 's/non monomodal/not low monomodal/' >  /home/mieg/RESULTS/SNV/AmishExome.variome.big_table.counts.with_gene.txt

cat tmp/KL.$MAGIC/variant2gene.*.txt ZZZZZ  toto.snp2coding.nickname.txt ZZZZZ /home/mieg/RESULTS/SNV/AmishExome.variome.big_table.counts.txt | gawk -F '\t' '/^ZZZZZ/{zz+=1;next;}/^#/{next}{if(zz<1){gsub(/\"/,"",$0);v=$2;if($3=="Gene")gene[v]=$4;if($3=="mRNA"){mrna[v]=$4;}next;}}{if(zz<2){mrna[$1]=$2;next;}}{if(length($1)<1)next;printf("%s",$1);for (i=2;i<=8;i++)printf("\t%s",$i);w=$3;gsub(/>/,"2",w);v=$1 ":" $2 ":" w;if(gene[v])g=gene[v];else g="-";if(mrna[v])m=mrna[v];else m="-";printf("\t%s\t%s",g,m);for (i=9;i<=NF;i++)printf("\t%s",$i);printf("\n");}' | $tab_sort -k 1,1 -k 2,2n >> /home/mieg/RESULTS/SNV/AmishExome.variome.big_table.counts.with_gene.txt

cat /home/mieg/RESULTS/SNV/AmishExome.variome.big_table.genotypes.txt | gawk -F '\t' '/^# Chromo/{printf("%s",$1);for (i=2;i<=8;i++)printf("\t%s",$i);printf("\tIntronic in gene\tExonic:mRNA model,if it is RefSeq based, the name ends with _1... and we give the translation if the variant is in the CDS, all other mRNA names are from AceView and we skip the translation:type if coding:reference DNA:Reference peptide:Modified residue in protein:Variant DNA:Variant peptide else coordinate in mRNA:strand 1 or -1");for (i=9;i<=NF;i++)printf("\t%s",$i);printf("\n");next;}/^#/{print}'  | sed -e 's/non monomodal/not low monomodal/'>  /home/mieg/RESULTS/SNV/AmishExome.variome.big_table.genotypes.with_gene.txt

cat tmp/KL.$MAGIC/variant2gene.*.txt ZZZZZ  toto.snp2coding.nickname.txt ZZZZZ /home/mieg/RESULTS/SNV/AmishExome.variome.big_table.genotypes.txt | gawk -F '\t' '/^ZZZZZ/{zz+=1;next;}/^#/{next}{if(zz<1){gsub(/\"/,"",$0);v=$2;if($3=="Gene")gene[v]=$4;if($3=="mRNA"){mrna[v]=$4;}next;}}{if(zz<2){mrna[$1]=$2;next;}}{if(length($1)<1)next;printf("%s",$1);for (i=2;i<=8;i++)printf("\t%s",$i);w=$3;gsub(/>/,"2",w);v=$1 ":" $2 ":" w;if(gene[v])g=gene[v];else g="-";if(mrna[v])m=mrna[v];else m="-";printf("\t%s\t%s",g,m);for (i=9;i<=NF;i++){x=$i;if(x>.2 && x < 1.8)x=1;printf("\t%s",x);}printf("\n");}' | $tab_sort -k 1,1 -k 2,2n >> /home/mieg/RESULTS/SNV/AmishExome.variome.big_table.genotypes.with_gene.txt

## count how many variants are in a gene, an mrna
cat  /home/mieg/RESULTS/SNV/AmishExome.variome.big_table.counts.with_gene.txt | gawk -F '\t' '/^#/{next}{nn++;if($9!="-"){m[$9]++;n1++;if(m[$9]==1)nm++;}}END{printf("%d variants, %d (%.1f%%) are in intronic regions of %d genes\n",nn, n1,100*n1/nn,nm);}' > tuti
cat  /home/mieg/RESULTS/SNV/AmishExome.variome.big_table.counts.with_gene.txt | gawk -F '\t' '/^#/{next}{nn++;if($10!="-"){m[$10]++;n1++;if(m[$10]==1)nm++;}}END{printf("%d variants, %d (%.1f%%) are in exonic regions of %d transcripts\n",nn, n1,100*n1/nn,nm);}' >> tuti

## try to attribute the sex by looking for individual mostly homozygous or hetero on chromosome X
# cat /home/mieg/RESULTS/SNV/AmishExome.variome.big_table.counts.with_gene.txt | gawk '/^X/{for(i=8;i<140;i++){z=$i;split (z,aa,",");u=aa[1]+aa[3];v=aa[2]+aa[4];if(u+v>10){if(3*u > u+v && 3*v > u+v)n1[i]++; else if(10*u<u+v || 10*v<u+v)n2[i]++;}}}END {for (i in n1){s="F";if(10*n1[i]<n2[i])s="M";print i+9,n1[i],n2[i],s;}}' | $tab_sort -k 1n | grep F
##############


# PCA of selected variants ^ sample
 cat  tmp/KL.$MAGIC/ACE/allSelected.chrom*.ace | gawk '/^Variant/{v=$2;vv[v]=1;next;}/^FQ/{if($2=="mm")mm=2;else if ($2=="ww")mm=-2;else mm=0;s=$3;vm[v,s]=mm;ss[s]=1;}END{for (s in ss)printf("\t%s",s);for(v in vv){printf("\n%s",v);for(s in ss)printf("\t%d",2+vm[v,s]);}printf("\n");}' > tmp/KL.$MAGIC/selected.v2group.txt

# Ghs106/110/112 is a good triplet
cat tmp/KL.$MAGIC/all.selected.countEdited | gawk '/^X/{g=$6;if(g=="Ghs106" || g == "Ghs110" || g=="Ghs112")print}' | $tab_sort -k 1,1 -k 2,2n | cut -f 1,2,3,6,7,8 | gawk '{z=$1"\t"$2"\t"$3;zz[z]=1;g=$4;gg[g]=1;gz[g,z]=$5;gf[g,z]=$6;}END{printf("\t\t");for(g in gg)printf("\t%s",g);for(g in gg)printf("\t%s",g);for(z in zz){printf("\n%s",z);for(g in gg)printf("\t%s",gz[g,z]);for(g in gg)printf("\t%s",gf[g,z]);}printf("\n");}' | $tab_sort -k 1,1 -k 2,2n >  toto.triplet.txt
\cp toto.triplet.txt RESULTS/SNV

NEWHI
# histo also creates a table of the smoothed profiles for R or mathematica

goto phaseLoop

R
genes = read.table("tmp/KL.$MAGIC/test.smoothed_profiles")
genes = read.table("tmp/KL.$MAGIC/selected.v2group.txt")
gg=as.matrix(genes)
#cc=cor(gg)
# heatmap takes 5 minutes to draw
# heatmap(cc)
pp=prcomp(genes,center=TRUE,scale=FALSE)
round (100*cov(predict(pp)[1:5,1:5]),0)


# extract first axis as a row vector
v1=pp$rotation[,1]

w1=as.integer(1000 * pp$rotation[,1])
w2=as.integer(1000 * pp$rotation[,2])
w3=as.integer(1000 * pp$rotation[,3])
w4=as.integer(1000 * pp$rotation[,4])
w5=as.integer(1000 * pp$rotation[,5])
ww=cbind(w1,w2,w3,w4,w5)

# find the projection of all genes on the first axis
alpha1= gg  %*% v1
p1gg = alpha1 %*% t(v1)
o1gg = gg - p1gg
# verify the orthogonality to the first axis
o1gg  %*% v1

# plot the distribution
hist(alpha1)

# secons axis
v2=pp$rotation[,2]
alpha2= o1gg  %*% v2
p2gg = alpha2 %*% t(v2)
o2gg = o1gg - p2gg
# verify the orthogonality to the first axis
#o2gg  %*% v2
# plot the distribution
hist(alpha2)

# third axis
v3=pp$rotation[,3]
alpha3= o2gg  %*% v3
p3gg = alpha3 %*% t(v3)
o3gg = o2gg - p3gg
# plot the distribution
hist(alpha3)

# 4th axis
v4=pp$rotation[,4]
alpha4= o3gg  %*% v4
p4gg = alpha4 %*% t(v4)
o4gg = o3gg - p4gg
# plot the distribution
hist(alpha4)

# 5th axis
v5=pp$rotation[,5]
alpha5= o4gg  %*% v5
p5gg = alpha5 %*% t(v5)
o5gg = o4gg - p5gg
# plot the distribution
hist(alpha5)

goto phaseLoop

###############################################################################################
## s7: parse the SNP into  tmp/SNP_DB is now in s20"

phases7:
echo "obsolete, transfered to s20"

goto phaseLoop

### parse the snp in chromosome 10
## transfer the phenotypes in the snps
# bin/snp -group -db tmp/VariantDB.$zone
# reexport the snp intmap and phenotype

# 2012_10_01 : reexport as .txt2, we have done a clean up between june20 and july1 2011, so the previous data sets was a bit different

set phenos="chgMaxAggrColl2  chg2MaxAggrPRPADP20 iAUCTriglycerides tIAUCTriglycerides BP"
foreach chrom ($chromSetAll)
  echo "find variant" > _ccc.$chrom
  foreach pheno ($phenos)
    if (! -d PHENO2/$pheno) mkdir  PHENO2/$pheno
    echo "query find variant phenotype" >> _ccc.$chrom
    echo "table -active -o PHENO2/$pheno/$pheno.chrom.$chrom.txt -f ../scripts/variant2map2pheno.def CATEG $pheno" >> _ccc.$chrom
  end
  bin/tacembly tmp/VariantDB.$chrom < _ccc.$chrom &
end


# create a BV wiggle and smooth it

# first average over 100bp in a hard way on the measured points
# $chromSetAll
foreach pheno ($phenos)
  pushd PHENO2/$pheno
    foreach chrom ($chromSetAll)
      if (! -e  profile.relatif.$chrom.txt) then

        cat $pheno.chrom.$chrom.txt  | gawk '/^\"/{if($6<0)$6=-$6;chrom=$2;x=int(($3+50)/100); if(x==oldx && chrom==oldchrom){oldz+=$6;oldn++;next;}if(oldn>0)printf("%s\t%d\t%f\n",oldchrom,100*oldx,oldz/oldn);oldn=1;oldx=x;oldz=$6;oldchrom=chrom;}END{if(oldn>0)printf("%s\t%d\t%f\n",oldchrom,100*oldx,oldz/oldn);}' |  gawk '/\"/{chrom=$1;if(chrom!=oldchrom){oldchrom=chrom;printf("track type=wiggle_0\nvariableStep chrom=%s\n",chrom);}printf("%d\t%f\n", $2,$3)}'  | bin/wiggle -I BV -O BF -out_step 100 | bin/wiggle -I BF -O BF -out_step 100 -gauss 1000000 |  bin/wiggle -I BF -O BV -out_step 2000 > profile.$chrom.txt
        cat $pheno.chrom.$chrom.txt  | gawk '/^\"/{$6=2000;       chrom=$2;x=int(($3+50)/100); if(x==oldx && chrom==oldchrom){oldz+=$6;oldn++;next;}if(oldn>0)printf("%s\t%d\t%f\n",oldchrom,100*oldx,oldz/oldn);oldn=1;oldx=x;oldz=$6;oldchrom=chrom;}END{if(oldn>0)printf("%s\t%d\t%f\n",oldchrom,100*oldx,oldz/oldn);}' |  gawk '/\"/{chrom=$1;if(chrom!=oldchrom){oldchrom=chrom;printf("track type=wiggle_0\nvariableStep chrom=%s\n",chrom);}printf("%d\t%f\n", $2,$3)}'  | bin/wiggle -I BV -O BF -out_step 100 | bin/wiggle -I BF -O BF -out_step 100 -gauss 1000000 |  bin/wiggle -I BF -O BV -out_step 2000 > density.$chrom.txt

        echo ZZZZZ > ZZZZZ
        cat  profile.$chrom.txt ZZZZZ density.$chrom.txt | gawk '/^ZZZZZ/{zz=1;next;}{if(zz<1){a[$1]=$2;next;}u=a[$1];printf("%d\t%f\n",$1,3*(-1.25*$2+u));}' > profile.relatif.$chrom.txt
      endif
      cat  profile.relatif.$chrom.txt | gawk '{x=$1;if ($2 < n){if (a1>0)printf("%s\t%09dd\tZONE\t%d\n",chrom,a1,x);a1=0;next;}if(a1<1)a1=x;}' n=500 chrom=$chrom > chrom.$chrom.over.500.txt
      cat chrom.$chrom.over.500.txt > tutu
      cat  $pheno.chrom.$chrom.txt  | gawk '{gsub(/\"/,"",$0);printf("%s\t%09d\tSNP\t",$2,$3);print;}' >> tutu 
      cat tutu | $tab_sort | gawk '/ZONE/{c=$1;a1=$2;a2=$4;next;}{x=$2;if (x>0 && $1 == c && x >= a1 && x <= a2)print;}' > snp.chrom.$chrom.over.500.pheno
    end
  popd
end

foreach pheno ($phenos)
  cat PHENO2/$pheno/snp.chrom.*.over.500.pheno | gawk -F '\t' '{printf("%d\t",int($9));print;}' | $tab_sort -k 1n > tutu
  cat tutu | gawk '{n++;z[n]=$0;}END{for (i = 1 ; i<= 150 ; i++){ print z[i]; print z[n+1-i];}}' | cut -f 2,5,7,8,9,10 | $tab_sort | gawk -F '\t' '{printf("%s\t%s\t%s\t%s\t%s\t%s\n",$2,$1,$3,$4,$5,$6);}' | gzip > PHENO2/$pheno.best.snp.gz

end


tail -n +4 profile.relatif.$chrom.txt > profile.relatif.txt2
tail -n +4 profile.$chrom.txt > profile.txt2
tail -n +4 density.$chrom.txt > density.txt2
gnuplot -bg white
 plot  'profile.txt2', 'density.txt2'
 plot 'profile.relatif.txt2'
 plot [3100000:3300000] 'profile.1.txt2', 'density.1.txt2'


toto2.density > toto3.density

#### 2012_09_01
## last week we exported over40.ace: list of zones in the > profile.relatif over 40
## extract the snps and the clopidogrel coeff corresponding to these zones
cat over40.ace | gawk '/IntMap/{gsub(/\"/,"",$0);printf("%s\t%09d\tZONE\t%09d\n",$2,$3,$4)}' > tutu
cat chgMaxAggrColl2.chrom.*.txt | gawk '{gsub(/\"/,"",$0);printf("%s\t%09d\tSNP\t",$2,$3);print;}' >> tutu
cat tutu | $tab_sort > tutus
cat tutus | gawk '/ZONE/{c=$1;a1=$2;a2=$4;next;}/SNP/{x=$2;if (x>0 && $1 == c && x >= a1 && x <= a2)print;}' > snp_clopi.in_over40_zones.txt

 


####

cat _rs35 | gawk '/^Variant/{if(v!=$2){for (r in vv){m=0;c=0;if (ff[r]==v){m=fm[r];c=fc[r];}if (rr[r]==v){m+=rm[r];c+=rc[r];}printf("%s\t%d\t%d\n",v,m,c);}}v=$2;}/fCounts/{vv[$2]=v;if(ff[$2]==v)next;ff[$2]=v;fm[$2]=$3;fc[$2]=$4;}/rCounts/{vv[$2]=v;if(rr[$2]==v)next;rr[$2]=v;rm[$2]=$3;rc[$2]=$4;}'> tmp/VariantDB/counts.simple.txt

cat tmp/VariantDB/counts.simple.txt | gawk '{if($3 > 1000)printf("%d\t%d\n",$2,$3);}' | bin/histo -smooth -plot -o tmp/VariantDB/counts.simple.plot

### 

cat tmp/VariantDB.*/snp.genotype.run.* | gawk -F '\t' '/\"/{gsub(/\"/,"",$0);if($7=="mm" && mm[$1]<3)mm[$1]=3;if($7=="wm" && mm[$1]<2)mm[$1]=2;if(mm[$1]==0)mm[$1]=1;v[$1]++;if(v[$1]==1){nv++;if($5!="NULL")inG++;if($6 !="NULL")coding++;if($6 !="NULL")ct[$6]++;typ[$4]++;gg[$7]++;}}END{for(k in mm)z[mm[k]]++;printf("01\tTotal\t%d\n02\tIn_gene\t%d\n03\tCoding\t%d\n", nv, inG, coding);printf("04\tmm\t%d\n",z[3]);printf("04\twm\t%d\n",z[2]);printf("04\tnot_ww\t%d\n",z[1]);for(k in ct)printf("05\t%s\t%d\n",k,ct[k]);for(k in typ)printf("%02d\t%s\t%d\n",6+length(k),k,typ[k]);}' | $tab_sort > RESULTS/SNV/$MAGIC.snp2genotype.txt

cat tmp/VariantDB.*/snp.genotype.run.* | gawk -F '\t' '/\"/{gsub(/\"/,"",$0);if($8!="Ghs50")next;if($7=="mm" && mm[$1]<3)mm[$1]=3;if($7=="wm" && mm[$1]<2)mm[$1]=2;if(mm[$1]==0)mm[$1]=1;v[$1]++;if(v[$1]==1){nv++;if($5!="NULL")inG++;if($6 !="NULL")coding++;if($6 !="NULL")ct[$6]++;typ[$4]++;gg[$7]++;}}END{for(k in mm)z[mm[k]]++;printf("01\tTotal\t%d\n02\tIn_gene\t%d\n03\tCoding\t%d\n", nv, inG, coding);printf("04\tmm\t%d\n",z[3]);printf("04\twm\t%d\n",z[2]);printf("04\tnot_ww\t%d\n",z[1]);for(k in ct)printf("05\t%s\t%d\n",k,ct[k]);for(k in typ)printf("%02d\t%s\t%d\n",6+length(k),k,typ[k]);}' | $tab_sort > RESULTS/SNV/$MAGIC.snp2genotype.Ghs50.txt


#######################################################
## there are probably two categories of snps
## those that are callable and those that are not
## those which are callable once are probably callable always

# prepare 2 awk commands, so we can submit on the farm
cat <<EOF >  tmp/KL.$MAGIC/mm.awk
{if(\$9=="m/m")printf("%s\t%s\t%s\t%s\t%s\n",\$1,\$2,\$3,\$4,\$5);}
EOF

cat <<EOF >  tmp/KL.$MAGIC/mw.awk
{if(\$9=="m/+" && \$10 >= 50 && \$11 >= 20) printf("%s\t%s\t%s\t%s\t%s\n",\$1,\$2,\$3,\$4,\$5);}
EOF

# grep for SNP seens as m/m at least in one sample
foreach run (`cat MetaDB/$MAGIC/RunList`)
  scripts/submit tmp/KL.$MAGIC/$run/edited.mm  "cat tmp/KL.$MAGIC/$run/s590.multi.countEdited | gawk -F '\t' -f  tmp/KL.$MAGIC/mm.awk | $tab_sort -u > tmp/KL.$MAGIC/$run/edited.mm.list"
end

# grep for SNP seens as m/+ at least in one sample over at least 20 coverage
foreach run (`cat MetaDB/$MAGIC/RunList`)
  scripts/submit tmp/KL.$MAGIC/$run/edited.mm  "cat tmp/KL.$MAGIC/$run/s590.multi.countEdited | gawk -F '\t' -f tmp/KL.$MAGIC/mw.awk | $tab_sort -u > tmp/KL.$MAGIC/$run/edited.mw.list"
end

# collate
scripts/submit wait
cat tmp/KL.$MAGIC/*/edited.mm.list | $tab_sort -u > tmp/KL.$MAGIC/edited.mm.list
cat tmp/KL.$MAGIC/*/edited.mw.list | $tab_sort -u > tmp/KL.$MAGIC/edited.mw.list
wc  tmp/KL.$MAGIC/edited.m?.list

# look for the histo in one person at those positions
set run=Ghs103
cat  tmp/KL.$MAGIC/edited.mm.list ZZZZZ tmp/KL.$MAGIC/$run/s590.multi.countEdited | gawk '/^ZZZZZ/{zz=1;next;}{z=$1 "\t" $2 "\t" $3 "\t" $4 "\t" $5 ;if(zz<1){ok[z]=1;next;}if(ok[z] && $11>=10)printf("%d\t%d\n",$12,$11);}' | bin/histo -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -plot -title "In $run, sites seen m/m in at least one sample" -o tmp/KL.$MAGIC/$run/mm.histo
cat  tmp/KL.$MAGIC/edited.mw.list ZZZZZ tmp/NEWHITS_snp/$run/s590.multi.countEdited | gawk '/^ZZZZZ/{zz=1;next;}{z=$1 "\t" $2 "\t" $3 "\t" $4 "\t" $5 ;if(zz<1){ok[z]=1;next;}if(ok[z] && $11>=10)printf("%d\t%d\n",$12,$11);}' | bin/histo -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -plot -title "In $run, sites seen m/w in at least one sample" -o tmp/KL.$MAGIC/$run/mw.histo
cat   tmp/KL.$MAGIC/edited.mm.list ZZZZZ tmp/NEWHITS_snp/edited.mw.list ZZZZZ tmp/NEWHITS_snp/$run/s590.multi.countEdited | gawk '/^ZZZZZ/{zz++;next;}{z=$1 "\t" $2 "\t" $3 "\t" $4 "\t" $5 ;if(zz<2){ok[z]+=1+zz;next;}if(ok[z]==1 && $11>=10)printf("%d\t%d\n",$12,$11);}' | bin/histo -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -plot -title "In $run, sites seen m/m but never m/+" -o tmp/KL.$MAGIC/$run/mmonly.histo

# look for the histo of 1 (or 100) and do the histo across all 120 people


#######################################################
## try to export a list of confirmed break points
set toto=RESULTS/SNV/$MAGIC.validation.brk.txt
date > $toto
echo "Chrom1\tPos\tchrom2\tPos\tType\tSample\tGenotype\tFrequency of variant\tLeft site coverage\tVariant strand plus\tReference strand plus\tVariant strand minus\tReference strand minus" >> $toto
foreach run (`cat MetaDB/$MAGIC/RunList`)
  cat tmp/NEWHITS_snp/$run/s590.multi.countEdited | gawk '{s=$5;if(substr(s,1,1)!="m" && substr(s,2,1)!=">")print}' | cut -f 1,2,3,4,5,8,9,10,11,12,13,14,15,16,17 | grep -v \- >> $toto.1
end
cat $toto.1 | $tab_sort -k 1,1 -k 2,2n >> $toto
\rm $toto.1



foreach run (`cat MetaDB/$MAGIC/RunList`)

  if (-e COMPARE_SNP/$run.aceview.simple.$MAGIC.u.txt) then
    cat COMPARE_SNP/$run.aceview.simple.$MAGIC.u.txt | gawk '/^#/{next}/^Total/{next;}{m=$10;t=$9;if(t>=4 && 100*m>=20*t){c=substr($1,4);printf("%s..%d.%c>%c\t%d\t%d\n",c,$2,$5,$6,m,t);}}' > toto45

    cat toto45 ZZZZZ tmp/NEWHITS_snp/Ghs103/s590.multi.countEdited_ok | gawk '/^#/{next}/^Total/{next;}/^ZZZZZ/{zz=1;next;}{if(zz==0){ok[$1]=1;next;}z=$1 ".." $2+1 "." $5 ; if(ok[z]==1){p+=$13;m+=$15;nn++;}}END{print "Number of mutant p/n supports in the confimation", p, m, " in ", nn, " SNPS";}'
    cat COMPARE_SNP/$run.aceview.simple.$MAGIC.u.txt | gawk -F '\t' '/^#/{next}/^Total/{next;}{p+=$12;n+=$14;if($9>0)nn++;}END{print "Number of p/n supports in the original mutant counts", p, n, " in ", nn, " SNPS";}' 

    cat toto45 ZZZZZ tmp/NEWHITS_snp/Ghs103/multi.countEdited_ok | gawk '/^#/{next}/^Total/{next;}/^ZZZZZ/{zz=1;next;}{if(zz==0){ok[$1]=1;next;}z=$1 ".." $2+1 "." $5 ; if(ok[z]==1){p+=$14;m+=$16;nn++;}}END{print "Number of wild type p/n supports in the confimation", p, m, " in ", nn, " SNPS";}'
    cat COMPARE_SNP/$run.aceview.simple.$MAGIC.u.txt | gawk -F '\t' '/^#/{next}/^Total/{next;}{p+=$13;n+=$15;if($9>0)nn++;}END{print "Number of p/n supports in the original wild type counts", p, n, " in ", nn, " SNPS";}' 

# histo original
    cat toto45 | cut -f 2,3 | bin/histo -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -plot -o toto45.original
# histo confirmed
    cat toto45 ZZZZZ tmp/NEWHITS_snp/Ghs103/multi.countEdited  | gawk '/^#/{next}/^Total/{next;}/^ZZZZZ/{zz=1;next;}{if(zz==0){ok[$1]=1;next;}z=$1 ".." $2+1 "." $5 ; if(ok[z]==1){printf ("%d\t%d\n",$11,$10);}}' |  bin/histo -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -plot -o toto45.confirmed
     cat toto45 ZZZZZ tmp/NEWHITS_snp/$run/snp.counts | gawk '/^#/{next}/^Total/{next;}/^ZZZZZ/{zz=1;next;}{if(zz==0){ok[$1]=1;w[$1]=$3-$2;m[$1]=$2;next;}if(m[$1]>$4+$3 && ok[$1]>0){printf("m\t%d\tw\t%d\t",m[$1],w[$1]);print;}}'

# histo from the new WM counts
 cat toto45 ZZZZZ tmp/NEWHITS_snp/$run/snp.M.counts tmp/NEWHITS_snp/$run/snp.W.counts | gawk '/^#/{next}/^Total/{next;}/^ZZZZZ/{zz=1;next;}{if(zz<1){ok[$1]=1;next;}z=substr($1,3); if(ok[z]<1)next;nn[z,substr($1,1,1)]=$3+$4;ok[z]=2;}END{for(z in ok)if (ok[z]==2)printf("%d\t%d\n",nn[z,"M"], nn[z,"M"]+nn[z,"W"]);}' |  bin/histo -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -plot -o toto45.confirmed
 
 cat tmp/NEWHITS_snp/$run/snp.M.counts tmp/NEWHITS_snp/$run/snp.W.counts | gawk '/^#/{next}/^Total/{next;}{z=substr($1,3); nn[z,substr($1,1,1)]=$3+$4;ok[z]=2;}END{for(z in ok)if (ok[z]==2 && nn[z,"M"]+nn[z,"W"] >= 100)printf("%d\t%d\n",nn[z,"M"], nn[z,"M"]+nn[z,"W"]);}' |  bin/histo -smooth  -colList MetaDB/$MAGIC/Run2Title.txt -plot -o toto45.confirmed.all
 
  endif

end

goto phaseLoop

###############################################################################################
## s6c: export the SNP reports and tables

phases6c: 
goto phaseLoop
echo "phase s6c  export the SNP reports and tables"

bin/tacembly tmp/VariantDB << EOF > /dev/null
  table -o tmp/VariantDB/$MAGIC.gene2variantFrequency.txt  -f tables/snp.RefSeq.frequency.def
EOF
cp tmp/VariantDB/$MAGIC.gene2variantFrequency.txt  RESULTS/SNV
goto phaseLoop

###############################################################################################
###############################################################################################
#######################################################################################
#######################################################################################
## Length and base content profiles before and after alignment
##################################################################
##################################################################
## Letter histograms, in the aceview transcripts

cat MRNAS/AceView.main_mrnas.fasta | gawk '/^>/{if(z>0)printf("\n");z=1;printf("%s\t",$1);next;}{printf("%s",$1);}'| gawk '{printf("%s\n%s\n",$1,substr($2,1,120));}' | bin/geneelements -letter -title "Main AceView mRNAs, first 100 letters" > letters.mrnas.first100.txt
cat MRNAS/AceView.main_mrnas.fasta | gawk '/^>/{if(z>0)printf("\n");z=1;printf("%s\t",$1);next;}{printf("%s",$1);}'| gawk '{n=length($2);if(n<100)next;printf("%s\n%s\n",$1,substr($2,n-100+1));}' | bin/geneelements -letter  -title "Main AceView mRNAs, last 100 letters" > letters.mrnas.last100.txt

cat MRNAS/AceView.complete5p_mrnas.fasta | gawk '/^>/{if(z>0)printf("\n");z=1;printf("%s\t",$1);next;}{printf("%s",$1);}'| gawk '{printf("%s\n%s\n",$1,substr($2,1,120));}' | bin/geneelements -letter -title "Complete 5p AceView mRNAs, first 100 letters" > letters.complete5p_mrnas.first100.txt
cat MRNAS/AceView.complete3p_mrnas.fasta | gawk '/^>/{if(z>0)printf("\n");z=1;printf("%s\t",$1);next;}{printf("%s",$1);}'| gawk '{n=length($2);if(n<100)next;printf("%s\n%s\n",$1,substr($2,n-100+1));}' | bin/geneelements -letter -title "Complete 3p AceView mRNAs, last 100 letters"> letters.complete3p_mrnas.last100.txt


cat MRNAS/AceView.complete5p_mrnas.fasta | gawk '/^>/{if(z>0)printf("\n");z=1;printf("%s\t",$1);next;}{printf("%s",$1);}'| gawk '{printf("%s\n%s\n",$1,substr($2,1,120));}'  | solid_encoding -fa2ccfa | bin/geneelements -letter -title "Complete 5p AceView mRNAs, first 100 letters" > letters.complete5p_mrnas.colorcoded.first100.txt
cat MRNAS/AceView.complete3p_mrnas.fasta | gawk '/^>/{if(z>0)printf("\n");z=1;printf("%s\t",$1);next;}{printf("%s",$1);}'| gawk '{n=length($2);if(n<100)next;printf("%s\n%s\n",$1,substr($2,n-100+1));}' | solid_encoding -fa2ccfa | bin/geneelements -letter -title "Complete 3p AceView mRNAs, last 100 letters"> letters.complete3p_mrnas.colorcoded.last100.txt

cat MRNAS/AceView.main_mrnas.ccfaD | gawk '{printf("%s\n", substr($1,1,120));}'| bin/geneelements -letter -title "Color transitions in the main AceView transcripts" > letters.mrnas.ccfa.txt

goto phaseLoop

#######################################################################################
#######################################################################################
#######################################################################################
##   export job CPU and statistics"


phasec1:
echo -n 'phase c1: Create a report per lane with the CPU and alignment stats :' 
date

if (! -d RESULTS/Mapping) mkdir RESULTS/Mapping

if ($USEMAGICBLAST == 1) then
  set toto=tmp/MAGICBLAST/cpu_stats.ace
  echo > $toto
  foreach run (`cat MetaDB/$MAGIC/RunList`)
    echo "Ali $run\n-D CPU" >> $toto
    cat tmp/MAGICBLAST/$run/*.jobstats.preace | gawk -F '\t' '/^CPU/{cpu[$4]+=$5;}END{for(c in cpu)printf("CPU %s %d seconds\n",c,cpu[c]);}' | sort -k 2  >> $toto

    cat Fastc/$run/LaneList | gawk /^$run/'{n++;}END{printf("Number_of_lanes %d\n",n);}' >> $toto


    gunzip -c tmp/MAGICBLAST/$run/*.stats.tsf.gz | grep _ALI | bin/tsf -g $run -t $run --sumAll | gawk -F '\t' '/^#/{next}{n=split($1,aa,"__");printf("%s\t%s",aa[1],aa[2]);if(n==2)printf(" %d seq %d tags %d kb_ali\n",$4,$5,$6);}'  >> $toto
    gunzip -c tmp/MAGICBLAST/$run/*.stats.tsf.gz | grep Stranding | bin/tsf -g $run -t $run --sumAll | sort | gawk -F '\t' '/^#/{next}{p=$5;n=$6;a=$7;split($1,aa,"__");printf("%s  %s %.2f  %d plus %d minus %d ambiguous\n",aa[1],aa[2],100.0*p/(n+p),p,n,a);}' | sort -k 1,1 -k 2,2n   >> $toto
    gunzip -c tmp/MAGICBLAST/$run/*.stats.tsf.gz | grep -v _ALI | grep -v Stranding | grep -v N_intron | bin/tsf -g $run -t $run --sumAll | gawk -F '\t' '/^#/{next}{n=split($1,aa,"__");printf("%s",aa[1]);if(n==2)printf(" %s ",aa[2]);for(i=4;i<=NF;i++)printf(" %s ",$i);printf("\n");}' | sort -k 1,1 -k 2,2n   >> $toto
    echo >> $toto
  end


  cat $toto | sed -e 's/^Compatible_pairs_inside_genes/Compatible_pairs_inside_gene/' -e 's/Count_missmatch/Count_mismatch/' | grep -v N_intron > $toto.2
  echo "pparse $toto.2" | bin/tacembly  MetaDB -no_prompt


  goto phaseLoop
endif



if (-e tmp/$MAGIC_COUNT_DIR/$MAGIC.job_statistics.txt) goto phaseLoop

# sync targets2 with jobstats.tcsh

setenv targets2 "any genome seqc av RefSeq UCSC mito rnaGene rrna SpikeIn DNASpikeIn gdecoy EBI smallRNA"
setenv targets2 "any $RNAtargets $DNAtargets"

# suivi de best a123 en colonnes 12 et 13

#set targets2="genome mito gdecoy"
set toto=tmp/job_statistics.txt

date > $toto
set nr=`cat MetaDB/$MAGIC/RunList | gawk '{n++;}END{print n}'`
set nl=`cat MetaDB/$MAGIC/LaneList | gawk '{n++;}END{print n}'`
echo "$MAGIC Job statistics, CPU, exit status, alignment statistics: $nr runs, $nl jobs" >> $toto

echo -n "Job" > $toto
set n123=1
foreach target ($targets2 best a123)
  if ($target == any) continue
  @ n123 = $n123 + 1
  echo -n "\tExit status $target"  >> $toto
end
echo -n "\t\tLane" >> $toto
foreach target ($targets2 best total)
  if ($target == any) continue
  echo -n "\tCPU seconds $target"  >> $toto
end
echo -n "\t\tLane\tSequence with entropy>=16\tSeq entropy<16bp" >> $toto
echo -n "\t% seq entropy<16bp\tLane" >> $toto
foreach target ( $targets2)
  echo -n "\tSeq on $target"  >> $toto
end
echo -n "\t\tLane" >> $toto
foreach target ( $targets2)
  echo -n "\t% Seq on $target"  >> $toto
end
echo -n "\t\tLane\tReads with entropy>=16\treads entropy<16bp" >> $toto
echo -n "\t% reads entropy<16bp\t\tLane" >> $toto
foreach target ( $targets2)
  echo -n "\tReads on $target"  >> $toto
end
echo -n "\t\tLane" >> $toto
foreach target ( $targets2)
  echo -n "\t% reads on $target"  >> $toto
end
echo -n "\t\tLane\tBases with entropy>=16\tbp entropy<16bp" >> $toto
echo -n "\t% bp entropy<16bp\t\tLane" >> $toto
foreach target ( $targets2)
  echo -n "\tbp on $target"  >> $toto
end
echo -n "\t\tLane" >> $toto
foreach target ( $targets2)
  echo -n "\t% bp on $target"  >> $toto
end
echo -n "\t\tLane" >> $toto
foreach target ($targets2 best)
  if ($target == any) continue
  echo -n "\tMemory Mb $target"  >> $toto
end
echo -n "\t\tLane\tSequences aligned on any\tReads aligned on any\tRedundancy" >> $toto
echo  "\tDone" >> $toto

foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -d tmp/$MAGIC_COUNT_DIR/$run) continue
  foreach lane (`cat Fastc/$run/LaneList`)
    if (! -e tmp/$MAGIC_COUNT_DIR/$lane.jobstats) then
      scripts/jobstats.tcsh $run $lane 0 0
    endif
    set nx=`cat tmp/$MAGIC_COUNT_DIR/$lane.a123.err | gawk '/Exit Status/{n=$4;}END{print n;}'`
#echo "$lane ALIGN exit-status=$nx"
    cat tmp/$MAGIC_COUNT_DIR/$lane.jobstats | gawk -F '\t' '{printf("%s",$1);$n123=nx;for(i=2;i<=NF;i++)printf("\t%s",$i);z=$36;if(z<1)z=1;z=$69/z;printf("\t\t%s\t%s\t%s\t%.2f",$1,$36,$69,z);printf("\n");}' nx=$nx n123=$n123>> $toto
  end
  echo ' ' >> $toto
end

cat $toto >! tmp/$MAGIC_COUNT_DIR/$MAGIC.job_statistics.txt
cat $toto | gawk -F '\t' '{ln++;if(ln<4)next;for (i=1;i<=NF;i++){if(i>imax)imax=i;if($i=="0" || 0+$i >0 || 0+$i == -1){ok[i]=1;n[i]+=$i;}}}END{for(i=2;i<=imax;i++){if(ok[i]==1)printf("\t%d",n[i]);else printf("\t-");}printf("\n");}' >>  tmp/$MAGIC_COUNT_DIR/$MAGIC.job_statistics.txt
\cp tmp/$MAGIC_COUNT_DIR/$MAGIC.job_statistics.txt RESULTS/Mapping
\rm $toto
echo "   done, alignment job statistics are summarized in RESULTS/Mapping/$MAGIC.job_statistics.txt"


set toto=RESULTS/Mapping/$MAGIC.error_report.txt
  date > $toto
  foreach run (`cat MetaDB/$MAGIC/RunList`)
    ls -ls tmp/$MAGIC_COUNT_DIR/$run/*.hits.gz | gawk '{if($6 < 1000)print }' >> $toto 
  end
  set nk=`cat tmp/$MAGIC_COUNT_DIR/$MAGIC.job_statistics.txt | head -1 | gawk -F '\t' '{n=19;n1=0;for(i=1;i<=NF;i++)if(n1==0 && $i=="Lane"){n1=i-2;n=i-2;}}END{print n};'`
  cat tmp/$MAGIC_COUNT_DIR/$MAGIC.job_statistics.txt | gawk -F '\t' '{n++;if(n<0)next; if(n==1){for (i=1;i<=nk;i++)title[i]=$i;next;}if(length($1)==0 || NF < 3)next;nn++;lane[nn]=$1;if(n>3)for (i=2;i<=nk;i++){z[nn,i]=$i;if($i==-1)nm[i]++;if($i==0)nok[i]++;if($i>0)bug[nn]=1;}}END{nbug=0;for (i=2;i<=nk;i++){n1ok+=nok[i];if(nok[i]==nn ||  nm[i]==nn){nok[i]=nn;}else nbug++;}printf("Success for %d jobs\n",n1ok) ;if (nbug>0){printf("Job");for (i=2;i<=nk;i++)if(nok[i]!=nn-1)printf("\t%s",title[i]); for (n=1;n<=nn;n++)if(bug[n]==1){n2=0;for (i=2;i<=nk;i++)if(nok[i]!=nn && z[n,i]!=0)n2++;if(n2>0){printf("\n%s",lane[n]);for (i=2;i<=nk;i++){if(nok[i]!=nn)printf("\t%d",z[n,i]);}}}printf("\n");}else printf("NO_ERROR during mapping\n");}' nk=$nk >> $toto
  foreach run (`cat MetaDB/$MAGIC/RunList`)
    grep FATAL tmp/PHITS*/$run/*.err >> $toto
    grep Segmentation tmp/COUNT/$run/*.a123.out >> $toto
  end
goto phaseLoop

#######################################################################################
## Report the tags aligning everywhere and the strandedness

phasec2hack:

  foreach run (`cat MetaDB/$MAGIC/RunList `)
   foreach lane (`cat Fastc/$run/LaneList`)
      if ( -e  tmp/COUNT/$lane.hits.gz && ! -e  tmp/COUNT/$lane.err.hack,done) then
        scripts/submit tmp/COUNT/$lane.hack "scripts/c2.hack.tcsh $run $lane"
      endif
    end
  end


goto phaseLoop

phasec2:
echo -n 'phase c2: Create an ace file per run with the alignment stats and parse it into MetaDB ' 
date

foreach run (`cat MetaDB/$MAGIC/RunList`) 
  set ok=1
  foreach lane (`cat Fastc/$run/LaneList`)
    if ($USEMAGICBLAST == 0 && ! -e  tmp/$MAGIC_COUNT_DIR/$lane.count) then
      set ok=0
      echo "Missing tmp/$MAGIC_COUNT_DIR/$lane.count, please rerun MAGIC ALIGN, only the missing lanes will be recomputed"
    endif
    if ($USEMAGICBLAST == 1 && ! -e  tmp/MAGICBLAST/$lane.stats.tsf.gz) then
      set ok=0
      echo "Missing tmp/MAGICBLAST/$lane.stats.tsf, please rerun MAGIC ALIGN, only the missing lanes will be recomputed"
    endif
  end
  if ($ok == 1 && ! -e tmp/$MAGIC_COUNT_DIR/$run/c2.alistats.ace) then
      scripts/submit tmp/$MAGIC_COUNT_DIR/$run/c2.alistats "scripts/c2.alistats.tcsh $run" 1G
  endif
end

goto phaseLoop

phasec2:
echo -n 'phase c2: Create an ace file per run with the alignment stats and parse it into MetaDB ' 
date

####################################################################################
## Construct the global report on the error rates according to the target and on error types

phasec3:
echo -n 'phase c3: Create an ace file per run with the characteristics of the mismatches (errors or SNPs) and parse it into MetaDB ' 
date

# submit the before and after ali profiles
foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -e  tmp/Profiles/$run/readsAfterAlignment.delta.txt) then
    scripts/submit tmp/Profiles/$run/c3.delta "scripts/c3.delta.profile.tcsh $run"  
  endif
end

######## C3 Import in the MetaDB database the statistics of the alignments
  echo "Preparing the alignment global ace tmp/$MAGIC_COUNT_DIR/alistats.ace"
  if (-e tmp/$MAGIC_COUNT_DIR/alistats.ace) then
    \rm  tmp/$MAGIC_COUNT_DIR/alistats.ace
  endif



  if (! -d tmp/Profiles) mkdir  tmp/Profiles
  foreach run (`cat MetaDB/$MAGIC/RunList`)  
    if (! -d tmp/Profiles/$run) $mkDir  Profiles $run
    if (-e tmp/$MAGIC_COUNT_DIR/$run/c2.alistats.ace) cat tmp/$MAGIC_COUNT_DIR/$run/c2.alistats.ace >>  tmp/$MAGIC_COUNT_DIR/alistats.ace

    echo "Ali $run" >  tmp/Profiles/$run/readsBeforeAlignment.ace
    echo "-D Letter_profile" >>  tmp/Profiles/$run/readsBeforeAlignment.ace

    foreach prefix (f2 f)
      if (-e tmp/Profiles/$run/$prefix.readsBeforeAlignment.1.profile.txt) then
        cat tmp/Profiles/$run/$prefix.readsBeforeAlignment.1.profile.txt | gawk -F '\t' '{n++;if(n<3)next;}{if($1 == 1){if(substr($3,length($3)-1)=="/1")prefix="f1";if(substr($3,length($3)-1)=="/2")prefix="f2"}}{if ($1+0>0)printf("Letter_profile %s %d  %d %d %d %d %d   %d   %d %d %d %d %d\n",prefix, $1,$10,$11,$12,$13,$14,$2,$4,$5,$6,$7,$8);}END{printf("\n\n");}' run=$run prefix=$prefix >>  tmp/Profiles/$run/readsBeforeAlignment.ace
        break
      endif
    end
    if (-e tmp/Profiles/$run/readsBeforeAlignment.ace && ! -e  tmp/Profiles/$run/readsBeforeAlignment.parsed2) then
      cat tmp/Profiles/$run/readsBeforeAlignment.ace >> tmp/$MAGIC_COUNT_DIR/alistats.ace 
      echo "\nAli $run" >> tmp/$MAGIC_COUNT_DIR/alistats.ace 
      cat tmp/Profiles/$run/readsBeforeAlignment.ace | gawk  '/^Letter_profile/{for(i=10;i<=14;i++){n[i]+=$i;}}END{for(i=10;i<=14;i++){nn+=n[i];}printf("\nAli %s\n-D ATGC_kb\nATGC_kb",run); if(nn<1)nn=1;	 for(i=10;i<=14;i++) printf("\t%d",int(1000.0 * n[i]/nn)) ; for(i=10;i<=14;i++) printf("\t%d", n[i]/1000);printf("\n\n") ;}' run=$run >> tmp/$MAGIC_COUNT_DIR/alistats.ace
      touch  tmp/Profiles/$run/readsBeforeAlignment.parsed
    endif

    if (! -d tmp/COUNT/$run) continue
    cat tmp/$MAGIC_COUNT_DIR/$run/*.Venn | gawk '{n[$2 "\t" $3]+= $1;}END{for (k in n) printf("%d\t%s\n",n[k],k);}' | scripts/tab_sort -k 2,2  -k 1,1nr >  tmp/$MAGIC_COUNT_DIR/$run/Venn.$run.txt

  end

  \rm tmp/Unaligned/$run/*.count.count

  echo -n "// " >  tmp/Unaligned/unaligned.ace
  date >>  tmp/Unaligned/unaligned.ace
  foreach run (`cat MetaDB/$MAGIC/RunList`)
    set n=`ls tmp/Unaligned/$run/*.count | wc | gawk '{print $1}'`
    if ($n > 0) then
      cat  tmp/Unaligned/$run/*.count | gawk '/^Sequence_kept/{ns+=$2;next;}/^Tags_kept/{nt+=$2;next;}/^Bases_tags_kept/{nb+=$2;next;}END{printf("Ali %s\nUnaligned %d seq %d tags %d kb\n\n",run,ns,nt,nb/1000);}' run=$run >> tmp/Unaligned/unaligned.ace
    endif
  end

  echo "Parsing the alignment statistics in the MetaDB database"
  if (-e MetaDB/$MAGIC/database/lock.wrm) then
    echo "the MetaDB database is locked i wait 120s"
    sleep 120
    if (-e MetaDB/$MAGIC/database/lock.wrm) then
      echo "it is still locked, I exit"
      exit 1
    endif
  endif

  bin/tacembly MetaDB <<EOF > /dev/null
    read-models
    pparse tmp/$MAGIC_COUNT_DIR/alistats.ace
    pparse tmp/PHITS_bacteria/p5.stats.ace
    pparse tmp/Unaligned/unaligned.ace
    save
    quit
EOF

######### C3 groupLetterProfile start
# This is the most important action of phase c3: bring the group 'ali' objects up to date
# by cumulating (in C) all the statistics of the runs belonging to each group

  echo "Updating the groups stats in MetaDB"
  bin/bestali -groupLetterProfile -db MetaDB -project $MAGIC
  bin/bestali -addQualityFactors  -db MetaDB -project $MAGIC

######### C3 groupLetterProfile end 

if (! -d RESULTS/Mapping) mkdir RESULTS/Mapping

######### C3_AliProfiles start
# export in tmp/$MAGIC_COUNT_DIR/AliProfiles very detailled quality controls for each group
# these statistics are interesting when tuning the code to deal with a new sequencing platorm
# or when analysing a totally new kind of experimental protocol

if ($MAGIC_COUNT_DIR != COUNT) goto phaseLoop

if (! -d  tmp/$MAGIC_COUNT_DIR/AliProfiles) mkdir tmp/$MAGIC_COUNT_DIR/AliProfiles

foreach group (`cat MetaDB/$MAGIC/GroupList`)
  if (-e tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_profiles.txt) \rm  tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_profiles.txt
  if (-e tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_quality.txt) \rm  tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_quality.txt
end

echo "// " > _r
foreach group (`cat MetaDB/$MAGIC/RunList MetaDB/$MAGIC/GroupList`)
  # 2014_08_20 a hack because we change the file names from ali_profile to ali_quality
  if (-e tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_profiles.txt && ! -e tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_quality.txt) then
    mv  tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_profiles.txt  tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_quality.txt
  endif
  if (! -e tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_quality.txt) then
  cat <<EOF >> _r
    find Run $group
    query Is_run && project == $MAGIC
    spush
    undo
    query Is_group ; COUNT {>runs project == $MAGIC} > 0 AND COUNT {>runs NOT project == $MAGIC} == 0
    sor
    spop
    spush
    follow ali
    sor
    spop
    show -a -f tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ace
EOF
  endif
end

  cat <<EOF >> _r
    query find run project == $MAGIC ;>ali
    show -a -f MetaDB/$MAGIC/ali.ace
EOF


  bin/tacembly MetaDB < _r  > /dev/null
  \rm _r

echo "export the quality profiles in RESULTS/Mapping/Quality_profiles. This operation may take 30 minutes"

if (! -d RESULTS/Mapping/Quality_profiles) mkdir RESULTS/Mapping/Quality_profiles
foreach group (`cat MetaDB/$MAGIC/RunList MetaDB/$MAGIC/GroupList`)

  if (! -e tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_quality.txt) then
    scripts/c3.ali_profiles.tcsh   $MAGIC.$group tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ace tmp/$MAGIC_COUNT_DIR/AliProfiles/$group
  endif
  if (-e tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_quality.txt) then
    \cp tmp/$MAGIC_COUNT_DIR/AliProfiles/$group.ali_quality.txt RESULTS/Mapping/Quality_profiles/$MAGIC.$group.ali_quality.txt 
  endif
end

phasec3aaaa:

######## C3 count unaligned // backwards compatibility, now integrated in a123
foreach run (`cat MetaDB/$MAGIC/RunList`)
  foreach lane (`cat Fastc/$run/LaneList`)
    if (-e tmp/Unaligned/$lane.fastc.gz && ! -e tmp/Unaligned/$lane.count) then
      scripts/submit  tmp/Unaligned/$lane "bin/dna2dna -i tmp/Unaligned/$lane.fastc.gz -I fastc -O count -o tmp/Unaligned/$lane" MULTICORE
    endif
  end
end


######### C3_AliProfiles end

goto phaseLoop

foreach run (`cat MetaDB/$MAGIC/RunList`)
  foreach lane (`cat Fastc/$run/LaneList`)
      if (-e tmp/$MAGIC_COUNT_DIR/$lane.hits.gz && ! -e tmp/$MAGIC_COUNT_DIR/$lane.seqc_by_target.done) then
        scripts/submit tmp/$MAGIC_COUNT_DIR/$lane.seqc_by_target "scripts/c3.seqc_by_target.tcsh $run $lane"
      endif
  end
end

goto phaseLoop

#######################################################################################
## strandedness profile
phasec4:

echo -n "phase c4: Create global report per run and group with the strandedness "
date

if (! -d RESULTS/Mapping) mkdir RESULTS/Mapping

# prepare a query
cat  <<EOF  > _q
  parse  MetaDB/$MAGIC/groups2runid.ace
  save
  query find run project=$MAGIC  && ! Private
  follow ali
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.Error_position.txt -f tables/Error_position.def
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.Error_type.txt -f tables/Error_type.def
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.Quality_profile.txt -f tables/c4.Quality_profile.def
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.Ambiguous_position.txt -f tables/Ambiguous_position.def
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.Unicity.av.txt -f tables/Unicity.def ET_av
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.Unicity.UCSC.txt -f tables/Unicity.def LT_UCSC
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.Unicity.genome.txt -f tables/Unicity.def Z_genome
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.Unicity.any.txt -f tables/Unicity.def any
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.Rejected.txt -f tables/Rejected.def
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.h_Ali_any.txt -f tables/c4.bpPerTag.def  any
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.h_Ali_av.txt -f tables/c4.bpPerTag.def  ET_av
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.h_Ali_UCSC.txt -f tables/c4.bpPerTag.def  LT_UCSC
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.av_ali.txt -f tables/c4.av_ali.def 
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.h_Ali_genome.txt -f tables/c4.bpPerTag.def  Z_genome
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.Cumulated_ambiguous.txt -f tables/c4.Cumulated_ambiguous.def
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.first_base.txt -f tables/c4.first_base.def
  undo
  table -active -o tmp/$MAGIC_COUNT_DIR/toto.c4.last_base.txt -f tables/c4.last_base.def
EOF

# extract the data as a table from the MetaDB acedb database
bin/tacembly MetaDB < _q > /dev/null
\rm _q

# export a nice document 
if (! -e ZZZZZ) then
  echo ZZZZZ > ZZZZZ
endif

# export a nice document 

set toto = tmp/$MAGIC_COUNT_DIR/$MAGIC.mismatch_position_in_read.txt
echo $toto

set n=`cat MetaDB/$MAGIC/RunList | gawk '{n++}END{print n}'`
if ($n <= 200) then
  echo -n "# $toto : " > $toto
  date >> $toto

  echo  "Position of the mismatches, in read coordinates (i.e. in cycles) at their best unique alignment in $MAGIC :" >> $toto
  echo "The first table (below) shows the raw number of mismatches for each base position in the reads." >> $toto
  echo "The next table (to the right) shows the percentage of mismatches per base position." >> $toto
  echo "This allows comparing positions and amplitude of eventual mismatches spikes or defects across runs." >> $toto
  echo "The third table shows the a posteriori quality per base position, -10 Log10(number of mismatches with the reference" >> $toto
  echo "per base aligned at each position), 10 is poor, 30 is excellent. This curve is a direct measure of the quality of the bases" >> $toto
  echo "in the run, and is used in Magic in replacement of the FastQ quality factor." >> $toto
  echo "This single small quality file per run and per base position is a more accurate representation of" >> $toto
  echo "the base quality, it ameliorates the SNV calls and as a side bonus minimizes CPU, memory and disk usage" >> $toto
  echo "Note that the third table, which gives the quality, is not the log of the second table, which is a profile normalized at 100%%." >> $toto
endif

set mydate=`date`
set mytitle="Position of the mismatches, in read coordinates (i.e. in cycles) at their best unique alignment in $MAGIC" 

  echo -n "# $toto : " > $toto
  date >> $toto

cat MetaDB/$MAGIC/GroupListSorted MetaDB/$MAGIC/RunListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.Error_position.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.Quality_profile.txt | gawk  -F '\t' -f scripts/c4.Error_position.awk mydate="$mydate" mytitle="$mytitle" | sed -e 's/_/ /g' >> $toto

if (! -d RESULTS/Mismatches) mkdir RESULTS/Mismatches

set n=`cat MetaDB/$MAGIC/RunList | gawk '{n++}END{print n}'`
if ($n>200) then
  cat $toto | gawk -F '\t' '{nn++;if (nn==1){j=0;for(i=1;i<=NF;i++){if(length($i)>1){jj[j++]=i;}}}jj[3]=NF+1;for (i=jj[kk-1];i<jj[kk];i++)printf("%s\t",$i);printf("\n");}' kk=1 >   RESULTS/Mismatches/$MAGIC.Mismatch_count_per_sequencing_cycle.txt
  cat $toto | gawk -F '\t' '{nn++;if (nn==1){j=0;for(i=1;i<=NF;i++){if(length($i)>1){jj[j++]=i;}}}jj[3]=NF+1;for (i=jj[kk-1];i<jj[kk];i++)printf("%s\t",$i);printf("\n");}' kk=2 >   RESULTS/Mismatches/$MAGIC.Mismatch_percentage_per_cycle.txt
  cat $toto | gawk -F '\t' '{nn++;if (nn==1){j=0;for(i=1;i<=NF;i++){if(length($i)>1){jj[j++]=i;}}}jj[3]=NF+1;for (i=jj[kk-1];i<jj[kk];i++)printf("%s\t",$i);printf("\n");}' kk=3 >   RESULTS/Mismatches/$MAGIC.Mismatch_per_cycle_per_Mb_aligned.txt
else
  \cp $toto RESULTS/Mismatches
endif

# export a nice document 

set toto = tmp/$MAGIC_COUNT_DIR/$MAGIC.N_or_SolidErrorCorrected_position_in_read.txt
echo $toto
  echo -n "# $toto : " > $toto
  date >> $toto


echo  "Position of the ambiguous bases, N or error corrected transitions in SOLiD, in read coordinates at their best unique alignment in $MAGIC" >> $toto
cat MetaDB/$MAGIC/GroupListSorted MetaDB/$MAGIC/RunsListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.Ambiguous_position.txt | gawk  -F '\t' -f scripts/c4.Error_position.awk | sed -e 's/_/ /g' >> $toto

\cp $toto RESULTS/Mismatches

# export a nice document 

# the error type file might have not been available at start of the program
\cp tmp/$MAGIC_COUNT_DIR/toto.c4.Error_type.txt  MetaDB/$MAGIC/Error_type.txt

set toto = tmp/$MAGIC_COUNT_DIR/$MAGIC.mismatch_type_and_prevalence.txt
echo $toto
if (-e $toto) \rm $toto

set mydate=`date`
set mytitle="Distribution of mismatches in best unique alignment in $MAGIC" 
  echo -n "# $toto : " > $toto
  date >> $toto

cat MetaDB/$MAGIC/GroupListSorted MetaDB/$MAGIC/RunsListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ  tmp/$MAGIC_COUNT_DIR/toto.c4.Error_type.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.Cumulated_ambiguous.txt | gawk  -F '\t' -f scripts/c4.Error_type.awk mydate="$mydate" mytitle="$mytitle" | sed -e 's/_/ /g' >> $toto

set n=`cat MetaDB/$MAGIC/RunList | gawk '{n++}END{print n}'`
if ($n>200) then
  cat $toto | gawk -F '\t' '{nn++;if (nn==1){j=0;for(i=1;i<=NF;i++){if(length($i)>1){jj[j++]=i;}}}jj[4]=NF+1;for (i=jj[kk-1];i<jj[kk];i++)printf("%s\t",$i);printf("\n");}' kk=1 >   RESULTS/Mismatches/$MAGIC.Mismatch_counts_per_type.txt
  cat $toto | gawk -F '\t' '{nn++;if (nn==1){j=0;for(i=1;i<=NF;i++){if(length($i)>1){jj[j++]=i;}}}jj[4]=NF+1;for (i=jj[kk-1];i<jj[kk];i++)printf("%s\t",$i);printf("\n");}' kk=2 >   RESULTS/Mismatches/$MAGIC.Mismatch_per_kb_aligned_per_type.txt
  cat $toto | gawk -F '\t' '{nn++;if (nn==1){j=0;for(i=1;i<=NF;i++){if(length($i)>1){jj[j++]=i;}}}jj[4]=NF+1;for (i=jj[kk-1];i<jj[kk];i++)printf("%s\t",$i);printf("\n");}' kk=3 >   RESULTS/Mismatches/$MAGIC.Percent_of_each_mismatch_type.txt
  cat $toto | gawk -F '\t' '{nn++;if (nn==1){j=0;for(i=1;i<=NF;i++){if(length($i)>1){jj[j++]=i;}}}jj[4]=NF+1;for (i=jj[kk-1];i<jj[kk];i++)printf("%s\t",$i);printf("\n");}' kk=4 >   RESULTS/Mismatches/$MAGIC.Percent_of_sliding_insertion_deletion.txt
else
  \cp $toto RESULTS/Mismatches
endif

# export a nice document 

if (0) then
  set toto = tmp/$MAGIC_COUNT_DIR/$MAGIC.average_length_aligned_per_target.txt
  echo $toto
  echo -n "# $toto : " > $toto
  date >> $toto

  cat <<EOF >> $toto
Average length (nt) aligned per target in $MAGIC
Average length aligned per target in nucleotide (table to the left) and in percentage of the length of the read, after clipping adaptors and barcodes (table to the right). 
Average lengths are reported only if more than 1000 reads are aligned. 
This is seldom the case for the imaginary decoy genome, used as a mapping specificity control, yet the histogram of length aligned on this target is used to set the thresholds for filtering alignments of low quality. 
Ribosomal RNA (rRNA) is encoded in the genome in many copies with slight sequence variations, hence when we align the archetypic rRNA precursor, usually from RefSeq or GenBank, the quality of the alignments is not expected to be perfect.  
Similarly, the small RNA targets, including tRNA, miRNA and other small RNAs often delineates only the mature product, and the actual genes are larger than the gene models. Hence usually only a fraction of the read lengths align on these targets. This is also true for the imperfect but useful human RNA genes from UCSC.
EOF

  if ($species == hs && $Strategy == RNA_seq) then
  cat <<EOF >> $toto
The human RNA genes (from UCSC 'RNA genes' track at UCSC) are too short relative to reality, leading to shorter
aligned length on this imperfect but useful target.
EOF
endif

  cat MetaDB/$MAGIC/GroupListSorted MetaDB/$MAGIC/RunsListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.av_ali.txt | gawk  -F '\t' -f scripts/c4.av_ali.awk | sed -e 's/_/ /g' >> $toto

  \cp $toto RESULTS/Mapping
endif

# export a nice document 

set toto = tmp/$MAGIC_COUNT_DIR/$MAGIC.mapping_unicity.txt
echo $toto
  echo -n "# $toto : " > $toto
  date >> $toto

set mydate=`date`
echo "Mapping unicities or multiplicities, i.e. number of reads with 1 to $maxHit alignments," >> $toto
echo "in number and % reads, successively on the best target, then the genome, then the AveView transcriptome." >> $toto

echo >> $toto
echo >> $toto

echo  "Number of reads with exactly 1 to $maxHit alignments on best target at best score in $MAGIC" >> $toto
echo  "Reads with $maxHit or more best alignments are discarded" >> $toto
cat MetaDB/$MAGIC/GroupListSorted MetaDB/$MAGIC/RunsListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.h_Ali_any.txt  ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.Rejected.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.Unicity.any.txt | gawk  -F '\t' -f scripts/c4.unicity.awk  type=site tt="in best target" | sed -e 's/_/ /g' >> $toto

\cp $toto RESULTS/Mapping

# export a nice document 

foreach target ($targets)
  if ($target == genome) then

echo >> $toto
echo >> $toto

set n="NA" ;
echo  "Number of reads with exactly 1 to 9 alignments on the genome at best score in $MAGIC" >> $toto
echo  "Reads with 10 or more best alignments are discarded" >> $toto
cat   MetaDB/$MAGIC/GroupListSorted MetaDB/$MAGIC/RunsListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.h_Ali_genome.txt  ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.Rejected.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.Unicity.genome.txt | gawk  -F '\t' -f scripts/c4.unicity.awk type=site  tt="in genome" | sed -e 's/_/ /g' >> $toto

  endif
end

# export a nice document 

foreach target ($targets)
  if ($target == av) then

echo >> $toto
echo >> $toto

echo  "Number of reads with exactly 1 to 9 alignments on AceView transcripts at best score in $MAGIC" >> $toto
echo  "Reads with 10 or more best alignments are discarded" >> $toto
cat  MetaDB/$MAGIC/GroupListSorted MetaDB/$MAGIC/RunsListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.h_Ali_av.txt  ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.Rejected.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.Unicity.av.txt | gawk  -F '\t' -f scripts/c4.unicity.awk  type=gene  tt="in aceview" | sed -e 's/_/ /g' >> $toto

  endif
end

\cp $toto RESULTS/Mapping

# export a nice document 

set toto = tmp/$MAGIC_COUNT_DIR/$MAGIC.first_last_base_aligned.txt
echo $toto
  echo -n "### $toto : " > $toto
  date >> $toto

echo  "Histogram of reads according to the position of the first and last base aligned," >> $toto
echo  "This measures the frequency of errors in the first and last few bases" >> $toto
echo  "as any mismatch closer than 8 bases in RNA-seq or 4 in Genome seq from the edges"  >> $toto
echo  "of the alignment is clipped." >> $toto

cat MetaDB/$MAGIC/GroupListSorted MetaDB/$MAGIC/RunsListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.first_base.txt ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c4.last_base.txt | gawk -f scripts/c4.first_last_base.awk | sed -e 's/_/ /g' >> $toto

\cp $toto RESULTS/Mapping

# done

# export a nice document 

set toto = tmp/$MAGIC_COUNT_DIR/$MAGIC.Reads_per_target.Venn.txt
echo $toto
  echo -n "# $toto : " > $toto
  date >> $toto

echo  "Multi Venn diagram of the number of reads mapping in all targets" >> $toto
echo  "Singlet indicates the number of read mapped in each target" >> $toto
echo  "Doublet indicates the number of read mapped in any pair of targets" >> $toto
echo  "Triplet indicates the number of read mapped in any triplet targets" >> $toto
echo  "Details indicates the non redundant number of read mapped in any set targets" >> $toto

echo > $toto.1
foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -e  tmp/$MAGIC_COUNT_DIR/$run/Venn.$run.txt) continue 
  echo "RUN\t$run"  >> $toto.1
  cat tmp/$MAGIC_COUNT_DIR/$run/Venn.$run.txt >> $toto.1
end

cat MetaDB/$MAGIC/RunListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ $toto.1 | gawk -F '\t' -f scripts/c4.venn_target.awk >> $toto

cat $toto | head -6 > $toto.2
cat $toto | tail -n +7 | scripts/transpose > $toto.3
head -5  $toto.3 > $toto.4
tail -n +6 $toto.3 | $tab_sort -k 2,2nr >> $toto.4
# tail -n +6 $toto.3  >> $toto.4
cat $toto.4 | scripts/transpose >> $toto.2

cat  $toto.2 | sed -e 's/_/ /g' >  $toto
\rm $toto.[1234]
\cp $toto RESULTS/Mapping
\rm tmp/$MAGIC_COUNT_DIR/toto.c4.*

goto phaseLoop

#######################################################################################
## hierarchic mapping report 

if (0) then
# a script to count the reads overlapping the introns, the input table is given by danielle
  cat ~/REPORTS/test_title.txt | gawk -F '\t' '{printf("%s",$0);if($5+0>0){x=$1-$2-$3-$4;n=$1;if(n<1)n=1;printf("\t%d\t%.2f\n",x,100*x/n);}else printf("\n");}' > ~/REPORTS/test_title.results.txt
endif

phasec5:

echo -n "phase c5: Create global report per run with the statistics of the alignments on the different targets "
date

if (! -d RESULTS/Mapping) mkdir RESULTS/Mapping

foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (-e Fastc/$run/Max_probe_length) then
    set ln=`cat Fastc/$run/Max_probe_length`
    if ($n == 0) \rm  Fastc/$run/Max_probe_length
  endif
  if (! -e Fastc/$run/Max_probe_length) then
    cat Fastc/$run/*.count  | gawk '/^Max_probe_length/{x=$2;if(n<x)n=x;}END{printf("%d\n",n);}' >  Fastc/$run/Max_probe_length
  endif
end


# prepare the profiles now in parallel so that phase c6 can collect them sequentially very fast
if (! -d tmp/Profiles) mkdir tmp/Profiles
foreach run (`cat MetaDB/$MAGIC/RunList`)
  continue
  if (! -d tmp/Profiles/$run) $mkDir Profiles $run
  if (! -e tmp/Profiles/$run/c5.profile.done) then
    scripts/submit tmp/Profiles/$run/c5.profile "scripts/c5.profiles.tcsh $run"
  endif
end

# prepare a query
cat  <<EOF  > _q
  parse  MetaDB/$MAGIC/groups2runid.ace
  save
  query find Run  project == $MAGIC && ! Private
  follow ali  
  show -a -f  tmp/$MAGIC_COUNT_DIR/toto.c5.readFate.ace
  query find Run  project == $MAGIC && ! Private
  follow ali  
  show -a -f  tmp/$MAGIC_COUNT_DIR/toto.c5.ATGC.ace ATGC_kb
  show -a -f  tmp/$MAGIC_COUNT_DIR/toto.c5.Accepted.ace Accepted
  show -a -f  tmp/$MAGIC_COUNT_DIR/toto.c5.ve.ace Entry_adaptor_clipping
  show -a -f  tmp/$MAGIC_COUNT_DIR/toto.c5.vx.ace Exit_adaptor_clipping
  show -a -f  tmp/$MAGIC_COUNT_DIR/toto.c5.h_Ali.ace h_Ali
  show -a -f  tmp/$MAGIC_COUNT_DIR/toto.c5.nh_Ali.ace nh_Ali
  show -a -f  tmp/$MAGIC_COUNT_DIR/toto.c5.Pair_fate.ace Pair_fate
  show -a -f  tmp/$MAGIC_COUNT_DIR/toto.c5.cpu.ace Computer_ressource
EOF

# extract the data as a table from the MetaDB acedb database
bin/tacembly MetaDB < _q > /dev/null
\rm _q

# export a nice document 

if (-e MetaDB/$MAGIC/TargetList) \rm MetaDB/$MAGIC/TargetList
  foreach t ($targets)
    echo $t >> MetaDB/$MAGIC/TargetList
  end
endif


# export a nice document on pair mapping


if (1 && -e MetaDB/$MAGIC/RunPairedList) then
  set toto=tmp/$MAGIC_COUNT_DIR/$MAGIC.pair_stats.txt
  echo -n "# $toto : " > $toto.1
  date >> $toto.1
  echo "Paired end mapping $MAGIC" >> $toto.1
  cat <<EOF >> $toto.1
In paired end sequencing, the 2 ends of each fragment are sequenced, yielding two reads.
Considering all reads aligning at their best score, the paired-end  information is used to
retain preferentially the target positions where both ends map in a consistent way,
therefore decreasing the number of ambiguous mappings. It is also used to phase SNVs.
The mapped fragments can then be partitioned into compatible pairs, non-compatible pairs 
and pairs with a single read aligned. In a compatible pair, the 2 reads face each other and span 
a segment no longer than 3 times the median insert length. For RNA-seq fragments best mapping 
on the genome, the limit for compatible pairs is arbitrarily set at 1 Mb, to allow for 
occasional long introns. The compatible pairs are then partitioned in subcategories
according to the targets. Compatible gene extensions refer to fragment for which one end
maps into an annotated gene and the other in a compatible way on the nearby genome.
EOF
  
  if (-e $toto.2) \rm $toto.2

  cat $toto.1 > $toto
  cat MetaDB/$MAGIC/RunListSorted  ZZZZZ  ZZZZZ MetaDB/$MAGIC/RunPrivateList  ZZZZZ MetaDB/$MAGIC/gtitle.txt  ZZZZZ tmp/$MAGIC_COUNT_DIR/toto.c5.Pair_fate.ace | sed -e 's/Aligned_pairs/Aligned_fragments/' | gawk -f  scripts/c5.pair_stats.awk  | sed -e 's/\tNULL/\t/g'  > $toto.1
  cat $toto.1 | gawk '/^#/{print}' | sed  -e 's/Orphans_Any/Single read aligned/g'  -e 's/Orphans_1/Single read uniquely aligned/g'   -e 's/Orphans.multi/Single read multiply aligned/g' -e 's/_/ /g' | sed -e 's/\tNULL/\t/g'  >> $toto
  cat $toto.1 | gawk '/^#/{next;}{print}' | sed  -e 's/mito/mitochondria/g'   -e 's/spikeIn/spike in/g'   -e 's/Orphans_Any/Single read aligned/g'  -e 's/Orphans_1/Pairs with a single read uniquely aligned/g'  -e 's/Orphans multi/Pairs with a single read alignedin 2 to 9 sites/g' -e 's/Too_distant_on_genome/Reads too distant on genome (> 1 Mb)/g'  -e 's/_/ /g' | sed -e 's/\tNULL/\t/g'   >> $toto
  \rm $toto.1
  echo $toto
  \cp $toto RESULTS/Mapping

  \rm $toto.*
endif


if (0 && -d tmp/ALIa) then
  set toto=tmp/ALIa/$MAGIC.barcode_stats.contami.txt
  echo -n "# $toto : " > $toto
  date >> $toto
  echo "Bar codes present in the best alignments to the mitochondria in $MAGIC" >> $toto

  date > $toto.1
  foreach run (`cat MetaDB/$MAGIC/RunList`)
    if (-e  tmp/ALIa/$run/a5.barcode.stats) then
      echo "RUN $run" >> $toto.1
      cat tmp/ALIa/$run/a5.barcode.contami.stats | grep -v N >> $toto.1
    endif
  end
  cat  MetaDB/$MAGIC/RunListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ $toto.1 | gawk -f  scripts/c5.barcode_stats.awk  | sed -e 's/\tNULL/\t/g' >> $toto
  echo $toto
  \cp $toto RESULTS
endif

if (! -d tmp/Profiles) mkdir tmp/Profiles
if (-d tmp/$MAGIC_COUNT_DIR) then
  set toto=tmp/$MAGIC_COUNT_DIR/$MAGIC.insert_size_from_pairs.Histo.txt
  echo toto > $toto.1
  foreach run (`cat MetaDB/$MAGIC/RunListSorted`)
    foreach run2 (`cat MetaDB/$MAGIC/RunPairedList`)
      if ($run != $run2) continue
      if (! -d tmp/Profiles/$run)  mkdir tmp/Profiles/$run
      if (! -e tmp/Profiles/$run/runPairHisto.txt) then
        if (-e tmp/$MAGIC_COUNT_DIR/$run/runPairHisto.txt) then
          \cp tmp/$MAGIC_COUNT_DIR/$run/runPairHisto.txt tmp/Profiles/$run/runPairHisto.txt
        else
          if (-e tmp/Profiles/$run/toto)  \rm tmp/Profiles/$run/toto
          foreach lib (`cat MetaDB/$MAGIC/r2sublib | gawk -F '\t' '{if($1 == gr) print $2;}' gr=$run | sort -u `)
            cat tmp/COUNT/$lib/*.pairStats >> tmp/Profiles/$run/toto
          end
          cat tmp/Profiles/$run/toto | gawk '/^#Number/{for(i=2;i<NF;i++)n[i]+=$i;if(NF > imax)imax=NF;}END{printf("Insert_length_in_pairs\t%s",r);for(i=4;i<=imax;i++)printf("\t%d",n[i]);printf("\n");}' r=$run >  tmp/Profiles/$run/runPairHisto.txt
          \rm  tmp/Profiles/$run/toto
        endif
      endif
      if (-e tmp/Profiles/$run/runPairHisto.txt) then
        cat tmp/Profiles/$run/runPairHisto.txt  | sed -e 's/\tNULL/\t/g' >> $toto.1
      endif
    end
  end
  echo -n "### $toto : " > $toto
  date >>  $toto
  echo "## Histogram of insert length (bp) measured as the distance between the first aligned base of the /1 and /2 reads in  compatible pairs" >> $toto
  cat  MetaDB/$MAGIC/RunListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ $toto.1 | gawk -f scripts/c5.pair_length_histo.awk  | sed -e 's/\tNULL/\t/g' >>  $toto
  \rm $toto.1
  echo $toto
  \cp $toto RESULTS/Mapping
endif
 
echo "// " > tmp/$MAGIC_COUNT_DIR/$MAGIC.Fragment_length.ace
foreach run (`cat MetaDB/$MAGIC/RunPairedList`)
  if (! -e  tmp/$MAGIC_COUNT_DIR/$run/runPairHisto.txt || -e tmp/$MAGIC_COUNT_DIR/$run/Fragment_length.fixed) continue
  echo "$run ZZZZZ ZZZZZ" > toto.$$
  cat toto.$$ ZZZZZ tmp/$MAGIC_COUNT_DIR/$run/runPairHisto.txt |  gawk -f scripts/c5.pair_length_histo.awk | head -100 | gawk -F '\t' '/^Run/{run=$2;next;}/^Average/{av=$2;next;}/^Median/{median=$2;next;}/^Position/{mode=$2;next;}/^Low 1/{z1=$2;next;}/^Low 5/{z5=$2;next;}/^High 95/{z95=$2;next;}/^High 99/{z99=$2;next;}END{printf("Ali %s\nFragment_length_1 %s\nFragment_length_5 %s\nFragment_length_mode %s\nFragment_length_median %s\nFragment_length_average %s\nFragment_length_95 %s\nFragment_length_99 %s\n\n",run,z1,z5,mode,median,av,z95,z99);}' >> tmp/$MAGIC_COUNT_DIR/$MAGIC.Fragment_length.ace
  \rm toto.$$
end
bin/tacembly MetaDB <<EOF
  read-models
  pparse  tmp/$MAGIC_COUNT_DIR/$MAGIC.Fragment_length.ace
  save
  quit
EOF
\rm tmp/$MAGIC_COUNT_DIR/toto.c5.*

goto phaseLoop

## Venn diagram per target

set toto=tmp/$MAGIC_COUNT_DIR/$MAGIC.global_venn.txt
  echo -n "# $toto : " > $toto
  date >> $toto
  echo "# Paired end mapping $MAGIC" >> $toto

foreach nog (G NoG)
  echo "# Venn$nog  diagram " | tee -a  $toto
  echo  "Run\tJust AceView\tJust RefSeq\tAv RefSeq\tJust EBI\tAv EBI\tRefSeq EBI\tAv RefSeq EBI\tJust HINV\tAv HINV\tRefSEq HINV\tAv RefSeq HINV\tEBI HINV\tAv EBI HINV\tRefSeq EBI HINV\tAv RefSeq EBI HINV" | tee -a  $toto

if (-e toto78.$$) \rm toto78.$$
touch toto78.$$
  foreach run (`cat MetaDB/$MAGIC/RunList`)
      \rm toto77.$$; touch toto77.$$
      foreach lane (`cat Fastc/$run/LaneList`)
        if( -e tmp/$MAGIC_COUNT_DIR/$lane.global) then
          cat  tmp/$MAGIC_COUNT_DIR/$lane.global | gawk "/^Venn$nog/{print}" >> toto77.$$
        endif
      end
      echo -n "$run" >> toto78.$$
      cat toto77.$$ |  gawk '{for(i=2;i<=16;i++)n[i-1]+=$i;}END{for(i=1;i<=15;i++)printf("\t%d",n[i]);}' >> toto78.$$
      echo >>   toto78.$$
  end
  cat toto78.$$ >> $toto  

  cat toto78.$$ | gawk '{for(i=3;i<=17;i++)n[i]+=$i;}END{printf("Any);for(i=3;i<=17;i++)printf("\t%d",n[i]);printf("\n");}' >> $toto
  echo >>   $toto
  echo >>   $toto
  echo >>   $toto
  \rm  toto78.$$  toto77.$$

end

cat  $toto
\cp  $toto RESULTS

#########################################################################
##  Prefix and suffix histograms

phasec6:

if (! -d RESULTS/Mapping) mkdir RESULTS/Mapping

echo -n "phase c6: Create per group a profile of the alignment prefixes and suffixes, on the reads and on the best target "
date

foreach run (`cat MetaDB/$MAGIC/RunList`) 
  if (! -e tmp/Profiles/$run/c5.profile.done) then
    echo "missing file tmp/Profiles/$run/c5.profile.done, please run phase c5 then re-run phase c6"
    goto phaseLoop
  endif
end
echo "starting multi_profiles"
if (! -d RESULTS/ATGC_sequence_profiles) mkdir RESULTS/ATGC_sequence_profiles

foreach type (readsBeforeAlignment prefix suffix target_prefix target_suffix clipped_adaptor unaligned)
  echo "starting multi_profiles $type"
  if (-e  tmp/Profiles/$MAGIC.$type.1.txt) \rm tmp/Profiles/$MAGIC.$type.*.txt
  set nmulti=1
  set nruns=1
  if (-e RESULTS/ATGC_sequence_profiles/$MAGIC.$type.multi_profile.$nmulti.txt) \rm RESULTS/ATGC_sequence_profiles/$MAGIC.$type.multi_profile.$nmulti.txt
  touch RESULTS/ATGC_sequence_profiles/$MAGIC.$type.multi_profile.$nmulti.txt
  foreach run (`cat MetaDB/$MAGIC/RunListSorted`)
     set nlines=`cat RESULTS/ATGC_sequence_profiles/$MAGIC.$type.multi_profile.$nmulti.txt | gawk '{n++}END{print n}'`
     if ($nlines >= 2000) then
        cat  tmp/Profiles/$MAGIC.$type.$nmulti.txt  >> RESULTS/ATGC_sequence_profiles/$MAGIC.$type.multi_profile.$nmulti.txt
        @ nmulti = $nmulti + 1
        set nruns=1
     endif
     if ($nruns == 1)  then
        echo -n "#  RESULTS/ATGC_sequence_profiles/$MAGIC.$type.multi_profile.$nmulti.txt : " > RESULTS/ATGC_sequence_profiles/$MAGIC.$type.multi_profile.$nmulti.txt
        date >>  RESULTS/ATGC_sequence_profiles/$MAGIC.$type.multi_profile.$nmulti.txt
     else
        echo "\n\n\n\n"  >> tmp/Profiles/$MAGIC.$type.$nmulti.txt
     endif
     echo "RUN\t$run"  >> tmp/Profiles/$MAGIC.$type.$nmulti.txt
     echo "\tPosition\tNumber of reads\t$run\tA\tT\tG\tC\tN\tRun\t%A\t%T\t%G\t%C\t%N"  >> tmp/Profiles/$MAGIC.$type.$nmulti.txt
     if ($nruns == 1) set nruns=2

     foreach prefix (f f1 f2)
        if ($type == unaligned && -e  tmp/Profiles/$run/$prefix.$type.profile.txt) then
          \cp tmp/Profiles/$run/$prefix.$type.profile.txt  tmp/Profiles/$run/$prefix.$type.1.profile.txt
        endif
     foreach readNumber (0 1 2)
       if (! -e  Fastc/$run/LaneList) continue
       set n=`cat Fastc/$run/LaneList | sed -e "s/$run\///" | gawk '{if (NF >= 1) {split($1,aa,".");if(aa[1]==p)n++}}END{print n+0}' p=$prefix`
       if ($n == 0)  continue

        if (! -e tmp/Profiles/$run/$prefix.$type.$readNumber.profile.txt) continue
        if ($nruns == 3 && $readNumber == 2 )  echo "\n\n\n\n"  >> tmp/Profiles/$MAGIC.$type.$nmulti.txt

        if ($nruns == 2)  then
           cat  tmp/Profiles/$run/$prefix.$type.$readNumber.profile.txt | head -1 | gawk -F '\t' '{split($1,aa,":");printf("# %s\n", aa[2]);}' >> RESULTS/ATGC_sequence_profiles/$MAGIC.$type.multi_profile.$nmulti.txt
           set nruns=3
        endif
        
          set xMax=`cat  tmp/Profiles/$run/$prefix.$type.$readNumber.profile.txt | gawk '{n++;x=0+$1;if(n> 4 && x>xMax)xMax=x;}END{print xMax}'`
# echo "BB $type $run xMax=$xMax"
          cat  tmp/Profiles/$run/$prefix.$type.$readNumber.profile.txt   | gawk -F '\t' '/^#/{next;}{n=$1+0;if(n<1)next;if(NF<12)next;r="";if(n==1 && rN > 1){printf("\n\n");r="read " rN ;}if(n>4 && (($1 % 10 == 0 && $1 < xMax - 6) || ($1 == xMax+999)) )r=n;if(n>mx)next;if(0)printf("%s", r);for(i=1;i<=2;i++)printf("\t%s",$i);if (1)printf("\t%s", r);for(i=4;i<=8;i++)printf("\t%s",$i);if (1) printf("\t%s", r);for(i=10;i<=14;i++){z=$i;if(0+$1 > 0 && $4+$5+$6+$7<100)z=0;printf("\t%s",z);}printf("\n");}' run=$run mx=353 xMax=$xMax rN=$readNumber >>  tmp/Profiles/$MAGIC.$type.$nmulti.txt

      end
      end
   
   end  

   cat  tmp/Profiles/$MAGIC.$type.$nmulti.txt  >> RESULTS/ATGC_sequence_profiles/$MAGIC.$type.multi_profile.$nmulti.txt
end

### Create a profile before/after for all runs

set toto=RESULTS/Mapping/$MAGIC.Aligned_length.histo.txt
if (-e $toto) \rm $toto

foreach delta (100 30 1 )
  set first=1
  foreach run (`cat MetaDB/$MAGIC/RunsListSorted`)
    set ffB=tmp/Profiles/$run/readsBeforeAlignment.delta.txt
    set ffA=tmp/Profiles/$run/readsAfterAlignment.delta.txt
    set isLib=`cat MetaDB/$MAGIC/r2sublib | gawk '{if($1== run) ok=1;}END{print ok+0}' run=$run`
    set ok=0
    set n=0
    if ($isLib == 0) then
      if (-e $ffA) set ok=1
      if (-e Fastc/$run/Max_probe_length) set n=`cat Fastc/$run/Max_probe_length`
    endif
    if ($isLib == 1) then
      set ffA = " "
      set ffB = " "
      set n=0
      foreach sublib (`cat MetaDB/$MAGIC/r2sublib | gawk '{if($1 == run) print $2;}' run=$run`)
	set n1=0
        if (-e Fastc/$sublib/Max_probe_length) set n1=`cat Fastc/$sublib/Max_probe_length`
        if ($n1 > $n) set n=$n1
        if (-e tmp/Profiles/$sublib/readsAfterAlignment.delta.txt) then
          set ok=1
          set ffA = "$ffA  tmp/Profiles/$sublib/readsAfterAlignment.delta.txt  "
          set ffB = "$ffB  tmp/Profiles/$sublib/readsBeforeAlignment.delta.txt "
        endif
      end
    endif  
    if ($ok == 0) continue    
    if ($n < 300) continue 
    if ($n <= 300 && $delta > 1) continue
    if ($n <= 2000 && $delta > 30) continue
    if ($n >= 1000 && $delta < 10) continue
    if ($first == 1) then
      set first=0
      echo -n "\n\t\t\t" >> $toto
      echo $delta | gawk '{for (i=0;i<=300 ;i++)printf("\t%d",i*delta);}END{printf("\n");}' delta=$delta >> $toto
    endif
    echo -n  "L:$run" >> $toto
    cat MetaDB/$MAGIC/gtitle.txt | gawk -F '\t' '{gsub(/\"/,"",$0);gsub(/NULL/,"",$0);if($1==run)printf("\t%s\t%s\t%s",$2,$6,$13) ;}' run=$run >> $toto
    cat $ffB | gawk -F '\t' '/^#/{next}{k=int(($2+delta - 1)/delta) ; if(k>300)k=300;nn[k] += $3;if(k>kMax)kMax =k;}END{for (i = 0 ; i <= kMax ; i++) printf ("\t%d", nn[i]+0);printf("\n");}' delta=$delta >> $toto
    echo -n "A:$run" >> $toto
    cat MetaDB/$MAGIC/gtitle.txt | gawk -F '\t' '{gsub(/\"/,"",$0);gsub(/NULL/,"",$0);if($1==run)printf("\t%s\t%s\t%s",$2,$6,$13) ;}' run=$run >> $toto
    cat $ffA | gawk -F '\t' '/^#/{next}{k=int(($2+delta - 1)/delta) ; if(k>300)k=300;nn[k] += $3;if(k>kMax)kMax =k;}END{for (i = 0 ; i <= kMax ; i++) printf ("\t%d", nn[i]+0);printf("\n");}' delta=$delta >> $toto
  end
  echo "\n\n\n\n\n\n\n\n\n" >> $toto
end

cat $toto | scripts/transpose > $toto.1
echo -n "### $MAGIC.Aligned_length.histo : " > $toto
date >> $toto
echo "\n\n" >> $toto
cat $toto.1 >> $toto

goto phaseLoop

## identical reads geometry

foreach lane (`cat MetaDB/$MAGIC/LaneList`)
  if (! -e  Fastc/$lane.illumina_redundancy_geometry.txt) then
    scripts/submit Fastc/$lane "gunzip -c Fastc/$lane.id.gz | gawk -F '\t' -f scripts/illumina_redundancy_geometry.awk lane=$lane > Fastc/$lane.illumina_redundancy_geometry.txt"
  endif
end
cat Fastc/*/*.illumina_redundancy_geometry.txt | gawk -F '\t' '/radial/{n=0;next;}{n++;if(n==2){for(i=1;i<=32;i++)rr[i]+=$i;}}END{for(i=1;i<=32;i++)printf("\t%d",rr[i]);printf("\n");}'
## centralize the counts (1 second): in global $2:$3 == seqs:tags

goto phaseLoop

#######################################################################################
##  Export a general quality control table  Prefix and suffix histograms

phasec7:
phaseqc:
echo -n "phase c7: Export a general quality control table called RESULTS/Mapping/$MAGIC.Data_Summary_and_QC.runs.txt"
date 
if (! -d RESULTS/Mapping) mkdir RESULTS/Mapping

if (! -e tmp/c7.fix.done) then

  bin/tacembly MetaDB << EOF
    query find ali aligned_pairs
    show -a -f tmp/toto.aligned_pairs.ace  aligned_pairs 
    query find ali ali
    show -a -f tmp/$MAGIC.tati.ace ali
EOF
 cat  tmp/$MAGIC.tati.ace  | gawk '/h_Ali/{b=$7;t=$5;if (t==0)t=1;n=$9;n1=int(.5+1000000*b/t)/1000;$9=n1;}{print}' >  tmp/$MAGIC.tati.ace2

  if (-e  tmp/toto.aligned_pairs.ace) then
    cat  tmp/toto.aligned_pairs.ace | sed -e 's/Aligned_pairs/Aligned_fragments/' >  tmp/toto.aligned_pairs.ace2
    bin/tacembly MetaDB << EOF
      parse  MetaDB/$MAGIC/groups2runid.ace
      query find ali aligned_pairs
      edit -D  aligned_pairs
      read-models  
      parse  tmp/toto.aligned_pairs.ace2
      parse  tmp/$MAGIC.tati.ace2
      save
      quit
EOF 
    \rm tmp/toto.aligned_pairs.ace tmp/toto.aligned_pairs.ace2
  endif   
  \rm  tmp/$MAGIC.tati.ace  tmp/$MAGIC.tati.ace2
  touch  tmp/c7.fix.done
endif

  bin/bestali -groupLetterProfile -db MetaDB -project $MAGIC

#########  'import the stranding'
#########  was in C3, should be transferred in the bin/bestali -groupLetterProfile C code
# do it backwards so that last is best

bin/tacembly MetaDB <<EOF 
  query find project IS  $MAGIC ; > run ; > ali ; Stranding
  table -o MetaDB/$MAGIC/stranding.txt -active -f tables/c3.observed_strandedness.def
EOF
touch MetaDB/$MAGIC/stranding.txt
cat MetaDB/$MAGIC/stranding.txt |                                                                                                                                                                gawk '/^"/{r=$1;t=$5 "\t" $7 "\t" $8 "\t" $9;s=$10/1000000.0;if(best[r]<200)best[r]=1000;d=s;if(100-s<d)d=100-s;if(s>=50 && s-50<d)d=s-50;if(s<50 && 50-s<d)d=50-s;d+=300;if(d<best[r]){best[r]=d;tt[r]=t;ss[r]=s;}}END{for(r in best)printf("%s\t%s\t%f\n",r,tt[r],ss[r]);}' > MetaDB/$MAGIC/stranding.txt2
cat MetaDB/$MAGIC/stranding.txt | grep -v rrna |  grep -v smallRNA | grep -v mito  | grep -v chloro  | grep -v transposon | grep -v virus | grep -v bacteria  | grep -v Spike | grep -v genome | gawk '/^"/{r=$1;t=$5 "\t" $7 "\t" $8 "\t" $9;s=$10/1000000.0;if(best[r]<200)best[r]=1000;d=s;if(100-s<d)d=100-s;if(s>=50 && s-50<d)d=s-50;if(s<50 && 50-s<d)d=50-s;d+=300;if(d<best[r]){best[r]=d;tt[r]=t;ss[r]=s;}}END{for(r in best)printf("%s\t%s\t%f\n",r,tt[r],ss[r]);}' >> MetaDB/$MAGIC/stranding.txt2
cat MetaDB/$MAGIC/stranding.txt2 | gawk -F '\t' '{gsub(/NULL/,"0",$0);split($2,aa,"_");split(aa[2],bb,".");printf ("Run %s\nObserved_strandedness_in_ns_mapping %s %f %s plus %s minus %s ambiguous\n\n", $1,bb[1],$6,$3,$4,$5);}' > MetaDB/$MAGIC/stranding.ace

echo "pparse MetaDB/$MAGIC/stranding.ace" | bin/tacembly MetaDB -no_prompt

######## 
  echo " bin/qcsummary -db MetaDB -project $MAGIC -runType 2   > RESULTS/Mapping/$MAGIC.Data_Summary_and_QC.runs.txt"

  set n=`cat MetaDB/$MAGIC/RunSublibrary_ofList | wc -l`
  if ($n > 0) then
    bin/qcsummary -db MetaDB -project $MAGIC -runType 1  > RESULTS/Mapping/$MAGIC.Data_Summary_and_QC.sublibs.txt
  endif
  if ($n > 1) then
    bin/table_histo -i RESULTS/Mapping/$MAGIC.Data_Summary_and_QC.sublibs.txt > RESULTS/Mapping/$MAGIC.Data_Summary_and_QC.sublibs.histo.txt
  endif

  set n=`cat MetaDB/$MAGIC/RunsList | wc -l`
  if ($n > 0) then
    bin/qcsummary -db MetaDB -project $MAGIC -runType 2   > RESULTS/Mapping/$MAGIC.Data_Summary_and_QC.runs.txt
  endif
  if ($n > 1) then
    bin/table_histo -i RESULTS/Mapping/$MAGIC.Data_Summary_and_QC.runs.txt > RESULTS/Mapping/$MAGIC.Data_Summary_and_QC.runs.histo.txt
  endif

  set n=`cat MetaDB/$MAGIC/GroupList | wc -l`
  if ($n > 0) then
    bin/qcsummary -db MetaDB -project $MAGIC  -runType 3   > RESULTS/Mapping/$MAGIC.Data_Summary_and_QC.groups.txt
  endif
  if ($n > 1) then
    bin/table_histo -i RESULTS/Mapping/$MAGIC.Data_Summary_and_QC.groups.txt > RESULTS/Mapping/$MAGIC.Data_Summary_and_QC.groups.histo.txt
  endif

  bin/qcsummary -db MetaDB -export Tt  -project $MAGIC > RESULTS/Mapping/$MAGIC.telomere_summary.txt

goto phaseLoop

bin/tacembly MetaDB << EOF
  query find run  project == $MAGIC AND sublibraries
  select -o SublibsFiles.txt -title stitle, T, subT, fil, fLine from r in @, stitle in r->sorting_title, T in r->title, sub in r->sublibraries, subT in sub->title, fil in sub=>file[2], fLine in sub=>first_line TITLE stitle:Sort,T:Library,subT:Sublibrary,fil:File name,fLine:First line
EOF
cat  SublibsFiles.txt | gawk '/^#/{print;next;}{if(old && $1!=old)printf("\n");old=$1;print;}' | sed -e 's/DATA/SEQC2/g'  -e 's/NULL/-/g'  >  RESULTS/SubLibsFileLocations.txt
bin/tacembly MetaDB << EOF
  query find run project == $MAGIC ; CLASS Runs
  select -o LibsFiles.txt -title stitle, T,fil, fLine,subT from r in @, stitle in r->sorting_title, T in r->title, sub in r->sublibraries,subT in sub->title, fil in r=>file[2], fLine in r=>first_line TITLE stitle:Sort,T:Library,subT:Sublibrary,fil:File name,fLine:First line
EOF
 cat LibsFiles.txt | gawk -F '\t' '{if($1 != old){printf("%s\t%s\n",u,substr(z,2));z="";}z=z "; " $5;old=$1;u=$1"\t"$2"\t"$3"\t"$4;}END{printf("%s\t%s\n",u,z);}'  | gawk -F '\t' '{printf("%s\t%s\t%s\t%s\t%s\n",$1,$2,$5,$3,$4);}' | gawk '/^#/{print;next;}{split($1,aa,"__");if(old && aa[1]!=old)printf("\n");old=aa[1];print;}' | sed -e 's/DATA/SEQC2/g' -e 's/NULL/-/g'  >  RESULTS/LibsFileLocations.txt
###############################################################
###############################################################
## phase ma1: Micro arrays

phasema1:
 echo -n "Phase ma1 Micro array alignments "
 date

if (! -d  MicroArray/Oligos/Fasta) goto phaseLoop
set ici2=`pwd`
pushd MicroArray/Oligos/Fasta
ls | gawk '/count/{next;}{gsub(/\.fasta\.gz/,"",$1);print $1;}' > ../../MaList
popd
if (! -d MicroArray/Hits) mkdir MicroArray/Hits

foreach pp (`cat MicroArray/MaList`)
  if (! -e  MicroArray/Hits/$pp.hits.gz) then
    scripts/submit MicroArray/Hits/$pp "scripts/ma1.align.tcsh $pp"
  endif
end

echo "The HITS file could be copied to the AceView ftp site ftp/ncbi_37_Aug10.human.genes/MicroArrayProbeMapping"
goto phaseLoop

###############################################################
## phase ma2: Micro-Array sponge the support for each probe in each run, per chrom and per strand

phasema2:
 echo -n "Phase ma2 Micro-Array sponge the support for each probe in each run, per chrom and per strand"
 date

# construct the sponge file
if (! -d MicroArray/Sponge) mkdir MicroArray/Sponge
foreach pp (`cat MicroArray/MaList`)
  if (! -e MicroArray/Sponge/$pp/sponge.gz) then
    if (! -d MicroArray/Sponge/$pp)  mkdir MicroArray/Sponge/$pp
    gunzip -c MicroArray/Hits/$pp.genome.hits.gz | gawk -F '\t' '/Z_genome/{p=substr($1,1,length($1)-1);if($10==1){nn[p]++;if(nn[p]>1)next;i=index(p,"_at");pp=p;if(i>0)pp=substr(p,1,i+2);printf("%s\t%s\t%s\t%s\t%s\n",pp,p,$11,$12,$13); }}'  | gzip > MicroArray/Sponge/$pp/sponge.gz
  endif
end

gunzip -c MicroArray/Sponge/$pp/sponge.gz | gawk -F '\t' '{if(length($3)<4)printf("Probe %s\nIntMap %s %d %d\n\n",$1,$3,$4,$5);}' > MicroArray/Sponge/$pp/sponge.intmap.ace


# Out of 43291 AGLuK NeuroBlastoma probes
#  42742 are well mapped probes, 40167 map uniquelly to genome, 36706 best map uniquelly to genome
# histo of aligned length
# gunzip -c AGLuK.genome.hits.gz  | gawk -F '\t' '{p=$1;if(p==old)next;old=p;n[$5]++;}END{for(k in n) print k,n[k];}' | $tab_sort -k 1n

# For each run, sponge collate the support of each probe/probeset
foreach pp (`cat MicroArray/MaList`)
  if (! -e MicroArray/Sponge/$pp/sponge.gz) continue
  foreach run (`cat MetaDB/$MAGIC/RunList`) 
    if (! -d MicroArray/Sponge/$pp/$run) mkdir MicroArray/Sponge/$pp/$run
    foreach chrom ($chromSetAll)
      foreach fr (f r)
        if (! -e tmp/WIGGLERUN/$run/$chrom/R.chrom.u.$fr.BF.gz) continue
        if (! -e MicroArray/Sponge/$pp/$run/$chrom.u.f.sponged.txt) then
          scripts/submit MicroArray/Sponge/$pp/$run/$run.$chrom.u.$fr.sponged "bin/geneelements -sponge 1 -spongeFile MicroArray/Sponge/$pp/sponge.gz  -wiggle tmp/WIGGLERUN/$run/$chrom/R.chrom.u.$fr.BF.gz  -sxxChromosome $chrom  -run $run -o MicroArray/Sponge/$pp/$run/$run.$chrom.u.$fr.sponged.txt"
        endif
      end
    end
  end
end

goto phaseLoop
   
###############################################################
## phase ma3: Micro-Array compute the probe and probe-set index genome wide

phasema3:
 echo -n "Phase ma3 Micro-Array compute the probe and probe-set index genome wide"
 date

 if (! -d MicroArray/ProbeCount) mkdir MicroArray/ProbeCount
# by probeset (2013_04: removed the measure of Length from the covered part, which was logically silly)
 foreach pp (Affy.Rat230_2)
   if (-e MicroArray/Sponge/$pp/sponge.gz) then
     cat MicroArray/Sponge/$pp/*/*.sponged.txt | gawk -F '\t' '/^#/{zz++;next}{if(zz<2)next;}{run=$2;ps=$3;p=$4;rr[run]=1;ps2p[p,ps]++;pps[ps]=1;n[run,ps]+=$12;bp[run,ps]+=$11;}END{for(ps in pps){printf("Gene %s\n",ps);for(r in rr){if(n[r,ps]>0)printf("Run_u %s 0 %.1f seq %.1f tags %.3f kb\n",r, n[r,ps],n[r,ps],bp[r,ps]/1000) ;}printf("\n");}}' | gzip >  MicroArray/ProbeCount/$pp.probeset.ace.gz
   endif
 end
# by probe 

if (! -d  MicroArray/ProbeCount) mkdir  MicroArray/ProbeCount

 if (! -d tmp/GENEINDEX) mkdir tmp/GENEINDEX
 scripts/geneindex.tcsh snp4 000

 foreach pp (`cat MicroArray/MaList`)
   if (-e MicroArray/Sponge/$pp/sponge.gz) then
     cat MicroArray/Sponge/$pp/*/*.sponged.txt | gawk -F '\t' '/^#/{zz++;next}{if(zz<2)next;}{run=$2;ps=$3;ps=$4;rr[run]=1;pps[ps]=1;n[run,ps]+=$12;bp[run,ps]+=$11;}END{for(ps in pps){printf("Gene %s\n",ps);for(r in rr){if(n[r,ps]>0)printf("Run_u %s 0 %.1f seq %.1f tags %.3f kb\n",r, n[r,ps],n[r,ps],bp[r,ps]/1000) ;}printf("\n");}}' | gzip >  MicroArray/ProbeCount/$pp.probe.ace.gz
   endif
 end

# export an index table for these micro arrays

# number of kb aligned in the genomic wiggle in which the sponge was evaluated
cat tmp/SPONGE/Rhs794/Total.*.1.ns.EBI_seqc.txt | gawk '{if($6=="Genome")n+=$9}END{print n/1000}'

 if (! -d RESULTS/MicroArray) mkdir RESULTS/MicroArray
 foreach pp (`cat MicroArray/MaList`)
   \cp  tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace MicroArray/ProbeCount/$pp.probeset_info.ace
   if (-e MicroArray/ProbeCount/$pp.probeset.ace.gz) then
       gunzip -c MicroArray/Sponge/$pp/sponge.gz | gawk -F '\t' '{if(index($3,"|")>0)next;j=index($2,"_at");printf("Gene %s\n\n",substr($2,1,j+2));}' >>  MicroArray/ProbeCount/$pp.probeset_info.ace
      bin/geneindex -pA -deepGene MicroArray/ProbeCount/$pp.probeset.ace.gz -gzo -o RESULTS/MicroArray/$pp.probeset -runList MetaDB/$MAGIC/RunListSorted -runAce MicroArray/ProbeCount/$pp.probeset_info.ace -malus 2.4 -correl -compare  -export ait
   endif
   if (-e MicroArray/ProbeCount/$pp.probe.ace.gz) then
      \cp  tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace MicroArray/ProbeCount/$pp.probe_info.ace
      gunzip -c MicroArray/Sponge/$pp/sponge.gz | gawk -F '\t' '{if(index($3,"|")>0)next;printf("Gene %s\nIntMap %s %s %s\n\n",$2,$3,$4,$5);}' >>  MicroArray/ProbeCount/$pp.probe_info.ace
      mkdir  RESULTS/Expression/unique/RNA_at_$pp RESULTS/Expression/unique/RNA_at_$pp/Diff_genes

      set myace=MicroArray/ProbeCount/$pp.probe.ace.gz
# optional rescaling is tuned by hand for NB/AGLuK in  in README.OTHER_PIPELINE, detrimental 2013_11_13
      if (0 && -e MicroArray/ProbeCount/$pp.probe.rescaled.ace.gz) then
        set myace="MicroArray/ProbeCount/$pp.probe.rescaled.ace.gz -keepIndex"
      endif
      if (-e MicroArray/Hits/$pp.probe2gene.reverseImage.hack.ace) cat MicroArray/Hits/$pp.probe2gene.reverseImage.hack.ace >> tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace  
      if (-e MicroArray/Hits/$pp.av.probe2mrna.unique.txt) cat MicroArray/Hits/$pp.av.probe2mrna.unique.txt | gawk -F '\t' '{printf("Gene %s\nFrom_transcript %s\n\n",$1,$2);}'  >> tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace  

      if (-e MicroArray/Hits/$pp.probe2chrom.unique.txt) cat  MicroArray/Hits/$pp.probe2chrom.unique.txt | gawk -F '\t' '{split($2,aa,":");gsub(/chr/,"",aa[1]);split(aa[2],bb,"-");printf("Gene %s\nIntMap %s %s %s\n\n",$1,aa[1],bb[1],bb[2]);}' >> tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace
      gunzip -c  MicroArray/Sponge/$pp/sponge.gz | gawk -F '\t' '{printf("Gene %s\nIntMap %s %s %s\n\n",$2,$3,$4,$5);}' >> tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace

      bin/geneindex -MA 60 -u -deepGene $myace -export ati -gzo -o RESULTS/Expression/unique/RNA_at_$pp/$MAGIC.RNA_at_$pp.MA.u -runList MetaDB/$MAGIC/RunListSorted -runAce tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace -compare -iterate -exportDiffGenes -target_class any
      mv  RESULTS/Expression/unique/RNA_at_$pp/*.diffGenes.*.txt RESULTS/Expression/unique/RNA_at_$pp/Diff_genes
   endif
 end

goto phaseLoop

# rescaled data are constructed in OTHER_PIPELINES/README.OTHER_PIPELINES
# use the rescaled original counts
foreach th (0 8 10 12 14)
  foreach rsc (80 100)
   bin/geneindex -MA 60 -u -deepGene OTHER_PIPELINES/MicroArray/$pp.rescaled$rsc.ace -export ati -gzo -o RESULTS/MicroArray/$MAGIC.$pp'_'rescaled$rsc.newindex_$th.probe -runList MetaDB/$MAGIC/RunListSorted -runAce tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace -compare -iterate -exportDiffGenes -keepIndex  -threshold $th &
  end
end

foreach th (0 8 10 12 14)
   bin/geneindex -deepGene tmp/GENEINDEX/$MAGIC.av.GENE.u.ace -export ati -gzo -o RESULTS/MicroArray/$MAGIC.av_newindex_$th -runList MetaDB/$MAGIC/RunListSorted -runAce tmp/GENEINDEX/$MAGIC.snp.SNP.info.ace  -compare -iterate -exportDiffGenes  -u -threshold $th -pA &
end

foreach th1 (12)
  foreach th2 (0 8 10 12)
    foreach rsc (80)
      if (1) scripts/ma4.MOA_analysis.tcsh av_newindex_$th1 AGLuK_rescaled$rsc.newindex_$th2 &
    end
    if (1) scripts/ma4.MOA_analysis.tcsh av_newindex_$th1 AGLuK_at_newindex_$th2 &
  end
end
 
## histo
cat RESULTS/MicroArray/NB_DEG.AGLuK_at_newindex_0.probe.ace | gawk '/^Gene /{gsub(/\"/,"",$2);print $2}' > titi.AGLuK.list

cat titi.AGLuK.list ZZZZZ RESULTS/MicroArray/NB_DEG.AGLuK_at_newindex_0.probe.ace | gawk 'BEGIN{print "0\n400";}/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;next;}}/^Gene/{ok1=0;gsub(/\"/,"",$2);ok1=ok[$2];next;}/^Run_U/{if(ok1<1)next;n++;z=$3;if(z<-900)next;print 5*int(2*z);}' | bin/histo -plot -w 80 -plain -o RESULTS/NB_DEG.AGLuK_at_newindex_0.selected.histo

foreach rsc (66 80 100)
  cat MetaDB/$MAGIC/RunList ZZZZZ  titi.AGLuK.list ZZZZZ OTHER_PIPELINES/$pp'_rescaled'$rsc.ace  | gawk 'BEGIN{print "0\n400";}/^ZZZZZ/{zz++;next;}{if(zz<1){runok[$1]=1;next;}}{if(zz<2){ok[$1]=1;next;}}/^Gene/{ok1=0;gsub(/\"/,"",$2);ok1=ok[$2];next;}/^Run_U/{if(ok1<1)next;gsub(/\"/,"",$0);if(runok[$2]<1)next;n++;z=$3;print 5*int(2*z);}' | bin/histo -plot -w 80 -plain -o RESULTS/NB_DEG.AGLuK_rescaled$rsc.newindex_0.selected.histo
end

gunzip -c MetaDB/$MAGIC/Results/NB_DEG.av.GENE.nu.ace.gz | gawk 'BEGIN{print "0\n400";}/^Run_nU/{n++;z=$3;print 5*int(2*z);}' | bin/histo -plot -w 80 -plain -o RESULTS/NB_DEG.av.newindex.histo

## correlation probe_rescaled probe_at
cat RESULTS/MicroArray/NB_DEG.AGLuK_at_newindex_0.probe.ace ZZZZZ OTHER_PIPELINES/$pp'_rescaled80.ace' | gawk  'BEGIN{zz=0;}/^ZZZZZ/{zz++;next;}{gsub(/\"/,"",$0);}/^Gene/{p=$2;pp[p]=1;ppz[p,zz]=1;next;}/^Run_/{r=$2;if(0 && $11=="NA")next; if(r=="Rhs884" ){z=$3;rr[r]=1;prz[p,r,0+zz]=z;if(0)print "####",p,r,z, zz;}}END{for(p in pp)for(r in rr)if((prz[p,r,0]+0>0 && prz[p,r,1]+0>0))printf("%s:%s\t%.1f\t%.1f\t%.1f\n",p,r,0+prz[p,r,0],0+prz[p,r,1],0+prz[p,r,0]+prz[p,r,1]);}' | $tab_sort -k 4nr >  RESULTS/AGLuK_at__AGLuK_rescaled80.Rhs884.txt



 cat PB.training.txt | gawk -F '\t' '/^Probe/{for(i=2;i<=NF;i++)nam[i]=$i;next;}{printf("Gene Rat230_2:%s\n",$1);for(i=2;i<=NF;i++)printf("Micro_array %s %.2f\n",nam[i],$i);printf("\n");}' > PB.training.ace

../../bin/geneindex -deep PB.training.ace -o tutu -correl -runAce PB.run2sample.ace
cat pierre.any.txt | gawk '/Value/{print;next;}{printf("%.1f\t%d\n",$1/10,$2);}' > ../../RESULTS/pierre.any.histo.txt

cat pierre.any.txt | gawk '/Value/{print;next;}{printf("%.1f\t%d\n",$1/10,$2);}' > ../../RESULTS/pierre.any.histo.txt

# gunzip -c ../../RESULTS/MicroArray/Affy.Rat230_2.probe.ace.gz | gawk '/^Gene/{ok=1;next;}/^Run_U/{if(ok==1 && $3 > 0)print int(10*$3+.4) }' | bin/histo -plain -plot -o rna_at_probeset -w 120

setenv ici2 `pwd`
../../bin/tacembly ../../MetaDB <<EOF 
  table -o sample2run2cel2runid.txt -f $ici2/sample2run2cel2runid.def 
EOF

cat sample2run2cel2runid.txt | gawk -F '\t' '/^\"/{gsub(/\"/,"",$0);n=split($3,aa," ");cel=aa[n];printf("%s\t%s\n",$2,cel);}' > run2cel0.txt
cat sample2run2cel2runid.txt | gawk -F '\t' '/^\"/{gsub(/\"/,"",$0);n=split($3,aa," ");cel=aa[n];printf("%sPB\t%s\n",$2,cel);}' > run2cel.txt

echo ZZZZZ > ZZZZZ
cat run2cel.txt | grep -v CELb > run2cel1.txt
cat run2cel.txt | grep  CELb | sed -e 's/CELb/CEL/' > run2cel2.txt
cat  run2cel1.txt ZZZZZ PB.training.ace | gawk '/ZZZZZ/{zz=1;next;}{if(zz<1){rr[$2]=$1;next;}}/^Micro_array/{printf("Micro_array %s %.2f\n", rr[$2],$3);next;}{print}' > PB.training.ace2 
cat  run2cel2.txt ZZZZZ PB.training.ace | gawk '/ZZZZZ/{zz=1;next;}{if(zz<1){rr[$2]=$1;next;}}/^Micro_array/{if (rr[$2])printf("Micro_array %s %.2f\n", rr[$2],$3);next;}{print}' >> PB.training.ace2 

cat  PB.training.ace2  | sed -e 's/PB//g' >  PB.training.ace3

cat   run2cel.txt run2celBis.txt | gawk '{printf ("Run %s\nSample %s\n\n",$1,$2);}' > info.ace

  cat  ../../MetaDB/$MAGIC/RunListSortedBySample | sed -e 's/\"//g'  | gawk '/^Rrn/{printf("%sPB\n",$1);}'  > toto.PB.runList
 ../../bin/geneindex -deepGene PB.training.ace2  -o PB.training.renamed -runList toto.PB.runList -runAce info.ace -export i -MA 60 -gzo


cat ../../MetaDB/$MAGIC/runs.ace > toto32
cat   run2cel.txt run2celBis.txt | gawk '{printf ("Run %s\nSample %s\n\n",$1,$2);}'   | sed -e 's/PB//g' >> toto32
 ../../bin/geneindex -deepGene PB.training.ace3  -o PB.training.Rrn -runList ../../MetaDB/$MAGIC/RunListSortedBySample -runAce toto32  -export i -MA 60 -gzo -correl

### 2012_12_05 analyse the test set in micro array
### to get the correspondance between the A1 A42 numbers and the Rrn we use Affy2NGS_36ratsTest.txt from the Excell of Scott and the run->sample
cat Affy2NGS_36ratsTest.txt ZZZZZ sample2runTestSet.txt | gawk '/^ZZZZZ/{zz=1;next;}{if(zz<1){rat2id[$2]=$1;next;}gsub(/\"/,"",$0);split($1,aa,"_");printf("%s\t%s\t%s\t%s\n",$2,$1,aa[2],rat2id[aa[2]]);}' | gawk -F '\t' '{if(length($4)>0)printf("%s\t%s\n",$4,$1);}' | $tab_sort -r | gawk '{r[$1]=$2;}END{for(k in r)printf("%s\t%s\n",k,r[k]);}' | $tab_sort > testSetAffyId2run
### add by hand 6 more identifications to the controls testSetAffyId2run.manual



### foreach affy probeset reexport the affy Mass5 index using the corresponding run names
cat testSetAffyId2run testSetAffyId2run.manual ZZZZZ SEQC_TGMX_Test_set-MAS5_normalized-masked_Affy_IDs-correction.from_sharePoint.2012_08_10.txt | gawk -F '\t' '/^ZZZZZ/{zz=1;next;}{if(zz<1){id2run[$1]=$2;next;}}/^Probe/{for(i=2;i<=NF;i++){r=id2run[$i];ii2r[i]=r;}next;}{printf("Gene \"Rat230_2:%s\"\n",$1);for(i=2;i<=NF;i++)if(ii2r[i])printf("Micro_array %s %s\n",ii2r[i],$i);printf("\n");}' > PB.test.ace3


### group the test and the training set, and shift all values to be in the ususal tange with a max around 12
cat  PB.training.ace3 PB.test.ace3 > PB.TandT.ace3
# the 4.6 shift exactly super imposes the climb from the right (high end) in Affy and RNA_seq
cat PB.TandT.ace3 | gawk '/^Micro_array/{printf("%s %s %.2f\n",$1,$2,4.6+$3);next;}{print}'  > PB.TandT.shifted.ace3

mkdir AnalysisAffyTestSet AnalysisAffyShifted
cd AnalysisAffyShifted
echo ZZZZZ > ZZZZZ
gzip ZZZZZ
echo ZZZZZ > ZZZZZ


../../../bin/geneindex -deepGene ../PB.TandT.shifted.ace3  -o PB.doubled.mass5 -runList ../../../MetaDB/$MAGIC/RunListSorted -runAce  ../../../tmp/GENEINDEX/$MAGIC.info.ace  -method MASS5 -export i -MA 60 -keepIndex -gzo -correl -compare -maxGene 5000


##############
## analysis of diff genes in rat
# hand pick a set of beta diff files
# ls tmp/GENEINDEX/Results/NB_DEG.**beta* > MOA.list
# ls tmp/GENEINDEX/Results/Liver.*beta.0.txt | grep Livers_1_ | grep Control | grep -v _A2_ | grep -v _D2_ | grep -v 13rats | grep -v new | grep -v _B3_ | grep -v _P3_ | grep -v RefSeq > MOA.list


# for the rat use

ls tmp/GENEINDEX/Results/Liver.*beta.0.txt | grep Livers_1_ | grep Control | grep -v _A2_ | grep -v _D2_ | grep -v 13rats | grep -v new | grep -v _B3_ | grep -v _P3_ | grep -v RefSeq > MOA.list 
ls tmp/GENEINDEX/Results/Liver.*Control_NN*Control_Oil*beta.0.txt | grep -v RefSeq >> MOA.list 
ls tmp/GENEINDEX/Results/Liver.*Control_IP*Control_NN*beta.0.txt | grep -v RefSeq >> MOA.list 
ls tmp/GENEINDEX/Results/Liver.*Control_IP*Control_Oil*beta.0.txt | grep -v RefSeq >> MOA.list 


ls tmp/GENEINDEX/Results/Liver.*beta.0.txt | grep Livers_1_ | grep Control | grep -v _A2_ | grep -v _D2_ | grep -v 13rats | grep -v new | grep -v _B3_ | grep -v _P3_ | grep -v RefSeq > MOA.list
ls  tmp/GENEINDEX/Results/Liver.*beta.0.txt | grep Livers_2_ | grep Control | grep -v _A2_ | grep -v _D2_ | grep -v 13rats | grep -v new | grep -v _B3_ | grep -v _P3_ | grep -v _ER | grep -v HMG | grep -v Ppara4 | grep -v Ppara5 | grep -v Ppara6 | grep -v _BCar4 | grep -v _BCar5 | grep -v _BCar6 | grep -v RefSeq > MOA.list
ls  tmp/GENEINDEX/Results/Liver.*beta.0.txt | grep Livers_2_ | grep Control |  grep -v RefSeq  > MOA.list

# Affy positions seen via RNA-seq
ls RESULTS/MicroArray/*beta.0.txt | grep Livers_2_ | grep Control | grep -v _A2_ | grep -v _D2_ | grep -v 13rats | grep -v new | grep -v _B3_ | grep -v _P3_ | grep -v _ER | grep -v HMG | grep -v Ppara4 | grep -v Ppara5 | grep -v Ppara6 | grep -v _BCar4 | grep -v _BCar5 | grep -v _BCar6 | grep -v RefSeq > MOA.list

\rm _tutu
echo XXXXX >> _tutu
foreach ff (`cat MOA.list`)
  echo XXXXX >> _tutu
  cat $ff | gawk  -F '\t' '{z1=f;i=index(f,"RatLivers_");if(i<1)i=index(f,".nu.")+4-10;if(i>0){z=substr(f,i+10);i=index(z,"...");z1=substr(z,1,i);}printf("%s\t%s\t%s\t%s\t%s\t\t%s\n",$1,z1,$3,$4,$2);}' f=$ff >> _tutu
end

#######################
# NB case
#  use all diff genes, not just those in the beta files
#  but the MOA.list of files is hand ordered from inside since ls tmp/GENEINDEX/Results/NB.*Stg*av*diff* > MOA.prelist
#  the diffGene tables which have only one direction per file, so we switch sign and do 2 tables at once as ff and ff1
#######################
## construct a table per gene with all DG seen in RNA-seq av or in Micro-array


set Target2=AGLuK_rescaled
set Target2=AGLuK_at

set Target1=av
set Target2=AGLuK

# scripts/ma4.MOA_analysis.tcsh $Target1 $Target2 GENE
# scripts/ma4.MOA_analysis.tcsh $Target1 $Target2 MRNAH

# in 2015, the experiment class has been superseded by the compare class
 scripts/ma4.MOA_compare_analysis.tcsh $Target1 $Target2 MRNAH

#############

\rm _tutu _tutu.ace
foreach ff (`cat  DEG.$target.list`)
  echo XXXXX >> _tutu
  cat $ff | gawk  -F '\t' '/Genes: overexpressed in/{split($2,aa," ");if(aa[1]<aa[4]){sign=-1;f=aa[1] "/" aa[4];}else{sign=1;f=aa[4] "/" aa[1];}next;}/^#/{next;}{z1=f;i=index(f,"RatLivers_");if(i<1)i=index(f,".nu.")+4-10;if(i>0){z=substr(f,i+10);i=index(z,"...");z1=substr(z,1,i);}if($1)printf("%s\t%s\t%s\t%s\t%.2f\n",$1,z1,$3,$4,sign * $2);}' f=$ff >> _tutu
  cat $ff |  gawk  -F '\t' '/Genes: overexpressed in/{gsub(/ /,"_",$2);printf("\n Keyset %s",$2);old="";next;}/^#/{next}{g=$1;if(g==old)next;if($2>=50)printf("Gene %s\n",g);old=g;}END{print("\n");}' >>  _tutu.ace
end

cat TARGET/GENES/$target.gene2geneid.txt ZZZZZ  _tutu | gawk -F '\t' '/^ZZZZZ/{zz++;next;}/^XXXXX/{sign=-1;next;}/^# Parameters/{next;}{if(zz==1){if(g2gid[$1]) g2gid[$1]=g2gid[$1] "," ;g2gid[$1]=g2gid[$1] $2;next;}}/^Genes: overexpressed in/{sign=-sign;next;}{g=$1;sco=$5;if(0 && sco < limit && sc > -limit) next;if(index(g,":")>0)next;f=$2;ff[f]=1;gg[g]=1;if(sco>=limit || sco<=-limit)gg90[g]=1;score[f,g]=sign*sco;if($3)title[g]=$3;if($4)chrom[g]=$4}END{printf("0\t0\t999999999\tGene\tGeneId\t\t");for(f in ff) printf("\t%s",f);for (g in gg)if(gg90[g]>0){z=0;z2=0;nnp=0;nnn=0;col=0;for(f in ff){col++;z1=score[f,g];if(index(f,"or")>0)z1=0;if(z1<0){z1=-z1;if(z1>0)nnn++;}else{if(z1>0)nnp++};z+=z1;if(z1>0)z2+=col;}nnnn=0;if(nnn>0 && nnp > 0)nnnn=100000;printf("\n%d\t%d\t%d\t%s\t%s\t%s\t%s",nnnn+1000*(nnn+nnp)+nnn,z2,z,g,g2gid[g],title[g],chrom[g]);for(f in ff) printf("\t%s",score[f,g]);}printf("\n");}' limit=50 | $tab_sort -k 1,1n  -k2,2n -k3nr > RESULTS/MOA_genes.$target.txt


### same in Affy, but we lower the score from 90 in RNA_seq to 60 in Affy

\rm _tutu
foreach ff (`cat MOA.list`)
  echo XXXXX >> _tutu
  cat $ff | gawk  -F '\t' '{i=index(f,"RatLivers_");z=substr(f,i+10);i=index(z,"...");printf("%s\t%s\t%s\t%s\t%s\n",$1,substr(z,1,i),$3,$4,$2);}' f=$ff >> _tutu
end

foreach limit (90 120 150 180 190 195 200)
  cat _tutu | gawk -F '\t' '/^XXXXX/{sign=-1;next;}/^# Param/{next;}/^# AUC/{next;}/^Genes: overexpressed in/{sign=-sign;if (0)print "TTTTT",sign ; next;}{g=$1;sco=$5;if(0)print "UUUU",sco;if(sign*sco < limit && sign*sco > -limit) next;if(index(g,"Rat230")==0 && index(g,":")>0)next;f=$2;ff[f]=1;gg[g]=1;score[f,g]=sign*sco;if(0)print "TTTT",g,score[f,g];title[g]=$3;chrom[g]=$4}END{printf("0\t0\t0\tAffy\t\t");for(f in ff) printf("\t%s",f);for (g in gg){z=0;z2=0;nnp=0;nnn=0;for(f in ff){z1=score[f,g];if(z1<0){z1=-z1;if(z1>0)nnn++;}else{if(z1>0)nnp++};z+=z1;if(z1>30)z2+=col;}nnnn=0;if(nnn>0 && nnp > 0)nnnn=100000;printf("\n%d\t%d\t%d\t%s\t%s\t%s",nnnn+1000*(nnn+nnp)+nnn,z2,z,g,title[g],chrom[g]);for(f in ff) printf("\t%s",score[f,g]);}printf("\n");}' limit=$limit | $tab_sort -k 1n -k2,2n -k3nr > _tutu2

  cat  ../../Hits/Affy.Rat230_2.av.probeset2gene.quasi_unique.txt ZZZZZ _tutu2 | gawk -F '\t' '/^ZZZZZ/{zz++;;p2g["Affy"]="Gene";next;}{if(zz<1){p2g[$1]=$2;next;}g=p2g[$4];affy=$4;if(g)$4=g;printf("%s\t%s\t%s\t%s",$1,$2,$3,affy);for(i=4;i<=NF;i++)printf("\t%s",$i);printf("\n");}' >  RESULTS/MOA_genes.Affy.Shifted.$limit.txt

# who are the unmapped affy
  cat  ../../Hits/Affy.Rat230_2.av.probeset2gene.quasi_unique.txt ZZZZZ _tutu2 | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){p2g[$1]=$2;next;}g=p2g[$4];affy=$4;if(g)next;print $4}' | gzip > affyNew.list.gz

  gunzip -c affyNew.list.gz ZZZZZ.gz ../../Hits/Affy.Rat230_2.magic.2012_06_21.hits.gz | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;next;}i=index($1,"_at");if(ok[substr($1,1,i+2)])printf("%s\t%s\n",substr($1,1,i+2),$9);}' | gawk '{n[$1 "\t" $2]++;}END{for (k in n) if(n[k]>=8)print k;}' > affyNew2gene
gunzip -c affyNew.list.gz ZZZZZ.gz ../../Hits/Affy.Rat230_2.RefSeq.hits.gz | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;next;}i=index($1,"_at");if(ok[substr($1,1,i+2)])printf("%s\t%s\n",substr($1,1,i+2),$9);}' | gawk '{n[$1 "\t" $2]++;}END{for (k in n) if(n[k]>=8)print k;}' | sed -e 's/X__//' >> affyNew2gene

# reexport using the extended table
  cat  ../../Hits/Affy.Rat230_2.av.probeset2gene.quasi_unique.txt  affyNew2gene ZZZZZ _tutu2 | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){gsub(/^S_/,"",$2);p2g[$1]=$2;next;}g=p2g[$4];affy=$4;if(g)$4=g;printf("%s\t%s\t%s\t%s",$1,$2,$3,affy);for(i=4;i<=NF;i++)printf("\t%s",$i);printf("\n");}' >  RESULTS/MOA_genes.Affy.Shifted.$limit.txt

# mix the RNA and Affy on the gene key
  cat RESULTS/MOA_genes.Affy.Shifted.$limit.txt ZZZZZ  TARGET/GENES/$target.gene2geneid.txt   ZZZZZ  RESULTS/MOA_genes.$limit.txt | gawk -F '\t' '/^ZZZZZ/{zz++;g2gid["Affy"]="GeneId";next;}{if(NF > 3 && zz<1){imax++;g=$5;i2a[imax]=g;affy[$5]=affy[$5] "\t" $0;next;}if(zz==1){if(g2gid[$1]) g2gid[$1]=g2gid[$1] "," ;g2gid[$1]=g2gid[$1] $2;next;}printf("%s\t%s\t%s\t%s",$1,$2,$3,$4);for(i=5;i<=NF;i++)printf("\t%s",$i);af[$4]=1;if(affy[$4]){print affy[$4];}else printf("\n");}END{for (i=1;i<=imax;i++){k=i2a[i];if(af[k]+0<1 && length(affy[k]>10)){printf("\t\t\t%s\t\t\t\t\t\t\t\t",k);print affy[k];}}}' > RESULTS/MOA_genes.RNA_Affy.Shifted.$limit.txt

end


## add the geneid and regularize the number of columns

set ncols=`cat RESULTS/MOA_genes.180.txt | gawk -F '\t' '{if(NF > n)n=NF}END{print n}'`


set limit=180
  cat  ../../Hits/Affy.Rat230_2.av.probeset2gene.quasi_unique.txt  affyNew2gene ZZZZZ  TARGET/GENES/$target.gene2geneid.txt ZZZZZ ../../../TARGET/GENES/$target.gene2title.txt ZZZZZ RESULTS/MOA_genes.Affy.Shifted.$limit.txt   ZZZZZ  RESULTS/MOA_genes.$limit.txt | gawk -F '\t' '/^ZZZZZ/{zz++;g2gid["Affy"]="GeneId";next;}{if(zz<1){g=$2;if (index(g2af[g],$1)>0)next;if (g2af[g]) g2af[g]=g2af[g] "," ; g2af[g]=g2af[g] $1;next;}}{if(zz==2){gsub(/\"/,"",$0);title[$1]=$2;next;}if(zz==1){if(g2gid[$1]) g2gid[$1]=g2gid[$1] "," ;g2gid[$1]=g2gid[$1] $2;next;}}{if(NF > 3 && zz==3){g=$5;if (index(g2af[g],$4)<1){if (g2af[g]) g2af[g]=g2af[g] "," ; g2af[g]=g2af[g] $4;}i0=nres[g]+0;nres[g]++;if(nres[g]>nresmax)nresmax=nres[g];for(i=1;i<=NF;i++)g2afi[g,i0,i]=$i;if(0 && g=="Asns"){printf("TTTT%s i0=%d\tk=%s\t",g,i0,g2afi[g,0,1]);print;}ng2af[g]=NF;if(NF>ncols2)ncols2=NF;next;}g=$4;printf("%s\t%s\t%s\t%s\t%s",$1,$2,$3,$4,g2gid[$4]);for(i=5;i<=ncols;i++)printf("\t%s",$i);printf("\t##\t%s\t%s",g,g2af[g]);for(i0=0;i0<nresmax;i0++){printf("\t#");for(i=1;i<=ncols2;i++)printf("\t%s",g2afi[g,i0,i]);}ng2af[g]=0;printf("\t##\n");}END{for (g in ng2af)if(ng2af[g] > 0){printf("\t\t\t%s\t%s\t%s",g,g2gid[g],title[g]);for(i=6;i<=ncols;i++)printf("\t");printf("\t##\t%s\t%s",g,g2af[g]);for(i0=0;i0<nresmax;i0++){printf("\t#");for(i=1;i<=ncols2;i++)printf("\t%s",g2afi[g,i0,i]);}printf("\t##\n");}}' ncols=$ncols   > RESULTS/MOA_genes.RNA_Affy.Shifted.$limit.txt

## add the DEG found by NCTR
ln -s ../../../DEG_NCTR/DEG

## magic counts
cat RESULTS/MOA_genes.Affy.Shifted.190.txt | cut -f 5 | grep -v Rat230_ | $tab_sort -u > magic.Affy.gene
cat RESULTS/MOA_genes.Affy.Shifted.190.txt | cut -f 4 | $tab_sort -u > magic.Affy
cat RESULTS/MOA_genes.190.txt | cut -f 4 | $tab_sort -u > magic.JD


### FDA counts at various thresholds and Venn diagram Affy/RNA and FDA/magic

# conclusion absolute (fc) >= 2.1 and p <= 2 10^-4
set toto=fdaLimits
date > $toto
echo -n "pLimit\tfcLimit\tDEG.JD\tDEG.Affy.gene\tUnion\tIntersect\tRate\tRate" >> $toto
echo -n "\tmagic.JD\tDEG.JD\tUnion\tIntersect\tRate\tRate" >> $toto
echo -n "\tmagic.Affy\tDEG.affy\tUnion\tIntersect\tRate\tRate" >> $toto
echo >> $toto

foreach pLimit (0.000006 0.000010 0.000020 0.000030 0.0001 0.0002 0.0005 0.001 0.002 0.005 0.01 0.02 0.05)
  foreach fcLimit (1 1.2 1.4 1.6 1.8 2.0 2.1 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8)

    echo -n "$pLimit\t$fcLimit"  >> $toto
    cat DEG/NGS.JD.Norm/limma/* | gawk -F '\t' '{if($4<= p && $3 * $3 >= fc * fc) print $1;}' p=$pLimit fc=$fcLimit | $tab_sort -u > DEG.JD
    cat DEG/AFX.MAS5/limma/* | gawk -F '\t' '{if($4<= p && $3 * $3 >= fc * fc) printf("Rat230_2:%s\n", $1);}'  p=$pLimit fc=$fcLimit  | $tab_sort -u > DEG.Affy
    cat   ../../Hits/Affy.Rat230_2.av.probeset2gene.quasi_unique.txt  affyNew2gene ZZZZZ DEG.Affy | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){if (p2g[$1])next;p2g[$1]=$2;next;}g=p2g[$1];affy=$1;if(g)print g}' | $tab_sort  -u > DEG.Affy.gene

    wc DEG.JD | gawk '{printf("\t%d",$1);}' >> $toto
    wc DEG.Affy.gene | gawk '{printf("\t%d",$1);}' >> $toto
    cat DEG.JD  DEG.Affy.gene | $tab_sort -u | wc | gawk '{printf("\t%d\t\t\t",$1);}' >> $toto

    wc magic.JD | gawk '{printf("\t%d",$1);}' >> $toto  
    wc DEG.JD  | gawk '{printf("\t%d",$1);}' >> $toto  
    cat magic.JD DEG.JD | $tab_sort -u | wc | gawk '{printf("\t%d\t\t\t",$1);}' >> $toto

    wc  magic.Affy | gawk '{printf("\t%d",$1);}' >> $toto
    wc  DEG.Affy | gawk '{printf("\t%d",$1);}' >> $toto
    cat magic.Affy DEG.Affy | $tab_sort -u | wc | gawk '{printf("\t%d\t\t\t",$1);}' >> $toto
    echo >> $toto
  end
end
cat $toto | gawk -F '\t' '{nLine++;if(nLine<3){print;next;}printf("%s\t%s",$1,$2);for(jj=0;jj<3;jj++){j=6*jj+3;k=j+1;l=j+2;a=$j;b=$k;u=$l;i=a+b-u;r1=100.0*i/(a+.1);r2=100.0*i/(b+.1);printf("\t%d\t%d\t%d\t%d\t%.1f\t%.1f",a,b,u,i,r1,r2);}printf("\n");}' > $toto.txt
 
\cp $toto.txt ../../../RESULTS 


\rm DEG2compound
\rm Affy2compound

foreach compound (IFO NAF CHL 3ME NAP ECO PIR THI MET NIT CAR PHE LEF BEZ AFL)
  cat MOA.list | grep $compound
  cat DEG/NGS.JD.Norm/limma/$compound.txt | gawk -F '\t'  '{if($4<0.000025 && $3 * $3 > 2.2*2.2)printf("%s\t%s\t%.2f\n",$1,cc,$3);}' cc=$compound >> DEG2compound
  cat DEG/AFX.MAS5/limma/$compound.txt | gawk -F '\t'  '{if($4<0.000025 && $3 * $3 > 2.2*2.2)printf("%s\t%s\t%.2f\n",$1,cc,$3);}' cc=$compound >> Affy2compound
end

 cat  ../../Hits/Affy.Rat230_2.av.probeset2gene.quasi_unique.txt  affyNew2gene ZZZZZ  Affy2compound | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){af2g[substr($1,10)]=$2;next;}g=$1;if(af2g[$1])g=af2g[$1];printf("%s\t%s\t%s\t%s\n",g,$1,$2,$3);}' > Affy2compoundGene


cat  DEG2compound ZZZZZ  Affy2compoundGene ZZZZZ RESULTS/MOA_genes.RNA_Affy.Shifted.190.txt  | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){p=$2;ip=p2ip[p];if(ip<1){ipmax++;ip=ipmax;p2ip[p]=ip;ip2p[ip]=p;}gps[$1,ip]=$3;gg[$1]=1;next;}if(zz<2){g=$1;a=$2;p=$3;ip=p2ip[p];i0=ga2i0[g,a];if(i0<1){ng2a[g]++;i0=ng2a[g];g2a[g,i0]="Rat230_2:" $2;ga2i0[g,a]=i0;if(i0>i0max)i0max++;}aps[g,ip,i0]=$4;gg[$1]=1;next;} printf("%s",$1);g=$4;gg[g]=2;for(i=2;i<=NF;i++)printf("\t%s",$i);if(NF>ncols)ncols=NF;printf("\t###");for(ip=1;ip<=ipmax;ip++){printf("\t");if(pass<1){printf("%s",ip2p[ip]);}else printf("%s",gps[g,ip]);}for(i0=1;i0<i0max;i0++){printf("\t#");if(pass<1)printf("\tGene\tAffy");else printf("\t%s\t%s",g,g2a[g,i0]);for(ip=1;ip<=ipmax;ip++){printf("\t");if(pass<1){printf("%s",ip2p[ip]);}else printf("%s",aps[g,ip,i0]);}}pass=1;printf("\n");}END{for (g in gg)if(gg[g]==1){printf("\t\t\t%s",g);for(i=5;i<=ncols;i++)printf("\t");printf("\t###");for(ip=1;ip<=ipmax;ip++)printf("\t%s",gps[g,ip]);for(i0=1;i0<i0max;i0++){printf("\t#\t%s\t%s", g,g2a[g,i0]);for(ip=1;ip<=ipmax;ip++)printf("\t%s",aps[g,ip,i0]);}printf("\n");}}' >  RESULTS/MOA_genes.RNA_Affy.Shifted.190.NCTR.txt
 



###############################################################
###############################################################
## phase wg: Export a genomic wiggle per lane

foreach chrom ($chromSetAll)
  foreach group (R454 HEL LIF_S LIF_R ILM_S ILM_R)
    ls -ls $group*/*/$chrom/*.bv.gz | gawk '{if($6==20)printf("\\rm %s\n",$10);}' > _k ; wc _k ; source _k
  end
end

phasewg1:
 echo -n "Phase wg1 Export a genomic wiggle per manip/tissue/lane "
 date

if (! -d tmp/WIGGLELANE) mkdir tmp/WIGGLELANE

if ($Strategy == RNA_seq && ! -e tmp/METADATA/mrnaRemap.gz) then
  echo "missing file tmp/METADATA/mrnaRemap.gz"
  goto phaseLoop
endif

# mito RefSeq $chromSetAll
# 
if (0) then
  # clean up missed subli wiggles
  \rm totokill
  foreach run (`cat MetaDB/$MAGIC/r2sublib | cut -f 2 | sort -u `)
    set run2=`cat MetaDB/$MAGIC/r2sublib | gawk -F '\t' 'BEGIN {rr="toto";}{if($2==run)rr=$1;}END{print rr}' run=$run`
    echo $run $run2
    if ($run2 != toto && ! -e  tmp/WIGGLEGROUP/$run2/NC_005111.4/R.chrom.u.f.BF.gz) then
      echo "\\rm -rf tmp/WIGGLE*/$run tmp/WIGGLE*/$run2 tmp/SPONGE/$run tmp/SPONGE/$run2 tmp/TABIX/$run2" >> totokill
    endif
  end
  foreach run (`cat MetaDB/$MAGIC/RunsList`)
    if (! -e  tmp/WIGGLERUN/$run/NC_005111.4/R.chrom.u.f.BF.gz && ! -e  tmp/WIGGLEGROUP/$run/NC_005111.4/R.chrom.u.f.BF.gz) then
      echo "\\rm -rf tmp/WIGGLE*/$run tmp/SPONGE/$run tmp/TABIX/$run" >> totokill
    endif
  end
  source totokill
endif

foreach run (`cat MetaDB/$MAGIC/RunList`)
  # retrocompatibility 2015_08_31
  if (-e tmp/WIGGLERUN/$run/wg2a.done && ! -e tmp/WIGGLERUN/$run/wg2a.u.done ) then
    mv tmp/WIGGLERUN/$run/wg2a.done tmp/WIGGLERUN/$run/wg2a.u.done
  endif
  if (-e tmp/WIGGLERUN/$run/wg2a.u.done && -e tmp/WIGGLERUN/$run/wg2a.nu.done) continue

  if (! -d  tmp/$MAGIC_COUNT_DIR/$run) continue
  if (! -d tmp/WIGGLELANE/$run) $mkDir WIGGLELANE $run

  set stranded="non_stranded"
  foreach run2 (`cat MetaDB/$MAGIC/RunForwardList`)
    if ($run == $run2) set stranded="strand"
  end
  foreach run2 (`cat MetaDB/$MAGIC/RunReverseList`)
    if ($run == $run2) set stranded="antistrand"
  end 
  # the experimental value takes precedence */
  set s=`cat MetaDB/$MAGIC/runs.ace | gawk 'BEGIN{x=-1;}/^Run[ \t]/{gsub(/\"/,"",$2);ok=0;if($2==run)ok=1;next;}/^Observed_strandedness_in_ns_mapping/{if(ok==1)x=$3;next;}END{print int(100*x)}' run=$run`
# 2019_12_16, in SILVER a few of the reads are standed (contaminant Oligo) but the experiment is non stranded
# by swithcing at 60% we maintain the strand of the contaminants
  if ($s >= 0 && $s < 4000) set stranded="antistrand"
  if ($s >= 4000 && $s <= 10000) set stranded="strand"
  echo "wgi.wigglelane $run $stranded"
  set paired="singlets"
  foreach run2 (`cat MetaDB/$MAGIC/RunPairedList`)
    if ($run == $run2) then
      set paired="pairs"
    endif
  end

  foreach lane (`cat Fastc/$run/LaneList`)
    if (! -d tmp/WIGGLELANE/$lane) mkdir tmp/WIGGLELANE/$lane 
    if (-e tmp/WIGGLERUN/$run/wg2a.u.done && -e tmp/WIGGLERUN/$run/wg2a.nu.done) continue
    if (! -e tmp/WIGGLELANE/$lane/wg1.done) then
      echo "scripts/wigglerun.tcsh $run $lane $stranded"
      scripts/submit tmp/WIGGLELANE/$lane.wg1  "scripts/wg1.wigglelane.tcsh $run $lane $stranded $paired"
    endif
  end
end

date

goto phaseLoop

###############################################################
## phase wg2a: combine the manip/tissue wiggle per group

phasewg2a:
 echo -n "Phase wg2a combine the lane wiggles per run "
 date


if ($Strategy == Exome) then
  bin/tacembly MetaDB <<EOF 
    query find runs project == $MAGIC
    edit Wiggle  // in Exome case we need the coveron for each run
    save
    quit
EOF
endif

foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -d  tmp/WIGGLELANE/$run) continue
  if (! -d  tmp/WIGGLERUN) mkdir tmp/WIGGLERUN
  if (! -d  tmp/WIGGLERUN/$run)$mkDir WIGGLERUN $run
  foreach uu (u nu pp)
    if (-e tmp/WIGGLERUN/$run/wg2a.$uu.done) continue
    scripts/submit "tmp/WIGGLERUN/$run/wg2a" "scripts/wg2a.wiggleLane2Run.tcsh $run $uu"
  end
end

goto phaseLoop

###############################################################
## phase wg2b: combine the manip/tissue wiggle per group

phasewg2ba:
phasewg2bb:
phasewg2bm:
 echo -n "Phase  wg2b: Combine the run wiggles into group wiggles (for groups with tag Wiggle in MetaDB) "
 date

set justMito=0 
if ($phase == wg2bm) set justMito=1

if ($phase == wg2bm && ! -d tmp/SNP) then
  echo "please run s1m s2m (to construct Run wiggles to the base before wg2bm (Group wiggles)"
  goto phaseLoop
endif 

if ($phase == wg2bb && ! -d  tmp/WIGGLERUN) then
  echo "please run wg2a (to construct Run wiggles, before wg2b (Group wiggles)"
  goto phaseLoop
endif

# report errors in wigglerun
if (-e RESULTS/Mapping/$MAGIC.error_report.txt) then
  set ok=1
  echo 'Status = 0' > RESULTS/Mapping/$MAGIC.error_report.txt.w
  if ($ok == 1) then
    cat  RESULTS/Mapping/$MAGIC.error_report.txt.w | grep -v '= 0' >  RESULTS/Mapping/$MAGIC.error_report.txt.we1
    cat  RESULTS/Mapping/$MAGIC.error_report.txt.w | grep  '= 0' >  RESULTS/Mapping/$MAGIC.error_report.txt.we0
    set n1=`cat RESULTS/Mapping/$MAGIC.error_report.txt.we1 | wc -l`
    set n0=`cat RESULTS/Mapping/$MAGIC.error_report.txt.we0 | wc -l`
    if ($n1 == 0) then
      echo "No error in WIGGLERUN $1 runs analysed" >>  RESULTS/Mapping/$MAGIC.error_report.txt
    else
      date >>  RESULTS/Mapping/$MAGIC.error_report.txt
      echo "$n1 ERRORS in WIGGLERUN/phase wg2a"  >>  RESULTS/Mapping/$MAGIC.error_report.txt
      cat RESULTS/Mapping/$MAGIC.error_report.txt.we1 >>  RESULTS/Mapping/$MAGIC.error_report.txt
    endif
  endif
  \rm  RESULTS/Mapping/$MAGIC.error_report.txt.w*
endif
      
set n=0

set WRGG=MetaDB/$MAGIC/GroupWiggleList
if ($phase == wg2bb) then
  if (-e MetaDB/$MAGIC/GroupWiggleList) set n=`cat MetaDB/$MAGIC/GroupWiggleList | wc -l`
  set groupLevelMax=`cat  MetaDB/$MAGIC/g2r | cut -f 3 | sort -k 1n | tail -1`
  if ($n<1) then
    echo "wg2b group wiggles has nothing to do, you may wish to add the tag Wiggle a few groups"
    echo "At least a global group is needed if you wish to discover new exons"
    goto phaseLoop
  endif
else if ($phase == wg2ba) then
  set groupLevelMax=1
  set WRGG=MetaDB/$MAGIC/RunHasSubLibList
  if (-e MetaDB/$MAGIC/RunHasSubLibList)  set n=`cat MetaDB/$MAGIC/RunHasSubLibList | wc -l`
  if ($n<1) goto phaseLoop
endif

if (! -d tmp/WIGGLEGROUP) mkdir tmp/WIGGLEGROUP

cat MetaDB/$MAGIC/runs.ace | gawk 'BEGIN{x=-1;}/^Run[ \t]/{gsub(/\"/,"",$2);ok=0;run=$2;next;}/^Observed_strandedness_in_ns_mapping/{x=$3;if((x>=0 && x < 35) || (x>=65 && x <=100))ss[run]=1;next;}/^Paired_end/{pp[run]=1;next;}END{for (run in ss)if(pp[run]<1)print run}' >  MetaDB/$MAGIC/WiggleDropEndList


foreach level (`seq 1 1 $groupLevelMax`)
  echo "$phase level=$level"
  set okk=0
  foreach group (`cat $WRGG`)
    if ($phase == wg2bb) then
      set gLevel=`cat MetaDB/$MAGIC/g2r |  gawk -F '\t' '{if($1==g)level=$3}END{print 0+level}' g=$group` 
      if ($gLevel != $level) continue
    endif

    if (! -d tmp/WIGGLEGROUP/$group) mkdir tmp/WIGGLEGROUP/$group

    foreach run (`cat MetaDB/$MAGIC/g2r | gawk '{if($1==g)print $2;}' g=$group`)
      if ($phase == wg2bb && ! -e tmp/WIGGLERUN/$run/wg2a.u.done  && ! -e tmp/WIGGLEGROUP/$run/wg2ba.done  && ! -e tmp/WIGGLEGROUP/$run/wg2bb.done) then
        echo "Missing file  tmp/WIGGLERUN/$run/wg2a.u.done"
        echo "Please run phase wg1 and wg2a before wg2b"
        set ok=0
        goto phaseLoop
      endif
      grep Status tmp/WIGGLERUN/$run/wg2a.err >>  RESULTS/Mapping/$MAGIC.error_report.txt.w
    end

    cat  MetaDB/$MAGIC/r2sublib  MetaDB/$MAGIC/g2r | gawk '{if($1==g)print $2}' g=$group | $tab_sort -u >  tmp/WIGGLEGROUP/$group/newRunList

    if (-e  tmp/WIGGLEGROUP/$group/RunList) then
       set n=`diff tmp/WIGGLEGROUP/$group/RunList tmp/WIGGLEGROUP/$group/newRunList | wc -l`
       if ($n == 0) continue
echo "XXXXX Modification of group $group ...  $n new runs"
       \rm -rf tmp/WIGGLEGROUP/$group/*
       \rm -rf tmp/TABIX/$group/*
       \rm -rf tmp/SPONGE/$group/*
    endif
    
    cat  MetaDB/$MAGIC/r2sublib  MetaDB/$MAGIC/g2r | gawk '{if($1==g)print $2}' g=$group | $tab_sort -u >  tmp/WIGGLEGROUP/$group/RunList


    foreach chrom  (mito SpikeIn $chromSetAll)
      if (0 && ! -e tmp/WIGGLERUN/$group/$chrom/R.chrom.u.f.BF.gz) continue
      if ($chrom == Un) continue
      if ($justMito == 1 && $chrom != SpikeIn) continue
      if (! -d tmp/WIGGLEGROUP/$group/$chrom) then
        mkdir tmp/WIGGLEGROUP/$group/$chrom
        sleep .2
      endif
      if (-e  tmp/WIGGLEGROUP/$group/$chrom/R.chrom.u.f.BF.gz && -e  tmp/WIGGLEGROUP/$group/$chrom/R.chrom.u.r.BF.gz && -e tmp/WIGGLEGROUP/$group/$chrom/wg2b.done) continue
      if ($justMito == 1) mkdir tmp/WIGGLEGROUP/$group/$chrom.step1
      if (-e tmp/WIGGLEGROUP/$group/$chrom/wg3a.coverome.u.done) then
        \rm  tmp/WIGGLEGROUP/$group/$chrom/wg3a.*
      endif
      echo "scripts/wg2.group_wiggles.tcsh $group $chrom $justMito "
      if (-e tmp/WIGGLEGROUP/$group/$chrom/wg2b.out) \rm  tmp/WIGGLEGROUP/$group/$chrom/wg2b.out
      set okk=1
      \cp tmp/WIGGLEGROUP/$group/RunList tmp/WIGGLEGROUP/$group/$chrom
      scripts/submit "tmp/WIGGLEGROUP/$group/$chrom/wg2b" "scripts/wg2b.group_wiggles.tcsh $group $chrom $justMito " 
    end
    touch tmp/WIGGLEGROUP/$group/$phase.done
  end 
  if ($phase == wg2bb && $okk == 1) then
    scripts/submit wait
  endif
end

goto phaseLoop

###################################################################################
## Construct the pseudon exons needed for SNP and new exons discovery: i.e. locate the genome regions with sufficient coverage

phasewg3a:

echo "phase wg3a: Construct the coverome used for exon discovery"

# cumulate the statistics of the group wiggles using uniquely mapped MetaDB/$MAGIC/GroupWiggleList
set toto1=tmp/WIGGLEGROUP/stats.txt.1
foreach group (`cat MetaDB/$MAGIC/GroupWiggleList`)
  if (! -d tmp/WIGGLEGROUP/$group) continue
  foreach chrom (mito SpikeIn $chromSetAll)
    if ($chrom == Un) continue
    # if ($chrom != 13) continue
    if (! -d tmp/WIGGLEGROUP/$group/$chrom) continue
    if (-e tmp/WIGGLEGROUP/$group/$chrom/wg3a.coverome.u.done ) continue 
    if (! -e tmp/WIGGLEGROUP/$group/$chrom/R.chrom.u.f.BF.gz) then
      echo "missing file tmp/WIGGLEGROUP/$group/$chrom/R.chrom.u.f.BF.gz"
      continue
    endif
   if (! -d tmp/WIGGLEGROUP/$group) mkdir tmp/WIGGLEGROUP/$group
    scripts/submit tmp/WIGGLEGROUP/$group/$chrom/wg3a.coverome  "scripts/wg3a.coverome.tcsh $group $chrom $minCoveron u"
    scripts/submit tmp/WIGGLEGROUP/$group/$chrom/wg3a.coverome  "scripts/wg3a.coverome.tcsh $group $chrom $minCoveron nu"
    scripts/submit tmp/WIGGLEGROUP/$group/$chrom/wg3a.coverome  "scripts/wg3a.coverome.tcsh $group $chrom $minCoveron pp"
  if (-e $toto1) \rm $toto1
  end
end

  bin/tacembly MetaDB << EOF
    bql -o tmp/_t_ercc select p in ?project where p == "ERCC*"
EOF
  set n=`cat tmp/_t_ercc | wc -l`
  \rm tmp/_t_ercc
  if ($n > 0) then
    echo "phase wg3a: Export a multiwiggle for the ERCC for all runs/groups of in project ERCC1/2"

    bin/tacembly MetaDB << EOF
      query find project IS ERCC1 ; follow run ; Is_group
      list -a -f $CaliRootDir/tmp/WIGGLE/SpikeIn/ERCC1.groups.list
      query find project IS ERCC1 ; follow run ; Is_run
      list -a -f $CaliRootDir/tmp/WIGGLE/SpikeIn/ERCC1.runs.list
      query find project IS ERCC2 ; follow run ; Is_group
      list -a -f $CaliRootDir/tmp/WIGGLE/SpikeIn/ERCC2.groups.list
      query find project IS ERCC2 ; follow run ; Is_run
      list -a -f $CaliRootDir/tmp/WIGGLE/SpikeIn/ERCC2.runs.list
      quit
EOF
    scripts/wg3a.ERCC.multiwiggle.tcsh
  endif

goto phaseLoop

###################################################################################
## Combine and report the coverome needed for SNP and new exons discovery: i.e. locate the genome regions with sufficient coverage

phasewg3b:
  
  if (! -d tmp/WIGGLEGROUP) mkdir tmp/WIGGLEGROUP
  if (! -d RESULTS/Coverage_and_exons) mkdir  RESULTS/Coverage_and_exons

  echo -n "phasewg3b Combine and report the coverome used for exon discovery: start "
  date
  set toto1=tmp/WIGGLEGROUP/stats.txt.1
  if (! -e $toto1) then
    foreach group (`cat  MetaDB/$MAGIC/RunHasSubLibList  MetaDB/$MAGIC/GroupWiggleList`)
      foreach ff (`ls tmp/WIGGLEGROUP/$group/*/wg3a.coverome.u.txt`)
        cat $ff | gawk -F '\t' '/genome/{next}{print}' >> $toto1
        cat $ff  | gawk -F '\t' '/genome/{z=$1 "\tgenome\t" $3 "\t" $4  ; u[z] += $5; v[z] += $6 ;}END{for (z in u) printf("%s\t%d\t%d\t%d\n",z,u[z],v[z],u[z]/(1+v[z]));}'  >> $toto1
        cat  $ff  | gawk -F '\t' '/genome/{next}{z=$1 "\tAny\t" $3 "\t" $4  ; u[z] += $5; v[z] += $6 ;}END{for (z in u) printf("%s\t%d\t%d\t%d\n",z,u[z],v[z],u[z]/(1+v[z]));}'  >> $toto1
      end
    end
  endif

  # may be there is no group with wiggles
  if (! -e $toto1) goto phaseLoop

  set toto=tmp/WIGGLEGROUP/$MAGIC.genome_coverage_per_threshold.txt
  date > $toto
  echo "Genome regions in Mb covered per threshold, no smoothing" >> $toto 
  echo "Only uniquely mapped tags are counted" >> $toto
  echo -n "Length covered per threshold per experiment" >> $toto
  cat $toto1 | $tab_sort -k 4,4n -k1,1 | gawk -F '\t' '{if ($2!="Any" || $3 != "ns")next;g=$1 ;if(g2i[g]<1){ng++;g2i[g]=ng;i2g[ng]=g;}ig=g2i[g];s=$4;if(s2i[s]<1){ns++;s2i[s]=ns;i2s[ns]=s;}is=s2i[s];nn[ig,is]+=$6;if($6>1000000)ns2=is;}END{for(is=1;is<=ns2;is++)printf("\t%d fold",i2s[is]);for(ig=1;ig<=ng;ig++){printf("\n%s",i2g[ig]);for(is=1;is<=ns2;is++)printf("\t%d",int(nn[ig,is]/1000000));}printf("\n");}' >> $toto

  set toto=tmp/WIGGLEGROUP/$MAGIC.alignedMb_per_threshold.txt
  date > $toto
  echo "Aligned Mb in genome regions covered per threshold, no smoothing" >> $toto 
  echo "Only uniquely mapped tags are counted" >> $toto
  echo -n "Aligned Mb per threshold per experiment" >> $toto
  cat $toto1 | $tab_sort -k 4,4n -k1,1 | gawk -F '\t' '{if ($2!="Any" || $3 != "ns")next;g=$1 ;if(g2i[g]<1){ng++;g2i[g]=ng;i2g[ng]=g;}ig=g2i[g];s=$4;if(s2i[s]<1){ns++;s2i[s]=ns;i2s[ns]=s;}is=s2i[s];nn[ig,is]+=$5;if($5>1000000)ns2=is;}END{for(is=1;is<=ns2;is++)printf("\t%d fold",i2s[is]);for(ig=1;ig<=ng;ig++){printf("\n%s",i2g[ig]);for(is=1;is<=ns2;is++)printf("\t%d",int(nn[ig,is]/1000000));}printf("\n");}' >> $toto

  set toto=tmp/WIGGLEGROUP/$MAGIC.percent_Mb_in_coverome_per_threshold.txt
  date > $toto
  echo "Percent aligned Mb in coverome per threshold" >> $toto 
  echo "Only uniquely mapped tags are counted" >> $toto
  echo -n "Aligned Mb per threshold per experiment, no smoothing" >> $toto
  cat $toto1 | $tab_sort -k 4,4n -k1,1 | gawk -F '\t' '{if ($2!="Any" || $3 != "ns")next;g=$1;if(g2i[g]<1){ng++;g2i[g]=ng;i2g[ng]=g;}ig=g2i[g];s=$4;if(s2i[s]<1){ns++;s2i[s]=ns;i2s[ns]=s;}is=s2i[s];nn[ig,is]+=$5;if($6>1000000)ns2=is;}END{for(is=1;is<=ns2;is++)printf("\t%d fold",i2s[is]);for(ig=1;ig<=ng;ig++){printf("\n%s",i2g[ig]);for(is=1;is<=ns2;is++)printf("\t%d",int(100*nn[ig,is]/nn[ig,1]));}printf("\n");}' >> $toto

  set toto=tmp/WIGGLEGROUP/$MAGIC.chromosome_Mb_per_threshold.txt
  date > $toto
  echo "Regions covered per coverage threshold, no smoothing" >> $toto 
  echo "Only uniquely mapped tags are counted" >> $toto
  echo -n "Aligned Mb per threshold per experiment\tChromosome" >> $toto
  cat $toto1 | $tab_sort -k 4,4n -k1,1 -k2,2n | gawk -F '\t' '/L2E/{if ($2 == "genome" || $3 != "ns")next;g=$1 "\t" $2 ;if(g2i[g]<1){ng++;g2i[g]=ng;i2g[ng]=g;}ig=g2i[g];s=$4;if(s2i[s]<1){ns++;s2i[s]=ns;i2s[ns]=s;}is=s2i[s];nn[ig,is]+=$6;if($6>1000000)ns2=is;}END{for(is=1;is<=ns2;is++)printf("\t%d fold",i2s[is]);for(ig=1;ig<=ng;ig++){printf("\n%s",i2g[ig]);for(is=1;is<=ns2;is++)printf("\t%.3f",(nn[ig,is]/1000000));}printf("\n");}' >> $toto

goto phaseLoop

###################################################################################
## Report the coverons statistics and the autocorrelation and strand cross correlation and the differential coverons

phasewg4:


#####

if (1) then

set toto4=tmp/WIGGLEGROUP/$MAGIC.coveron_length_histogram.txt
set toto5=tmp/WIGGLEGROUP/$MAGIC.coveron_extent_per_coverage.txt
if (-e $toto4) rm $toto4
if (-e $toto4.1) rm $toto4.1
if (-e $toto5) rm $toto5

foreach group (`cat MetaDB/$MAGIC/GroupListSorted`)
  set ok=0
  foreach group2 (`cat MetaDB/$MAGIC/GroupWiggleList`)
    if ($group == $group2) set ok=1
  end
  if ($ok == 0) continue
  echo $group

  set toto=tmp/WIGGLEGROUP/$group/$MAGIC.$group.coveron_length_histogram.txt
  echo -n "## $toto computed on group $group : " > $toto
  date >> $toto
  echo "Histogram of the length of the coverons at different coverage thresholds in chromosomes $chromSetAll" >> $toto
  echo "0\t0\t0" > $toto.1
  foreach cover (1 2 5 10 20 50 100 200 500 1000)
    cat   tmp/WIGGLEGROUP/$group/*/coverome.$cover.u.peaks | gawk -F '\t' '{da=$4 - 1 ;n[da]++;bp[da]+=$7;}END{for(da in n)printf("%d\t%d\t%d\t%d\n",da,cov,n[da],bp[da]);}' cov=$cover >> $toto.1
  end
  $tab_sort -k 2n -k 1n  $toto.1 | gawk -F '\t' '{x=$1;c=$2;y=$3;bp=$4;ic=c2i[c];if(ic==0){icmax++;c2i[c]=icmax;i2c[icmax]=c;ic=icmax;}if(c==0)next;zyy[ic]+=x*y;zbp[ic]+=bp;if(x>10000)x=10000;if(x>xmax)xmax=x;yy[x,ic]+=y;yyy[ic]+=y;}END{printf("# Coveron or exon length");for(ic=1;ic<=icmax;ic++)if(yyy[ic]>0)printf("\t%d fold %s",i2c[ic],group);for(x=10;x<=xmax;x+=10){printf("\n%d",x);for(ic=1;ic<=icmax;ic++)if(yyy[ic]>0)printf("\t%d",yy[x,ic]);}printf("\n# Number of segments");for(ic=1;ic<=icmax;ic++)if(yyy[ic]>0)printf("\t%d",yyy[ic]);printf("\n# Genomic length covered (Mb)");for(ic=1;ic<=icmax;ic++)if(yyy[ic]>0)printf("\t%d",zyy[ic]/1000000);printf("\n# Aligned (Mb)");for(ic=1;ic<=icmax;ic++)if(yyy[ic]>0)printf("\t%d",zbp[ic]/1000000);printf("\n");}' group=$group | sed -e 's/^10000/>=10000/' >>  $toto
  wc $toto
  cat $toto | gawk '/^#/{print}' >> $toto5
  cat $toto | scripts/transpose >> $toto4.1
  echo "\n\n" >> $toto4.1
  \rm $toto.1

end
  cat $toto4.1 |  scripts/transpose > $toto4
  set n=`cat $toto4 | wc -l`
  if ($n > 0) then
    \cp $toto4 RESULTS/Coverage_and_exons
    \cp $toto5 RESULTS/Coverage_and_exons
  endif
endif

##########

if (0) then
# this is obsolete
# Strand shift computed using the auto-correlation function of the stranded wiggles

echo Strand_shift
set toto=tmp/WIGGLEGROUP/$MAGIC.strand_correlation_per_chromosome.txt
date > $toto
echo "Correlation between the 2 densities of reads on the 2 strands per chromosome " >> $toto

foreach group (`cat MetaDB/$MAGIC/GroupWiggleList`)
  foreach chrom ($chromSetAll)  
    if ($chrom != chrX && $chrom != chrY && -d  tmp/WIGGLEGROUP/$group/$chrom && -e  tmp/WIGGLEGROUP/$group/$chrom/u.strand_shift.txt) then
      cat tmp/WIGGLEGROUP/$group/$chrom/u.strand_shift.txt | gawk '/^#/{next}{print "Autosome",g,$1,$2,$3}' g=$group c=$chrom >> $toto.1
    endif
  end
  foreach chrom (chrX chrY)
    if (-d  tmp/WIGGLEGROUP/$group/$chrom && -e  tmp/WIGGLEGROUP/$group/$chrom/u.strand_shift.txt) then
      cat tmp/WIGGLEGROUP/$group/$chrom/u.strand_shift.txt | gawk '/^#/{next}{print c,g,$1,$2,$3}' g=$group c=$chrom >> $toto.1
    endif
  end
end

cat $toto.1 | gawk -f scripts/s4.autocorrel.awk >> $toto

\cp $toto RESULTS/Coverage_and_exons
wc $toto

\rm $toto.1

endif

#########

if (0) then

echo Strand_coverage
set toto=tmp/WIGGLEGROUP/$MAGIC.$WnewExon.strand_coverage_per_threshold.txt
date > $toto

# show the title lines
foreach chrom ($chromSetAll)
end
cat tmp/WIGGLEGROUP/$WnewExon/$chrom/u.strand_coverage_per_threshold.txt | gawk '/^#/{gsub(/threshold/,"fold",$0);print}' >> $toto

#colate the data
foreach chrom ($chromSetAll)
  cat tmp/WIGGLEGROUP/$WnewExon/$chrom/u.strand_coverage_per_threshold.txt | gawk '/^#/{next}{print}' >> $toto.1
end
cat $toto.1 | gawk -F '\t' '/^[0-9]/{c=$1;cc[c]=1;for(i=2;i<=NF;i++)n[c,i]+=$i;if(NF>iMax)iMax=NF;}END{for(c in cc){printf("%s",c);for(i=2;i<=iMax;i++)printf("\t%d",n[c,i]);printf("\n");}}' | $tab_sort -k 1n  >> $toto
cat $toto.1 | gawk -F '\t' '/^[0-9]/{next;}{c=$1;cc[c]=1;for(i=2;i<=NF;i++)n[c,i]+=$i;if(NF>iMax)iMax=NF;}END{for(c in cc){printf("%s",c);for(i=2;i<=iMax;i++)printf("\t%d",n[c,i]);printf("\n");}}' | $tab_sort  >> $toto
cat $toto.1 | gawk -F '\t' '/^Total/{for(i=2;i<=NF;i++)t[i]+=$i;if(NF>iMax)iMax=NF;}/^Reliably_read_on_both_strands/{for(i=2;i<=NF;i++)r[i]+=$i;if(NF>iMax)iMax=NF;}/^Only_read_on_one_strand/{for(i=2;i<=NF;i++)o[i]+=$i;if(NF>iMax)iMax=NF;}END{printf("%% Reliably_read_on_both_strands");for(i=2;i<=iMax;i++){if(t[i]<1)t[i]=1;printf("\t%.2f",100.0*r[i]/t[i]);}printf("\n");printf("%% Only_read_on_one_strand");for(i=2;i<=iMax;i++)printf("\t%.2f",100.0*o[i]/t[i]);printf("\n");}' >> $toto
\rm $toto.1
\cp $toto RESULTS/Coverage_and_exons
wc $toto

endif

###########
if (0) then

  # differential expression of most differential coverons covered at least $minCoveron times
  # create an ace file
  set toto=RESULTS/Coverage_and_exons/$MAGIC.Coverons
  \rm  toto.deepAce
  cat MetaDB/$MAGIC/runs.ace >  toto.runAce
  cat  MetaDB/$MAGIC/GroupWiggleList  > toto.runList
  cat  MetaDB/$MAGIC/GroupWiggleList | gawk '{printf("R_%s\n",$1);}' >> toto.runList
  foreach group (`cat MetaDB/$MAGIC/GroupWiggleList`)
    echo $group | gawk '{printf ("Run R_%s\nGroup %s\n\n",$1,$1);}' >> toto.runAce
    cat tmp/WIGGLEGROUP/$group/*/coverome.$minCoveron.u.peaks | gawk -F '\t' '/^#/{next;}{printf ("Gene %s__%d_%d\nRun_U R_%s 0 %.2f seqs %.2f tags %.2f kb\n\n",$1,$2,$3,g,$6,$6,$7/1000);}' g=$group >> toto.deepAce
    cat tmp/WIGGLEGROUP/$group/*/coverome.$minCoveron.u.peaks | gawk -F '\t' '/^#/{next;}{printf ("Gene %s__%d_%d\nLength %d\n\n",$1,$2,$3,$4);}' g=$group >> toto.runAce
  end

endif

# bin/geneindex -compare -pA -deepGene toto.deepAce -runAce toto.runAce -runList toto.runList -o $toto
# name the coverons by contact with the genes
# gene2intMap

if (0) then

  foreach chrom ($chromSetAll)
    echo ' ' > toto.sp0
    if (-e TARGET/GENES/av.gene2intMap.txt) then
      cat TARGET/GENES/av.gene2intMap.txt | gawk '{g=$1;c=$2;gsub(/\"/,"",c);if(chrom!=c)next;a1=$3;a2=$4;if(a1>a2){a2-=0;a0=a1;a1=a2;a2=a0;}else a2+=0; printf("%s\t%09d\t%09d\tGENE\t%s\n",chrom,a1,a2,g); }' chrom=$chrom > toto.sp0
    endif
    foreach run (`cat MetaDB/$MAGIC/GroupWiggleList`) 
      if (! -e tmp/WIGGLEGROUP/$run/$chrom/coverome.$minCoveron.u.peaks) continue
      cat toto.sp0 > toto.sp1
      cat  tmp/WIGGLEGROUP/$run/$chrom/coverome.$minCoveron.u.peaks | gawk '/^#/{next;}{nn++;chrom=$1;a1=$2;a2=$3;if(a1>a2){a0=a1;a1=a2;a2=a0;}printf("%s\t%09d\t%09d\tCOVERON\tCoveron.%s.%s_%d\t%d\t%s\t%s\t%s\n",chrom,a1,a2,run,chrom,nn,$4,$5,$6,$7); }' run=$run >> toto.sp1
      cat toto.sp1 | $tab_sort -k 1,1 -k2,2n -k3,3n |  gawk -F '\t' 'BEGIN{printf("#Target\ta1\ta2\tCoveron\tGene\tLength bp\tmax cover\taverage cover\taligned bp\n");}/^#/{next;}{chrom=$1;a1=$2;a2=$3;type=$4;if(type=="GENE"){g++;gnam[g]=$5;gch[g]=chrom;g1[g]=a1;g2[g]=a2;gz=0;if(a2>amax){amax=a2;top=g;}next;}if(type=="COVERON"){gz=0;for(i=g;i>=top;i--){if(gch[i]==chrom && a1<g2[i] && a2>g1[i]){gz=gnam[i];break;}}if(gz==0){ngz++;gz="New_" chrom "_"  ngz;}printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",$1,$2,$3,$5,gz,$6,$7,$8,$9);}}'  > tmp/WIGGLEGROUP/$run/$chrom/coverome2gene.$minCoveron.u.peaks
    end
    \rm toto.sp[01]
  end

endif

######

if (0) then
 foreach group (`cat MetaDB/$MAGIC/GroupWiggleList`) 
   cat tmp/WIGGLEGROUP/$group/*/coverome2gene.$minCoveron.u.peaks | gawk -F '\t' '/^#/{next;}/New_/{next}{n++;ln+=$6;bp+=$9;}END{print group,n,ln,bp}' group=$group 
   cat tmp/WIGGLEGROUP/$group/*/coverome2gene.$minCoveron.u.peaks | gawk -F '\t' '/^#/{next;}/New_/{n++;ln+=$6;bp+=$9;}END{print group,n,ln,bp}' group=$group 
 end
endif

goto phaseLoop

###############################################################
 
# ovary CNV heatmap 2013_01_22

cat B[3458]/tmp/WIGGLEGROUP/Ghs*/*/coverome2gene.10.u.peaks | gawk -F '\t' '/New_/{next;}{split($4,aa,".");r=aa[2];rr[r]=1;g=$5;gg[g]=1;rg[r,g]+=$9;}END{sep="";for(r in rr){i++;if(i>1)sep="\t";printf("%s%s",sep,rr[r]);}for(g in gg){printf("\n%s",g);for(r in rr)printf("\t%.1f",rg[r,g]);}printf("\n");}' > titi3458 &

# contruct a heat map
# export in 3 columns the name of the lane, the position and cover

R
genes = read.table("tutu2.txt")
cc=cor(genes)
c2 = cc[3:388,3:388]
heatmap(c2)
pdf ("heatmap.Y.pdf")
heatmap(c2)
quit()

###############################################################
## phase wg4b: compute the ETargets genebox coverage 

phasewg4b:

 echo -n "Phase wg4b compute the ETargets genebox coverage "
 date

foreach capture ($CAPTURES)
 foreach target ($Etargets)
  foreach run (`cat MetaDB/$MAGIC/RunsList`)
    if (-d tmp/WIGGLERUN/$run && ! -e tmp/WIGGLERUN/$run/wg4b.$target.ns.any_genebox.$capture.sponge.count) then
      scripts/submit tmp/WIGGLERUN/$run/wg4b "scripts/wg4b.gene_sponge.tcsh WIGGLERUN $target $run $capture"
    endif
    if (-d tmp/WIGGLEGROUP/$run && ! -e tmp/WIGGLEGROUP/$run/wg4b.$target.ns.any_genebox.$capture.sponge.count) then
      scripts/submit tmp/WIGGLEGROUP/$run/wg4b "scripts/wg4b.gene_sponge.tcsh WIGGLEGROUP $target $run $capture"
    endif
  end
 end
end

goto phaseLoop

###############################################################
## phase wg4c:

phasewg4c:

 echo -n "Phase wg4c gene_sponge capture Cumul "
 date

scripts/submit tmp/WIGGLERUN/wg4b.$MAGIC  "scripts/wg4b.gene_sponge.tcsh Cumul"
goto phaseLoop

###############################################################
## phase wg4d:

phasewg4d:

 echo -n "Phase wgc gene_sponge capture Parse "
 date

scripts/wg4b.gene_sponge.tcsh Parse
goto phaseLoop

###############################################################
## phase wg5: TABIX the groups

phasewg5:

 echo -n "Phase wg5 TABIX the group wiggles "
 date

set tabix=`which tabix | gawk '/Command/{print "uudummy";next;}{print $1}'`
if (! -x $tabix) then
  echo "Sorry tabix is not avalaible"
  echo "May be you should add it to the path, or install it from Source forge"
  echo "But this is completelly optional, it is only used by the graphic gene display"
  echo "but not by any of the algorithms used to reconstruct the genes"
  goto phaseLoop
endif

if (! -d tmp/TABIX) mkdir tmp/TABIX

if (-e tmp/TABIX/tabix.ace) \rm  tmp/TABIX/tabix.ace
set chr=""
if ($species == worm) set chr="CHROMOSOME_"

foreach group (`cat MetaDB/$MAGIC/RunWiggleList  MetaDB/$MAGIC/GroupWiggleList`)
  # we construct all run wigglesin WIGGLERUN,  but we only want to TABIX the groups and runs comtaining the Wiggle tag
  if (! -d tmp/TABIX/$group) mkdir tmp/TABIX/$group
  foreach chrom ($chromSetAll mito chloro)
    foreach unique (nu u pp)
 
        if (! -e tmp/WIGGLEGROUP/$group/$chrom/R.chrom.$unique.f.BF.gz && ! -e tmp/WIGGLERUN/$group/$chrom/R.chrom.$unique.f.BF.gz) continue
        if (-e  tmp/TABIX/$group/$chrom.$unique.tabix.done) continue
          # last parm could be C_$chrom
          scripts/submit  tmp/TABIX/$group/$chrom.$unique.tabix  "scripts/wiggle2tabix.tcsh $group $chrom $unique $chrom"
    end
  end
end

goto phaseLoop

###############################################################
## phase wg6: TABIX the groups

phasewg6:

 echo -n "Phase wg6 create the tabix.ace files "
 date 
 if (! -d tmp/TABIX) goto phaseLoop
 if (! -d tmp/TABIX/$MAGIC) mkdir tmp/TABIX/$MAGIC
 foreach chrom ($chromSetAll mito)
  echo "Map $chrom" >  tmp/TABIX/$MAGIC/$chrom.tabix.ace
  foreach group (`cat MetaDB/$MAGIC/RunWiggleList MetaDB/$MAGIC/GroupWiggleList`)
    ls -ls  tmp/TABIX/$group/$chrom.u.f.tabix.gz
    ls -ls  tmp/TABIX/$group/$chrom.u.r.tabix.gz
    if (! -e tmp/TABIX/$group/$chrom.u.f.tabix.gz && ! -e  tmp/TABIX/$group/$chrom.u.r.tabix.gz) continue
    echo "Wiggle $group $group/$chrom" >>  tmp/TABIX//$MAGIC/$chrom.tabix.ace
  end
  echo >> tmp/TABIX/$MAGIC/$chrom.tabix.ace
end

goto phaseLoop

###############################################################
## phase wg7# setenv UCSCgenomeRelease hg19: Create a Wiggle for the UCSC web site

phasewg7:

 echo -n "Phase wg7 create a wiggle for UCSC"
 date
 echo "this phase is only manual"
 # goto phaseLoop

 if ($species != hs) goto phaseLoop

# setenv species hs
# setenv UCSCgenomeRelease hg19

# setenv species corona
# setenv UCSCgenomeRelease wuhCor1  NC_045512v2

if (! -d tmp/WIGGLE) mkdir  tmp/WIGGLE
scripts/fetchChromSizes $UCSCgenomeRelease > tmp/WIGGLE/$species.chrom.sizes
if (! -d  ~/ftp/$species) mkdir  ~/ftp/$species
if (! -d  ~/ftp/$species/bigwig.$UCSCgenomeRelease) mkdir  ~/ftp/$species/bigwig.$UCSCgenomeRelease
if (! -d  ~/ftp/$species/bigwig.$UCSCgenomeRelease/$MAGIC) mkdir  ~/ftp/$species/bigwig.$UCSCgenomeRelease/$MAGIC

 foreach rg ( `cat MetaDB/$MAGIC/UcscWiggleList`)
   foreach fr ( f r frns pp  nu)
     echo $rg,$fr
     # ls -ls  tmp/WIGGLEGROUP/$rg/any.$fr.wig

# submit local, because not all farm machines see the ftp disc
     if (-d tmp/WIGGLEGROUP/$rg && ! -e tmp/WIGGLEGROUP/$rg/any.$fr.wig2 && ! -e ~/ftp/$species/bigwig.$UCSCgenomeRelease/$MAGIC/$rg/any.$fr.bw3) then
       echo "scripts/submit tmp/WIGGLEGROUP/$rg/wg7.make_bigwig.$fr  scripts/wg7.make_bigwig.tcsh GROUP $rg $fr"
       scripts/submit tmp/WIGGLEGROUP/$rg/wg7.make_bigwig.$fr "scripts/wg7.make_bigwig.tcsh GROUP $rg $fr"  local
     endif
     if (-d tmp/WIGGLERUN/$rg && ! -e tmp/WIGGLERUN/$rg/any.$fr.wig2 && ! -e ~/ftp/$species/bigwig.$UCSCgenomeRelease/$MAGIC/$rg/any.$fr.bw) then
       echo "scripts/submit tmp/WIGGLERUN/$rg/wg7.make_bigwig.$fr  scripts/wg7.make_bigwig.tcsh RUN $rg $fr"
             scripts/submit tmp/WIGGLERUN/$rg/wg7.make_bigwig.$fr "scripts/wg7.make_bigwig.tcsh RUN $rg $fr" local
     endif

   end
 end

goto phaseLoop

###############################################################

phasewgh:

# any_tissue

foreach tissue (BodyMapSEQC)
  foreach chrom ($chromSetAll mito)
    if (! -e tmp/WIGGLE/$chrom/$tissue.ns.histo) then
      scripts/wiggleHisto.tcsh $chrom $tissue u
    endif
  end
end

goto phaseLoop

gnuplot -bg white
  plot [0:20] 'tmp/WIGGLE/mito/BodyMapSEQC.u.histo.f.txt' using (log($1)/log(2)):(log($2)/log(2)) with line, 'tmp/WIGGLE/mito/BodyMapSEQC.u.histo.r.txt' using (log($1)/log(2)):(log($2)/log(2)) with line


####

foreach tissue ($tissues)
  cat tmp/WIGGLE/*/$tissue.*.histo.txt | gawk '{n[$1]+=$2;}END{for(z in n)printf("%s\t%d\n",z,n[z]);}'  | $tab_sort -k 1n > tmp/WIGGLE/$tissue.wholegenome.histo.txt
  echo -n "$tissue genome length = "
  cat tmp/WIGGLE/$tissue.wholegenome.histo.txt | gawk '{n+=$2;}END{print 10*n}'
end
foreach tissue ($tissues)
  cat tmp/WIGGLE/any.$tissue.*.histo.ns.txt | gawk '{n[$1]+=$2;}END{for(z in n)printf("%s\t%d\n",z,n[z]);}'  | $tab_sort -k 1n > tmp/WIGGLE/$tissue.wholegenome.histo.ns.txt
  echo -n "$tissue genome length = "
  cat tmp/WIGGLE/$tissue.wholegenome.histo.ns.txt | gawk '{n+=$2;}END{print 10*n}'
end

cat tmp/WIGGLE/*/any.any_tissue.histo.fr.txt | gawk '{n[$1]+=$2;}END{for(z in n)printf("%s\t%d\n",z,n[z]);}'  | $tab_sort -k 1n > tmp/WIGGLE/any_tissue.wholegenome.histo.fr.txt
  echo -n "any tissue genome length = "
  cat tmp/WIGGLE/any_tissue.wholegenome.histo.fr.txt | gawk '/[a-z_]/{next}{n+=$2;}END{print 10*n}'
  cat tmp/WIGGLE/any_tissue.wholegenome.histo.fr.txt | gawk '/[a-z_]/{next}{n+= $1*$2}END{print n}'
cat tmp/WIGGLE/*/any.any_tissue.histo.ns.txt | gawk '{n[$1]+=$2;}END{for(z in n)printf("%s\t%d\n",z,n[z]);}'  | $tab_sort -k 1n > tmp/WIGGLE/any_tissue.wholegenome.histo.ns.txt
  echo -n "any tissue genome length = "
  cat tmp/WIGGLE/any_tissue.wholegenome.histo.ns.txt | gawk '/[a-z_]/{next}{n+=$2;}END{print 10*n}'
  cat tmp/WIGGLE/any_tissue.wholegenome.histo.ns.txt | gawk '/[a-z_]/{next}{n+= $1*$2}END{print n}'

foreach tissue (any_tissue)
  date >! RESULTS/$MAGIC.$tissue.wholegenome.minihisto.txt
  echo "Coverage\t$tissue stranded" >> RESULTS/$MAGIC.$tissue.wholegenome.minihisto.txt
  cat tmp/WIGGLE/$tissue.wholegenome.histo.fr.txt | gawk '{if($1>10000)$1=10000;n[int($1)]+=$2;mx=$1;}END{for(x=0;x<=10000;x++)printf("%d\t%d\n",x,n[x]);}' >> RESULTS/$MAGIC.$tissue.wholegenome.minihisto.fr.txt

  date >! RESULTS/$MAGIC.$tissue.wholegenome.minihisto.ns.txt
  echo "Coverage\t$tissue non stranded" >> RESULTS/$MAGIC.$tissue.wholegenome.minihisto.ns.txt
  cat tmp/WIGGLE/$tissue.wholegenome.histo.ns.txt | gawk '{if($1>10000)$1=10000;n[int($1)]+=$2;mx=$1;}END{for(x=0;x<=10000;x++)printf("%d\t%d\n",x,n[x]);}' >> RESULTS/$MAGIC.$tissue.wholegenome.minihisto.ns.txt
end

# 2649322631 each tag counts around 3 times, so arount .8 Giga tags are mapped 

# there is a signle place over 120,000 on chrom 18 reverse at position 72,858,010 [000 to 020] coverage=953886

gnuplot -bg white
  plot [0:20] '/home/mieg/RESULTS/$MAGIC.any_tissue.wholegenome.hs.minihisto.fr.txt' using (log($1)/log(2)):(log($2)/log(2)),  '/home/mieg/RESULTS/$MAGIC.any_tissue.wholegenome.hs.minihisto.ns.txt' using (log($1)/log(2)):(log($2)/log(2)) with line

goto phaseLoop

###############################################################
### cnv: Differential CNV analysis, using class compare: tag CNV
phasecnv:

# Find compare ; CNV AND Profile
# The schema is expected to be
# Compare CNV   1000  // 1000 (default value), is the threshold to capture coverons in the sum of the wiggles of the big group
#         Profile     // each compare objects with CNV and Profile  tags will produce a cnv-compare table
#         Runs Big_group 1      // all wiggles from the runs/subgroups inside this groups will be cumulated to locate coverons
#              Control_group 2  // for each coveron the median of the coverag of the runs and additive subgroups will be used to define the base line
# In addition, all groups with the tags (WIGGLE && CNV) are added in the table in additive mode
  
# bigroup is the first group in the compare
# compute all coverage of all runs wich are subroups or runs of biggroup
if (! -d tmp/WIGGLE_CNV) mkdir tmp/WIGGLE_CNV
# identify the compare->CNV
if (-e  tmp/WIGGLE_CNV/c2runs.txt) \rm  tmp/WIGGLE_CNV/c2runs.txt
bin/tacembly MetaDB << EOF
  query find compare project == $MAGIC AND CNV AND Profile 
  select -o  tmp/WIGGLE_CNV/c2runs.txt  c,g,n, r,x  from c in @, g in c->runs, n in g[1], r in g->union_of, x in c->cnv
  query find project == $MAGIC ; > run ; Union_of && CNV && WIGGLE
  select -o  tmp/WIGGLE_CNV/c2groups.txt @
EOF

if (! -e  tmp/WIGGLE_CNV/c2runs.txt) then
  echo "No Compare objects with tags  CNV AND Profile were found in project $MAGIC"
  goto phaseLoop
endif

foreach chrom ($chromSetAll)
  if (! -d tmp/WIGGLE_CNV/$chrom) mkdir tmp/WIGGLE_CNV/$chrom
end


foreach compare (`cat  tmp/WIGGLE_CNV/c2runs.txt | cut -f 1 | sort -u`)
  touch  tmp/WIGGLE_CNV/cnv.$compare.runsa
  touch  tmp/WIGGLE_CNV/cnv.$compare.runsb
  \rm  tmp/WIGGLE_CNV/cnv.runs[ab12]  tmp/WIGGLE_CNV/cnv.bigCover
  cat  tmp/WIGGLE_CNV/c2runs.txt | gawk -F '\t' '{if($1 == cmp)printf("%s\t%s\n",$2,$3);}' cmp=$compare | sort -u | sort -k 2,2n | head -1 | cut -f 1 > tmp/WIGGLE_CNV/cnv.$compare.runsa
  cat  tmp/WIGGLE_CNV/c2runs.txt | gawk -F '\t' '{if($1 == cmp)printf("%s\t%s\n",$2,$3);}' cmp=$compare | sort -u | sort -k 2,2nr | head -1 | cut -f 1 > tmp/WIGGLE_CNV/cnv.$compare.runsb
  cat  tmp/WIGGLE_CNV/c2runs.txt | gawk -F '\t' '{if($1 == cmp)printf("%s\n",$5);}' cmp=$compare | sort -u | gawk -F '\t' '{n=1000; if($1>0) n=$1 ; print n;}'  > tmp/WIGGLE_CNV/cnv.$compare.bigCover

  set bigGroup=`cat tmp/WIGGLE_CNV/cnv.$compare.runsa`
  set bigCover=`cat  tmp/WIGGLE_CNV/cnv.$compare.bigCover`
  set controlGroup=`cat tmp/WIGGLE_CNV/cnv.$compare.runsb`

  cat  tmp/WIGGLE_CNV/c2runs.txt | gawk -F '\t' '{if ($1 == cmp && $2 == g) print $4;}' cmp=$compare g=$bigGroup | grep -v NULL   > tmp/WIGGLE_CNV/cnv.$compare.runs1
  cat  tmp/WIGGLE_CNV/c2runs.txt | gawk -F '\t' '{if ($1 == cmp && $2 == g) print $4;}' cmp=$compare g=$controlGroup | grep -v NULL   > tmp/WIGGLE_CNV/cnv.$compare.runs2

# echo NB_exome_tumor >  tmp/WIGGLE_CNV/cnv.runsc
# add tmp/WIGGLE_CNV/cnv.runs[abc] in the netx line if you want the groups in the table
# cat tmp/WIGGLE_CNV/cnv.runs1a ZZZZZ tmp/WIGGLE_CNV/cnv.runs2 | gawk '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;next;}if(ok[$1]<1)print;}' | scripts/tab_sort -u  > tmp/WIGGLE_CNV/cnv.runs1a

# the script is passed runsa runsb explicitlely, i.e. the names of the 2 groups, but also reads the files runs1 runs2 i.e. the full list of individuals in either group

  if ($bigCover == "") continue

  touch tmp/WIGGLE_CNV/c2runs.txt  tmp/WIGGLE_CNV/cnv.runs1a
  \rm  tmp/WIGGLE_CNV/c2runs.txt  tmp/WIGGLE_CNV/cnv.runs1a

  scripts/submit tmp/WIGGLE_CNV/cnv.$compare "scripts/cnv.compare_coverons.tcsh $compare $bigGroup $bigCover $controlGroup "
end

goto phaseLoop

foreach chrom ($chromSetAll)
  if (! -d tmp/WIGGLE_CNV/$chrom) mkdir tmp/WIGGLE_CNV/$chrom
  scripts/submit tmp/WIGGLE_CNV/$chrom/cnv.$compare "scripts/cnv.compare_coverons.tcsh $chrom $bigGroup $bigCover $controlGroup"
end

###############################################################

phasesponge1:
goto phaseLoop


#  look in scripts/sex.tcsh towards the end for what to do next


goto phaseLoop

###############################################################

phasesponge2:
# grab the forward aceview genes(1 2 5 10 20 50)
echo -n "Phase sponge 2, start : "
date

set WnewExon=`cat MetaDB/$MAGIC/GroupW_new_exonList | gawk 'BEGIN{z="toto";n=0;}{n++;if(n==1)z=$1;}END{print z}'`

if (! -d tmp/SPONGE) mkdir tmp/SPONGE

set mask=""

## recursive masks
set mainTarget=toto
foreach target ($Etargets)
  set mainTarget=$target
  break
end

foreach target ($Etargets)
  set mask=$mask",$target""_CDS:tmp/METADATA/$target.ns.cds.sponge"
end
foreach target ($Etargets)
  set mask=$mask",$target""_transcripts:tmp/METADATA/$target.ns.mrna.sponge"
end
foreach target ($Etargets)
  set mask=$mask",$target""_gene:tmp/METADATA/$target.ns.gene.sponge"
end

if (-e tmp/METADATA/genome.ns.sponge)       set mask=$mask",Genome:tmp/METADATA/genome.ns.sponge"


  foreach run (`cat  MetaDB/$MAGIC/GroupWiggleList MetaDB/$MAGIC/RunsList | sort -u `)
    echo "---sponge2 $run $WnewExon"
    if (0 && $run != $WnewExon) continue
    if (! -d  tmp/SPONGE/$run) $mkDir SPONGE $run 

    if (! -d  tmp/WIGGLEGROUP/$run && ! -d  tmp/WIGGLERUN/$run) continue

    foreach limit (1 2 5 10 20 50 100 1000 10000)
      if (-e tmp/SPONGE/$run/sponge2.gene.$limit.done5) continue
      echo "scripts/sponge2.tcsh $run $limit $mask $mainTarget"
      scripts/submit  "tmp/SPONGE/$run/sponge2.$limit" "scripts/sponge2.tcsh $run $limit $mask $mainTarget"
    end
  end

goto phaseLoop

###############################################################

phasesponge3:
  echo " sponge3: sponge statistics, construct RESULTS/Coverage_and_exons/sea_level.ace"

  echo "\nDo we have stranded runs for which the wiggle is backwards" >> RESULTS/Mapping/$MAGIC.error_report.txt   

if ($Strategy == RNA_seq) then
  if (! -d RESULTS/Expression) mkdir RESULTS/Expression
  set toto=RESULTS/Expression/$MAGIC.antisense_transcripts.txt
  touch $toto ; \rm $toto* 
  touch $toto.1
  foreach run (`cat MetaDB/$MAGIC/RunsList MetaDB/$MAGIC/GroupWiggleList`)
    if (-e  tmp/SPONGE/$run/isStranded) then 

      cat tmp/SPONGE/$run/*.sponge.stranded | gawk -F '\t' '{s=$3;a=$4;if (a+s > 10000){if($5 > 80)aa[$1]++;if($5<20)ss[$1]++;}}END{for(r in ss)if(aa[r]>ss[r])print r,ss[r],aa[r];else nn++;printf("%d runs have their wiggle correctly stranded\n",nn);}' >> RESULTS/Mapping/$MAGIC.error_report.txt   
 
      cat tmp/SPONGE/$run/*.sponge.stranded | gawk -F '\t' '{s=$3;a=$4;if (a+s > 10000){if($5 > 30)print}}' >> $toto.1
    endif
  end
  cat $toto.1 | gawk '{nn[$2]++;}END{for(k in nn)printf("%s\t%d\n",k,nn[k]);}' | sort -k 2nr > $toto.2
  echo -n "## $toto : " > $toto
  date >> $toto
  echo "## For all stranded runs, we sponged the wiggle and antiwiggle in every transcripts and selected those with > 30% antihits and total cover > 10000" >> $toto
  echo "# Transcript\tChromosome\tGene\tTitle\tNumber of stranded run for which the transcript reaches the thresholds" >> $toto

  foreach target ($Etargets)
    break
  end
  cat tmp/METADATA/$target.mrna_map_ln_gc_gene_geneid.txt ZZZZZ TARGET/GENES/$target.gene2title.ace ZZZZZ $toto.2 | gawk -F '\t' '/^ZZZZZ/{zz++;next;}/^#/{next;}{if(zz<1){t[$1]= "chr" $2 "\t" $5;t2gene[$1]=$5;next;}}/^Gene/{if(zz<2){n=split($1,aa," ");gene=aa[n];next;}}/^Title/{if(zz<2){n=split($1,aa,"\"");title[gene]=aa[2];next;}}{if(zz<2)next;}{printf("%s\t%s\t%s\t%s\n",$1,t[$1],title[t2gene[$1]],$2);}' >> $toto

endif #Strategy RNA_seq
#  (1 2 5 10 20 50 100 200 500 1000)
if (! -d RESULTS/Coverage_and_exons) mkdir RESULTS/Coverage_and_exons
# (1 2 5 10 20 50 100 200 500 1000)

set totoA=RESULTS/Coverage_and_exons/$MAGIC.sponge.txt
echo -n "## $totoA " > $totoA
date >> $totoA
if (-e $totoA.1) \rm $totoA.1

foreach limit (1 2 5 10 20 50 100 200 500 1000 2000 5000 10000)
  echo "sponge3 $MAGIC level $limit"
  set toto=tmp/SPONGE/$MAGIC.sponge.$limit.txt
  echo -n "# " > $toto
  date >> $toto
  echo "... sponge3 limit=$limit"
  echo ' ' > $toto.list
  foreach rg (`cat MetaDB/$MAGIC/RunsList MetaDB/$MAGIC/GroupWiggleList`)
    ls  tmp/SPONGE/$rg/Total.*.u.frns.$limit.txt >>  $toto.list
  end
  cat  MetaDB/$MAGIC/RunSublibrary_ofList ZZZZZ MetaDB/$MAGIC/RunListSorted ZZZZZ  MetaDB/$MAGIC/GroupListSorted ZZZZZ  MetaDB/$MAGIC/RunsList ZZZZZ MetaDB/$MAGIC/GroupWiggleList   ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ  `cat $toto.list`  | gawk -F '\t' -f scripts/sponge3.awk limit=$limit > $toto.1

  cat $toto.1 | gawk '/^#/{print}' > $toto.2
  cat $toto.1 | gawk '/^#/{next;}{if($2 < 1) next; print}'  >> $toto.2
  cat $toto.2 | scripts/transpose | scripts/tab_sort -k 1n >> $toto
  \rm $toto.[12] $toto.list
  if ($limit == 1) then
     cat $toto | head -2 | tail -1 |  gawk -F '\t' '{printf("#Type\tType\tCoverage threshold\t"); for (i = 2 ; i <= NF; i++)printf("\t%s",$i);printf("\n");}' >> $totoA
  endif
  cat $toto | gawk -F '\t' '/#/{next}{x=0+substr($1,4,3);type="";if(x==1)type="intergenic";printf("%s\t%s\t%d\t",$1,type,limit); for (i = 2 ; i <= NF; i++)printf("\t%s",$i);printf("\n");}' limit=$limit >> $totoA.1
end
cat $totoA.1 | scripts/tab_sort -k 1n -k 3n | gawk -F '\t' '{split($1,aa," ");if(0+$1<=10 && $3>1)next;}/^00[148]/{if($3>1)next;}{print}' >>  $totoA
\rm $totoA.1

if (0) then
cat $toto "mapped bp on genome " compte tenu du wiggle
les 3000  RNA in extent  ->les bases capturees par les categories  sum CDS sum utr sum intronic 
bruit = 30001 
7001 = % des bases not in transcripts   interg intronic exonic utr cds 
8001  fold cov of exon
endif

# echo "ZZZZZ\nRprim286\nZZZZZ\nZZZZZ\nRprim286\nZZZZZ\nZZZZZ " > titi
# cat titi tmp/SPONGE/Rprim286/Total.1.1.ns.$CDS.txt   | gawk -F '\t' -f scripts/sponge3.awk
# \rm titi tutu toto

cat tmp/SPONGE/$MAGIC.sponge.1.txt | gawk -F '\t' '/^#Run/{print ;}'   > tutu
# extent of intergenic in bp
cat tmp/SPONGE/$MAGIC.sponge.1.txt | gawk -F '\t' '/^001001/{print ;}' >> tutu  
# level 1 intergenic coverons
cat tmp/SPONGE/$MAGIC.sponge.1.txt | gawk -F '\t' '/^003001/{print ;}' >> tutu  
# level 100 intergenic coverons
cat tmp/SPONGE/$MAGIC.sponge.100.txt | gawk -F '\t' '/^003001/{print ;}' >> tutu  

set toto=tmp/SPONGE/$MAGIC.intergenicKb.ace
echo -n "// $toto " > $toto
date >> $toto
echo "// Number of kb or RNAseq mapping outside the gene boxes, exported by sponge3"  >> $toto
cat tutu | scripts/transpose | gawk '/^#Run/{ok=1;next;}{if(ok==1 && $2>0)printf("Ali %s\nIntergenic %d kb\nIntergenic_density %.4f \n\n",$1,($3-$4)/1000,($3 - (0 + $4))/(1 + $2));}' >> $toto
\rm tutu

echo $toto
echo "pparse $toto" | bin/tacembly MetaDB -no_prompt
bin/bestali -groupLetterProfile -db MetaDB -project $MAGIC


###  actual amount of bp per region  2 5 10 20 50 100 1000 10000)

set totox=tmp/SPONGE/$MAGIC.totox
echo '//' >  $totox.ace
foreach limit (1)
  if (-e $totox) \rm $totox
  foreach run (`cat MetaDB/$MAGIC/RunsList MetaDB/$MAGIC/GroupWiggleList`)
    cat tmp/SPONGE/$run/Total.*.u.frns.$limit.txt | gawk '/^#/{ok=0;next}{if(index($6,"_not_")>0)ok=0;else ok++;}/Genome_not_/{Gextent += $7 ; GAbove += $8 ; Gbp += $9;next;} /gene_not_/{IntronExtent +=$7 ; IntronAbove += $8 ;IntronBp += $9;next;}/transcripts_not_/{UTRextent += $7 ; UTRAbove += $8 ;UTRbp += $9;}/CDS_not_/{CDSextent += $7 ; CDSAbove += $8;CDSbp += $9;}/CDS/{if(ok==1){CDSextent += $7 ; CDSAbove += $8;CDSbp += $9;}}END{bp=Gbp+IntronBp+UTRbp+CDSbp;if(bp>0)printf("%s\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%.2f\t%.2f\t%.2f\t%.2f\n", run,Gbp, GAbove,Gextent,IntronBp,IntronAbove, IntronExtent, UTRbp,UTRAbove,UTRextent, CDSbp, CDSAbove,CDSextent, 100*Gbp/bp, 100*IntronBp/bp,100*UTRbp/bp,100*CDSbp/bp);}' run=$run >> $totox
  end 
  cat $totox | gawk -F '\t' '{printf("Ali %s\nS_1_intergenic %f \"Mb aligned, covered area\" %f \"Mb, annotated area\" %f Mb\nS_1_intronic %f \"Mb aligned, covered area\" %f \"Mb, annotated area\" %f Mb\nS_1_UTR %f \"Mb aligned, covered area\" %f \"Mb, annotated area\" %f Mb\nS_1_CDS %f \"Mb aligned, covered area\" %f \"Mb, annotated area\" %f Mb\n\n", $1, $2/1000000, $3/1000000, $4/1000000, $5/1000000, $6/1000000,$7/1000000,  $8/1000000, $9/1000000,$10/1000000,$11/1000000, $12/1000000,$5/1000000);}' | gawk '{gsub (/^S_1_/,"S_"limit"_",$1);print ;}' limit=$limit>> $totox.ace
end

echo "pparse $totox.ace" | bin/tacembly MetaDB -no_prompt

goto phaseLoop

###############################################################
###############################################################
###############################################################
## Signature wiggles, per run then per group, to divine the tissue and assess the 3' bias

phasewsig1:
 echo -n "Phase wsig1 : export signature wiggles (tissues and 3' bias) "
 date
# this code is impossibly too slow
# 2016_02_29  seems useless, disacard
goto phaseLoop

 if (! -d tmp/WIGGLESIG) mkdir tmp/WIGGLESIG
 foreach target ($targets)
   if (-e TARGET/Targets/$species.$target.signature_transcripts_list.txt) then
     foreach run (`cat MetaDB/$MAGIC/RunList`)
       set err=0
       foreach lane (`cat Fastc/$run/LaneList`)
         if (! -e tmp/COUNT/$lane.hits.gz) then
           set err=0
         endif
       end
       if ($err == 0 && ! -e tmp/WIGGLESIG/$run/sig.BV.gz) then
         if (! -d tmp/WIGGLESIG/$run) $mkDir WIGGLESIG $run
         scripts/submit tmp/WIGGLESIG/$run/wsig "scripts/wsig.signature_wiggle.tcsh RUN $target $run"
       endif
     end
   endif
 end

echo -n "wsig1 done "
date

goto phaseLoop

###############################################################
## phase wsig2: group the signature wiggles

phasewsig2:
 echo -n "Phase wsig2 : group the signature wiggles  "
 date

# 2016_02_29  seems useless, disacard
goto phaseLoop

 foreach target ($targets)
   if (-d tmp/WIGGLESIG && -e TARGET/Targets/$species.$target.signature_transcripts_list.txt) then
     set err=0
     foreach run (`cat MetaDB/$MAGIC/RunList`) 
       if ($err == 0 && ! -e tmp/WIGGLESIG/$run/sig.BV.gz) then
         echo "Missing file  tmp/WIGGLESIG/$run/sig.BV.gz"
         echo "Please run phase wsig1 before wsig2"
         set err=0
       endif
     end

     foreach group (`cat MetaDB/$MAGIC/GroupList`)
       if ($err == 0 && ! -e  tmp/WIGGLESIG/$group/sig.BV.gz) then
         if (! -d tmp/WIGGLESIG/$group) mkdir tmp/WIGGLESIG/$group
         scripts/submit   tmp/WIGGLESIG/$group/wsig "scripts/wsig.signature_wiggle.tcsh GROUP $target $group"
       endif
     end
   endif
 end

echo -n "wsig2 done "
date
goto phaseLoop

###############################################################
## phase wsig3: final report

phasewsig3:
 echo -n "Phase wsig3: export the summarized wiggles "
 date

# 2016_02_29  seems useless, disacard
goto phaseLoop

if (! -d  RESULTS/Coverage_and_exons) mkdir RESULTS/Coverage_and_exons

set toto=RESULTS/Coverage_and_exons/$MAGIC.signature_coverage
echo -n '# ' > $toto.txt
date >> $toto.txt
echo -n "# Run\tGene" > $toto.txt
echo toto | gawk '{for(i=0;i<=20000;i+=step)printf("\t%d",i);printf("\n");}' step=200 >> $toto.txt
foreach run (`cat MetaDB/$MAGIC/RunListSorted MetaDB/$MAGIC/GroupListSorted`)
  gunzip -c  tmp/WIGGLESIG/$run/sig.BV.gz | gawk '/variableStep/{split($2,aa,"=");gene=aa[2];next;}/^#/{next}/^track/{next}{x=0+$1;if(x>0 && x>gln[gene]){gln[gene]=x;gx[gene,x]=$2;if($2>mx[gene])mx[gene]=$2;next;}}END{for(gene in gln) {gln[gene]=gln[gene]-(gln[gene]%step);printf("%s\t%s",run,gene);ok=0;dy=0;for(i=0;i<=20000 && i<= gln[gene];i+=step){y=gln[gene]-i;if(20*gx[gene,y]>mx[gene])ok=1;if(ok==0)dy+=step;else {printf("\t%d",gx[gene,y]);cumul[y-dy]+=gx[gene,y];}}printf("\n");}printf("%s\tzCumul",run,gene);for(i=0;i<=20000;i+=step)printf("\t%d",cumul[i]);printf("\n");}' step=200 run=$run | scripts/tab_sort | sed -e 's/zCumul/Cumul/'  >> $toto.txt
end

head -3 $toto.txt > $toto.cumul.txt
cat $toto.txt | gawk -F '\t' '{if($2=="Cumul")print}' >> $toto.cumul.txt

echo -n "wsig3 done "
date
goto phaseLoop

###############################################################
## phase 8: Export the mrna wiggles 
# to get the mrna/chrom correspondance:
pushd MRNAS/CHROM2MRNAS
  bin/tacembly ~/yk <<EOF > /dev/null
    query find gene ! cloud
    follow transcribed_gene
    bql -a  -o m2i.txt -active select m,map from tg in @, m in tg->mrna, map in tg->intmap
    quit
EOF
  foreach chrom ($chromSetAll)
    cat m2i.txt | gawk -F '\t' '{gsub(/\"/,"",$0);m=$1;c=$2;gsub(/CHROMOSOME_/,"",c);if (c==chrom)print m}' chrom=$chrom | gzip > mrnas.$chrom.list.gz
  end

  gunzip -c $species.RefSeq.transcript2gene.txt.gz | cut -f 1 | split -l 2500 -d - mrnas2chrom.

popd

phasewm1:
phasewm1H:
 set H=""
 if ($phase == wm1H) set H=H
 echo -n "Phase wm1$H "
 date

if (! -e TARGET/MRNAS/mRNA2Wiggle.txt) goto phaseLoop

foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -e tmp/$MAGIC_COUNT_DIR/$run) continue
  if (-e tmp/MRNAWIGGLERUN$H/$run/run.done) continue
  if (! -d tmp/MRNAWIGGLELANE$H) mkdir  tmp/MRNAWIGGLELANE$H
  if (! -d tmp/MRNAWIGGLELANE$H/$run) $mkDir  MRNAWIGGLELANE$H $run
  foreach lane (`cat Fastc/$run/LaneList `)
    if (! -e tmp/$MAGIC_COUNT_DIR/$lane.hits.gz || -e tmp/MRNAWIGGLELANE$H/$lane.done) continue
    scripts/submit  tmp/MRNAWIGGLELANE$H/$lane  " scripts/wiggle.mrna.tcsh lane $lane $H"
  end
end

goto phaseLoop

phasewm2:
phasewm2H:
 set H=""
 if ($phase == wm2H) set H=H
 echo -n "Phase wm2$H "
 date

if (! -e TARGET/MRNAS/mRNA2Wiggle.txt) goto phaseLoop

foreach run (`cat MetaDB/$MAGIC/RunList  `)
  if (! -e tmp/MRNAWIGGLELANE$H/$run) continue
  if (-e tmp/MRNAWIGGLERUN$H/$run/run.done) continue
  if (! -d tmp/MRNAWIGGLERUN$H) mkdir  tmp/MRNAWIGGLERUN$H
  if (! -d tmp/MRNAWIGGLERUN$H/$run) $mkDir MRNAWIGGLERUN$H $run
  set ok=1
  foreach lane (`cat Fastc/$run/LaneList `)
    if (! -e tmp/MRNAWIGGLELANE$H/$lane.done) set ok=0
  end
  if ($ok == 0) continue
  scripts/submit  tmp/MRNAWIGGLERUN$H/$run  " scripts/wiggle.mrna.tcsh run $run $H"
end

goto phaseLoop

phasewm3:
phasewm3H:
 set H=""
 if ($phase == wm3H) set H=H
 echo -n "Phase wm3$H "
 date

if (! -e TARGET/MRNAS/mRNA2Wiggle.txt) goto phaseLoop

foreach group (`cat MetaDB/$MAGIC/GroupWiggleList  `)
  if (! -d tmp/MRNAWIGGLERUN$H) continue
  if (! -d tmp/MRNAWIGGLEGROUP$H) mkdir  tmp/MRNAWIGGLEGROUP$H
  if (! -d tmp/MRNAWIGGLEGROUP$H/$group) mkdir  tmp/MRNAWIGGLEGROUP$H/$group
  set ok=1
  foreach run (`cat MetaDB/$MAGIC/g2r | gawk -F '\t' '{if($1==g)print $2);}' g=$group`)
    if (! -e tmp/MRNAWIGGLERUN$H/$run/run.done) set ok=0
  end
  if ($ok == 0) continue
  scripts/submit  tmp/MRNAWIGGLEGROUP$H/$group  " scripts/wiggle.mrna.tcsh group $group $H"
end

goto phaseLoop

gunzip -c TARGET/MRNAS/hs.RefSeq.tr2ln2gene.ace.gz TARGET/MRNAS/hs.av.tr2ln2gene.ace.gz | gawk '{gsub(/\"/,"",$0);}/Transcript/{t=$2;}/Length/{print t "\t",$2;}' > tmp/MRNAWIGGLEGROUPH/tr2ln.txt
echo -n "# " > RESULTS/mrna.fr.groupwiggles.H.txt
date >> RESULTS/mrna.fr.groupwiggles.H.txt
echo -n "Transcriptlength\tPlot\tLength\tSupporting bp\tGroup\tTranscrit\tPosition" >> RESULTS/mrna.fr.groupwiggles.H.txt
echo toto | gawk '{for(i=10;i<=40000;i+=10)printf("\t%d",i);printf("\n");}' >>  RESULTS/mrna.fr.groupwiggles.H.txt
cat tmp/MRNAWIGGLEGROUPH/*/mrna.?.wiggles.txt | scripts/tab_sort -k 5,5 -k 4,4 | grep Group | grep -v LibBatchZ | grep -v ChronicFatigueAndControls_199| grep -v FC  > toto
cat tmp/MRNAWIGGLEGROUPH/tr2ln.txt ZZZZZ toto | gawk -F '\t' '/ZZZZZ/{zz++;next;}{if(zz<1){ln[$1]=$2;next}}{printf("%d\t",ln[$5]+0);print;}'  | scripts/tab_sort -k 1,1nr -k 6,6 -k 5,5 >> RESULTS/mrna.fr.groupwiggles.H.txt

gunzip -c TARGET/MRNAS/hs.RefSeq.tr2ln2gene.ace.gz TARGET/MRNAS/hs.av.tr2ln2gene.ace.gz | gawk '{gsub(/\"/,"",$0);}/Transcript/{t=$2;}/Length/{print t "\t",$2;}' > tmp/MRNAWIGGLEGROUP/tr2ln.txt
echo -n "# " > RESULTS/mrna.fr.groupwiggles.txt
date >> RESULTS/mrna.fr.groupwiggles.txt
echo -n "Transcriptlength\tPlot\tLength\tSupporting bp\tGroup\tTranscrit\tPosition" >> RESULTS/mrna.fr.groupwiggles.txt
echo toto | gawk '{for(i=10;i<=40000;i+=10)printf("\t%d",i);printf("\n");}' >>  RESULTS/mrna.fr.groupwiggles.txt
cat tmp/MRNAWIGGLEGROUP/*/mrna.?.wiggles.txt | scripts/tab_sort -k 5,5 -k 4,4 | grep Chronic | grep -v LibBatch | grep -v ChronicFatigueAndControls_199| grep -v FC  > toto
cat tmp/MRNAWIGGLEGROUP/tr2ln.txt ZZZZZ toto | gawk -F '\t' '/ZZZZZ/{zz++;next;}{if(zz<1){ln[$1]=$2;next}}{printf("%d\t",ln[$5]+0);print;}'  | scripts/tab_sort -k 1,1nr -k 6,6 -k 5,5 >> RESULTS/mrna.fr.groupwiggles.txt


gunzip -c TARGET/MRNAS/hs.RefSeq.tr2ln2gene.ace.gz TARGET/MRNAS/hs.av.tr2ln2gene.ace.gz | gawk '{gsub(/\"/,"",$0);}/Transcript/{t=$2;}/Length/{print t "\t",$2;}' > tmp/MRNAWIGGLEGROUPH/tr2ln.txt
echo -n "# " > RESULTS/mrna.LengthCoverage.fr.groupwiggles.H.txt
date >> RESULTS/mrna.LengthCoverage.fr.groupwiggles.H.txt
echo -n "Transcriptlength\tPlot\tLength\tSupporting bp\tGroup\tTranscrit\tPosition" >> RESULTS/mrna.LengthCoverage.fr.groupwiggles.H.txt
echo toto | gawk '{for(i=10;i<=40000;i+=10)printf("\t%d",i);printf("\n");}' >>  RESULTS/mrna.LengthCoverage.fr.groupwiggles.H.txt
cat tmp/MRNAWIGGLEGROUPH/*/mrna.LengthCoverage.?.wiggles.txt | scripts/tab_sort -k 5,5 -k 4,4 | grep Chronic | grep -v LibBatch | grep -v ChronicFatigueAndControls_199| grep -v FC  > toto
cat tmp/MRNAWIGGLEGROUPH/tr2ln.txt ZZZZZ toto | gawk -F '\t' '/ZZZZZ/{zz++;next;}{if(zz<1){ln[$1]=$2;next}}{printf("%d\t",ln[$5]+0);print;}'  | scripts/tab_sort -k 1,1nr -k 6,6 -k 5,5 >> RESULTS/mrna.LengthCoverage.fr.groupwiggles.H.txt

gunzip -c TARGET/MRNAS/hs.RefSeq.tr2ln2gene.ace.gz TARGET/MRNAS/hs.av.tr2ln2gene.ace.gz | gawk '{gsub(/\"/,"",$0);}/Transcript/{t=$2;}/Length/{print t "\t",$2;}' > tmp/MRNAWIGGLEGROUP/tr2ln.txt
echo -n "# " > RESULTS/mrna.LengthCoverage.fr.groupwiggles.txt
date >> RESULTS/mrna.LengthCoverage.fr.groupwiggles.txt
echo -n "Transcriptlength\tPlot\tLength\tSupporting bp\tGroup\tTranscrit\tPosition" >> RESULTS/mrna.LengthCoverage.fr.groupwiggles.txt
echo toto | gawk '{for(i=10;i<=40000;i+=10)printf("\t%d",i);printf("\n");}' >>  RESULTS/mrna.LengthCoverage.fr.groupwiggles.txt
cat tmp/MRNAWIGGLEGROUP/*/mrna.LengthCoverage.?.wiggles.txt | scripts/tab_sort -k 5,5 -k 4,4 | grep Chronic | grep -v LibBatch | grep -v ChronicFatigueAndControls_199| grep -v FC  > toto
cat tmp/MRNAWIGGLEGROUP/tr2ln.txt ZZZZZ toto | gawk -F '\t' '/ZZZZZ/{zz++;next;}{if(zz<1){ln[$1]=$2;next}}{printf("%d\t",ln[$5]+0);print;}'  | scripts/tab_sort -k 1,1nr -k 6,6 -k 5,5 >> RESULTS/mrna.LengthCoverage.fr.groupwiggles.txt




cat RESULTS/mrna.groupwiggles.txt | grep Chronic | gawk -F '\t' '{m=0;for(i=5;i<=NF;i++)m+=$i;printf("%s\t%s\t%d\n",$1,$2,m);}' | scripts/tab_sort -k 2 | grep .gAu

# collate all the runs and regularize the location of the most 3' hit (all lines for given mRNA must have same value in col 3

cat tmp/MRNAWIGGLERUN/Rhs*/mrna.f.wiggles | gawk '/^#/{next}{nn++;z[nn]=$0;if($3>LL[$2]){LL[$2]=$3;if($3>LMax)LMax=$3;}k=0;for(i=5;i<=NF;i++)k+=$i;kk[nn]=k;kkk+=k;next;}END{printf("Run\tmRNA\tLength\tBegin");for(i=0;i<=LMax;i+=50)printf("\t%d",i);for(i=1;i<=nn;i++){n=split(z[i],aa,"\t");L=LL[aa[2]];printf("\n%s\tU%s\t%d\t%d",aa[1],aa[2],L,aa[4]);for(j=aa[3];j<L;j+=50)printf("\t0");a=10*kkk/(nn*(1+kk[i]));for(j=5;j<=n;j++)printf("\t%d",aa[j]*a);}printf("\n");}' > RESULTS/mrna.wiggles.txt
cat tmp/MRNAWIGGLERUN/Rhs*/mrna.f.wiggles | scripts/tab_sort -k 2,2 |  gawk '/^#/{next}{nn++;z[nn]=$0;if($3>LL[$2]){LL[$2]=$3;if($3>LMax)LMax=$3;}k=0;for(i=5;i<=NF;i++)k+=$i;kk[nn]=k;kkk+=k;next;}END{printf("Run\tmRNA\tLength\tBegin");for(i=0;i<=LMax;i+=50)printf("\t%d",i);for(i=1;i<=nn;i++){n=split(z[i],aa,"\t");L=LL[aa[2]];printf("\n%s\tU%s\t%d\t%d",aa[1],aa[2],L,aa[4]);for(j=aa[3];j<L;j+=50)printf("\t0");a=10*kkk/(nn*(1+kk[i]));for(j=5;j<=n;j++)printf("\t%d",aa[j]*a);}printf("\n");}'  > RESULTS/mrna.wiggles2.txt

###############################################################
## phase wpA:

phasewpA:
 echo -n "Phase wpA export the polyA/T wiggle "
 date

# position chrom
foreach chrom ($chromSetAll)
end
## export a Feature AAA table in the cosmids

goto phaseLoop

cat tmp/pA/pA.1.*.ace  > toto.ace
# wpa.sx_pA.2010_02_11.ace

# count the categories
cat toto.ace | gawk '/^Feature/{ns[$6]++ ; nt[$6]+=$5;}END{for(t in ns)printf("%s\t%d\t%d\n",t,ns[t],nt[t]);}'

echo "query find sequence feature" > _bob
cat toto.ace | grep Feature | gawk '{printf ("edit -D Feature %s\n", $2)}' | scripts/tab_sort -u  >> _bob
echo parse toto.ace >> _bob
echo save >> _bob
echo quit >> _bob

bin/tacembly ~/yk < _bob > /dev/null
\rm toto.ace
\rm _bob

# code pour eliminer les patabeaux
bin/tacembly ~/yk <<EOF > /dev/null
  query find sequence feature
  show -a -f wpa.feature.2010_02_16.ace Feature
  //edit -D AAA_Sx_FPU
  //edit -D AAA_Sx_FABIO
  //edit -D AAA_Sx_FABIOfa
  //edit -D AAA_Sx_JK
  save
  quit
EOF

goto phaseLoop

# histo de ce qui traine as right wall

# polyA vu en 3' chez Fraser/Mixed
gunzip -c tmp/PHITS_av/Fraser1/Mixed/*.hits.gz | cut -f 20 | grep -v '-' | gawk '{n[$1]++}END{for(k in n)printf("%05d\t%s\n",n[k],k);}' | scripts/tab_sort -k 2
00015
267498  A
56975   AA
18728   AAA
05986   AAAA
02641   AAAAA
01514   AAAAAA
01103   AAAAAAA ***
00871   AAAAAAAA
00719   AAAAAAAAA
00524   AAAAAAAAAA
00462   AAAAAAAAAAA
00676   AAAAAAAAAAAA
00544   AAAAAAAAAAAAA
00503   AAAAAAAAAAAAAA
00344   AAAAAAAAAAAAAAA
00306   AAAAAAAAAAAAAAAA

00084   AAAAAAAAAAAAAAAAA

# polyA vu en 5' chez Fraser/Mixed
gunzip -c tmp/PHITS_av/Fraser1/Mixed/*.hits.gz | cut -f 17 | grep -v '-' | gawk '{n[$1]++}END{for(k in n)printf("%05d\t%s\n",n[k],k);}' | scripts/tab_sort -k 2
00015
722355  A
183720  AA
169809  AAA
162619  AAAA
137650  AAAAA
108778  AAAAAA ***
69926   AAAAAAA
35160   AAAAAAAA
16634   AAAAAAAAA
08737   AAAAAAAAAA
02133   AAAAAAAAAAA
gunzip -c tmp/PHITS_av/Fraser1/L4/*.hits.gz | cut -f 17 | grep -v '-' | gawk '{n[$1]++}END{for(k in n)printf("%05d\t%s\n",n[k],k);}' | scripts/tab_sort -k 2
173309  A
70360   AA
56628   AAA
55135   AAAA
49753   AAAAA
42457   AAAAAA  ***
34805   AAAAAAA
24347   AAAAAAAA
16186   AAAAAAAAA
09738   AAAAAAAAAA
03001   AAAAAAAAAAA

# 5' prefix in Fraser
gunzip -c tmp/PHITS_genome/Fraser1/Mixed/*.hits.gz | grep HIT | cut -f 17 | grep -v '-' | gawk '{if(length($1)>5)n[$1]++}END{for(k in n)printf("%05d\t%s\n",n[k],k);}' | scripts/tab_sort -k 1nr | more
165599  caaacttg
68728   caaact
66041   caaactt
57537   AAAAAA
39915   caaacttgg
36525   AAAAAAA
18136   AAAAAAAA
08791   AAAAAAAAA
05491   tgagtaactg
04433   AAAAAAAAAA

# in Bob
 gunzip -c tmp/PHITS_genome/BOB3/L1/*.hits.gz | grep HIT | cut -f 17 | grep -v '-' | gawk '{if(length($1)>5)n[$1]++}END{for(k in n)printf("%05d\t%s\n",n[k],k);}' | scripts/tab_sort -k 1nr | more326816  caaacttg
131773  caaacttgg
81772   caaact
61800   caaactt
25187   AAAAAA
21851   AAAAAAA
18286   tgagtaactg
17038   AAAAAAAA
14772   tgagtaact
12863   tgagtaac

###############################################################
###############################################################
## phase wmitopA1:

phasewmitopA1:
 echo -n "Phase wmito pA export the mitochondria polyA/T wiggle "
 date

if (! -d tmp/mito_wiggle) mkdir tmp/mito_wiggle
if (! -d tmp/mito_wiggle/pA) mkdir tmp/mito_wiggle/pA

## export all pA seen in the mito as a wiggle

foreach delta (1)
  echo -n "Rounding to $delta bp"
  foreach limit (1)
    foreach run (`cat MetaDB/$MAGIC/RunList`) 
        if ($manip != any && $tissue != any && ! -d tmp/PHITS_mito/$run) continue
        if (! -e tmp/mito_wiggle/pA/$manip.$tissue.tag.double) then
          scripts/submit tmp/mito_wiggle/pA/$manip.$tissue "scripts/mito_wiggle.tcsh $manip $tissue"
        endif
    end
  end
end

goto phaseLoop

###############################################################
## phase wmitopA2:

phasewmitopA2:
 echo -n "Phase wmito pA centralize the mitochondria polyA/T wiggle "
 date

if (! -d tmp/mito_wiggle/pA) goto phaseLoop


foreach tissue ($tissues)
  cat tmp/mito_wiggle/pA/*.$tissue.double | gawk '{if($2>0)printf("%d\t%d\n",$1,$2);}' | bin/wiggle -I BV -O BV -trackName "$tissue.f"  -out_step 1  > tmp/mito_wiggle/pA/any.$tissue.tag.f.bv
  cat tmp/mito_wiggle/pA/*.$tissue.double | gawk '{if($3>0)printf("%d\t%d\n",$1,$3);}' | bin/wiggle -I BV -O BV -trackName "$tissue.r"  -out_step 1  > tmp/mito_wiggle/pA/any.$tissue.tag.r.bv
  cat tmp/mito_wiggle/pA/*.$tissue.double | gawk '{if($4>0)printf("%d\t%d\n",$1,$4);}' | bin/wiggle -I BV -O BV -trackName "$tissue.f"  -out_step 1  > tmp/mito_wiggle/pA/any.$tissue.seq.f.bv
  cat tmp/mito_wiggle/pA/*.$tissue.double | gawk '{if($5>0)printf("%d\t%d\n",$1,$5);}' | bin/wiggle -I BV -O BV -trackName "$tissue.r"  -out_step 1  > tmp/mito_wiggle/pA/any.$tissue.seq.r.bv
end

cat tmp/mito_wiggle/pA/*.*.double | gawk '{if($2>0)printf("%d\t%d\n",$1,$2);}' | bin/wiggle -I BV -O BV -trackName "any.f" -out_step 1  > tmp/mito_wiggle/pA/any.any.tag.f.bv
cat tmp/mito_wiggle/pA/*.*.double | gawk '{if($3>0)printf("%d\t%d\n",$1,$3);}' | bin/wiggle -I BV -O BV -trackName "any.r" -out_step 1  > tmp/mito_wiggle/pA/any.any.tag.r.bv

cat tmp/mito_wiggle/pA/*.*.double | gawk '{if($4>0)printf("%d\t%d\n",$1,$4);}' | bin/wiggle -I BV -O BV -trackName "any.f" -out_step 1  > tmp/mito_wiggle/pA/any.any.seq.f.bv
cat tmp/mito_wiggle/pA/*.*.double | gawk '{if($5>0)printf("%d\t%d\n",$1,$5);}' | bin/wiggle -I BV -O BV -trackName "any.r" -out_step 1  > tmp/mito_wiggle/pA/any.any.seq.r.bv

echo ZZZZZ >! toto
foreach tissue ($tissues)
  if ($tissue == RefSeq) continue
  if ($tissue == dbSNP) continue
  if ($tissue == av) continue
  echo "ZZZZZ\t$tissue" >> toto
  cat tmp/mito_wiggle/pA/*.$tissue.double >> toto
end

set limit=100
date > toto1
echo "$MAGIC Mitochondria, poly A positions with at least $limit supports (tags and distinct sequences, per strand" >> toto1
cat toto | gawk -F '\t' '/^ZZZZZ/{nt++;tissue[nt]=$2;next;}{x=$1;xx[x]+=$2+$3;for(i=2;i<=5;i++)nn[i+4*nt,x]+=$i;if(xmax<x)xmax=x;}END{printf("Position");for(i=2;i<=nt;i++)printf("\t%s tag +\t%s tag -",tissue[i],tissue[i]) ;for(i=2;i<=nt;i++)printf("\t%s seq +\t%s seq -",tissue[i],tissue[i]) ;for(x=1;x<=xmax;x++){if(xx[x]>=limit){printf("\n%d",x);for(i=2;i<=nt;i++)printf("\t%d\t%d",nn[2+4*i,x],nn[3+4*i,x]);for(i=2;i<=nt;i++)printf("\t%d\t%d",nn[4+4*i,x],nn[5+4*i,x]);}}printf("\n");}' limit=$limit >> toto1
\mv toto1 tmp/mito_wiggle/pA/table.$limit.txt
\cp  tmp/mito_wiggle/pA/table.$limit.txt RESULTS/$MAGIC.mito_polyAwiggle.limit$limit.txt


goto phaseLoop

#######################################################################################

cat tmp/mito_wiggle/pA/pA.1.*.ace  > toto.ace
# wpa.sx_pA.2010_02_11.ace

# count the categories
cat toto.ace | gawk '/^Feature/{ns[$6]++ ; nt[$6]+=$5;}END{for(t in ns)printf("%s\t%d\t%d\n",t,ns[t],nt[t]);}'

echo "query find sequence feature" > _bob
cat toto.ace | grep Feature | gawk '{printf ("edit -D Feature %s\n", $2)}' | scripts/tab_sort -u  >> _bob
echo parse toto.ace >> _bob
echo save >> _bob
echo quit >> _bob

# bin/tacembly ~/yk < _bob
\rm toto.ace
\rm _bob

goto phaseLoop

#######################################################################################
#######################################################################################
## phase L1:  Measure the size of the double ended reads

phaseL1:
 echo -n "Phase L1 "
 date

# The pairs are UHR  73 74  // 76 77  // 80 81
#               Brain 55 56  // 59 60 // 62 63
# The loop is UHR (73 76 80)  Brain (55 59 62)
# on calcule la distance dans le premier target de chaque clone
foreach target (av)
  echo "$target"
  if (! -d tmp/Double) mkdir  tmp/Double
  foreach manip ($manips_fastc_paired)
    if (! -d tmp/Double/$manip) mkdir  tmp/Double/$manip
    foreach tissue ($tissues)
      if (! -d tmp/Double/$run) $mkDir  Double $run
      if (! -e tmp/Double/$run/length.histo.txt) then
        set toto=tmp/Double/$run/toto.$$
        touch $toto
        foreach lane (`cat Fast[ac]/lanes | $tab_sort -u`)
          if (-e tmp/$MAGIC_COUNT_DIR/$run/$lane.bestg.gz) then
            scripts/lnAliErr.count.tcsh bestg $manip $tissue $lane E_av >> $toto
          endif
        end
        cat $toto | gawk -F '\t' '{p=$1;if(p==oldp) next; i=index(p,"/");if(i==0)next;clo=substr(p,1,i-1);st=substr(p,i,2);mrna=$5; if(mm[clo]>=3)next;if(mm[clo]>0 && mmr[clo]!=mrna)next;mmr[clo]=mrna;a1=$9;a2=$10;mult=$8;if(mult==0)mult=1;if(st=="/1"){if(mm[clo]==1)next;mm[clo]++;ma1[clo]=a1;}else {if(mm[clo]==2)next;mm[clo]+=2;mb1[clo]=a1;}if(mm[clo]==3){dx=mb1[clo]-ma1[clo]+1;if(dx<0)dx=-dx;if(dx>1000)dx=1000;nn[dx]+=mult;}}END{for(dx=0;dx<=1000;dx++)if(nn[dx]>0)printf("%d\t%d\n",dx,nn[dx]);}' >  tmp/Double/$run/length.histo.txt
        \rm $toto
      endif
    end
  end
end

goto phaseLoop

gnuplot -bg white
  plot [150:400] 'myhisto', 78000 * exp (-(x-264)*(x-264)/280)

#######################################################################################
#######################################################################################
## phase L2:  Measure the transplicing in the mito

phaseL2:
 echo -n "Phase L2 "
 date

# The pairs are UHR  73 74  // 76 77  // 80 81
#               Brain 55 56  // 59 60 // 62 63
# The loop is UHR (73 76 80)  Brain (55 59 62)
# on calcule la distance dans le premier target de chaque clone
set pairedLanes="UHR.73 UHR.74 UHR.76 UHR.77 UHR.80 UHR.81 Brain.55 Brain.56 Brain.59 Brain.60 Brain.62 Brain.63" 
if (! -d tmp/Transplicing) mkdir tmp/Transplicing
foreach target (mito)
  set bonus=0
  if ($target == genome) set bonus=0
  if ($target == cloud)  set bonus=-6
  if ($target == rnaGene) set bonus=10
  if ($target == mito) set bonus=10
  set targetBonus="-targetBonus $bonus"
  if (! -d tmp/Transplicing/$target) mkdir tmp/Transplicing/$target
  foreach manip (ILM_nS)
    set isSolid=" "
    foreach manip2 ($manips_ccfa)
      if ($manip == $manip2) set isSolid=".ccfa"
    end
    set clipPolyA=" "
    set clipPolyT=" "
    foreach manip2 ($manipsPolyA)
      if ($manip == $manip2) then
        set clipPolyA="-clipPolyA"
        foreach manip3 ($manips_fastc_non_stranded)
          if ($manip == $manip3) set clipPolyT="-clipPolyT"
        end
      endif
    end

    set isSplice=" "
    if ($target == genome || $target == mito) then
      foreach run2 (`cat MetaDB/$MAGIC/RunRnaList`)
        if ($run == $run2) then
          set isSplice="-splice"
        endif
      end
      if ($species == worm) set slBonus="-slBonus 5"
    endif
    foreach tissue ($tissues)
      if (! -d tmp/Transplicing/$target/$tissue) mkdir tmp/Transplicing/$target/$tissue

      foreach lane ($pairedLanes)
echo "hello $lane"
ls -ls Fasta/$manip/$lane.fastq
        if (! -e Fasta/$manip/$lane.fastq) continue
        set qq=q
        if ($?manips_fastq_33) then
          foreach manip2 ($manips_fastq_33)
            if ($manip == $manip2) set qq=fastq33
          end
        endif
        if ($?manips_fastq_64) then
          foreach manip2 ($manips_fastq_64)
            if ($manip == $manip2) set qq=fastq64
          end
        endif
          if (-e tmp/Transplicing/$target/$tissue/$lane.hits) continue
            scripts/submit tmp/LOGS/$manip.$tissue.$lane.$off.$target  "bin/clipalign -$qq -i Fasta/$manip/$lane.fastq $isSolid -t TARGET/Targets/$species.$target.fasta.gz  -maxHit 10 -clipPolyA  $clipPolyT -minEntropy $minEntropy -seedLength $seedLength -minAli $minAli $isSplice  $targetBonus   -seedOffset $off -silent > tmp/Transplicing/$target/$tissue/$lane.hits"
        end

    end
  end
end

goto phaseLoop

foreach tissue ($tissues)
  cat  tmp/Transplicing/mito/$tissue/*hits | gawk -F '\t' '/chondria/{a1=$8;a2=$9;if(a1<500 && a2<500)print $1}' | $tab_sort -u >  tmp/Transplicing/$tissue.probes.list
end
foreach tissue ($tissues)
  cat tmp/Transplicing/$tissue.probes.list ZZZZZ tmp/Transplicing/mito/$tissue/*hits | gawk -F '\t' '/^ZZZZZ/{zz=1;next;}{p=$1; i=index(p,"/");clo=substr(p,1,i-1);if(zz==0){cloclo[clo]=1;next;}if(cloclo[clo])print}' | grep HIT | $tab_sort >  tmp/Transplicing/$tissue.pairs.hits
end

#count the orientations
foreach tissue ($tissues)
  echo "$tissue pairs"
  cat tmp/Transplicing/mito/$tissue/*hits | gawk -F '\t' '/HIT/{p=$1;a1=$8;a2=$9; i=index(p,"/");clo=substr(p,1,i-1);s=0+substr(p,i+1);if(a1<a2)pp[clo,s]++;else mm[clo,s]++;allp[clo]=1;}END{for(clo in allp){if((pp[clo,1]>0 && mm[clo,2]>0) || (pp[clo,2]>0 && mm[clo,1]>0))antipara++;if((pp[clo,1] + mm[clo,1]>0 && pp[clo,2] + mm[clo,2] == 0 ) || (pp[clo,1] + mm[clo,1] == 0 && pp[clo,2] + mm[clo,2] > 0 )) orphan++ ;}printf("para %d antipara %d orphan %d\n",para, antipara, orphan);}'
end
# select the anomalous parallel pairs
foreach tissue ($tissues)
  echo "$tissue para"
  cat  tmp/Transplicing/mito/$tissue/*hits | gawk -F '\t' '/HIT/{p=$1;a1=$8;a2=$9; i=index(p,"/");clo=substr(p,1,i-1);s=0+substr(p,i+1);if(a1<a2)pp[clo,s]++;else mm[clo,s]++;allp[clo]=1;}END{for(clo in allp){if((pp[clo,1]>0 && mm[clo,1]>0) || (pp[clo,2]>0 && mm[clo,2]>0))printf("%s/\n", clo);}}' >   tmp/Transplicing/$tissue.para.list
end

# export the anomalous parallel pairs
foreach tissue ($tissues)
  echo "$tissue para"
  cat    tmp/Transplicing/$tissue.para.list  ZZZZZ tmp/Transplicing/mito/$tissue/*hits | gawk -F '\t' '/^ZZZZZ/{zz=1;next;}{p=$1; i=index(p,"/");clo=substr(p,1,i-1);if(zz==0){cloclo[clo]=1;next;}if(cloclo[clo])print}' | grep HIT | $tab_sort >  tmp/Transplicing/$tissue.parahits
end

# histogram of clone coverage including the probes themselves
foreach tissue ($tissues)
  cat  tmp/Transplicing/mito/$tissue/*hits | grep chondria | gawk -F '\t' '/HIT/{p=$1;score=0+$2;if(score<50)next;a1=$8;a2=$9; if (a1<1000)a1+=16500;if(a2<1000)a2+=16500;i=index(p,"/");clo=substr(p,1,i-1);s=0+substr(p,i+1);if(a1<a2)pp[clo,1]=a1;if(a1>a2)pp[clo,2]=a1;allp[clo]=1;}END{for(clo in allp){a1=pp[clo,1];a2=pp[clo,2];if (a1 > 0 && a2 > 0)for(x=a1+1;x<a2;x++)zz[x]++;}for (x in zz)printf("%d\t%d\n",x,zz[x]);}' | $tab_sort -k 1n >   tmp/Transplicing/$tissue.good.histo
end
foreach tissue ($tissues)
  cat tmp/Transplicing/$tissue.good.histo  | gawk '{if($2>500)$2=500;print}'> tmp/Transplicing/$tissue.clipped.histo
end
# histogram of clone showing a deletion including the probes themselves
foreach tissue ($tissues)
  cat  tmp/Transplicing/mito/$tissue/*hits | grep chondria | gawk -F '\t' '/HIT/{p=$1;score=0+$2;if(score<50)next;a1=$8;a2=$9; if (a1<10000)a1+=16600;if(a2<10000)a2+=16600;i=index(p,"/");clo=substr(p,1,i-1);s=0+substr(p,i+1);if(a1<a2)pp[clo,1]=a1;if(a1>a2)pp[clo,2]=a1;allp[clo]=1;}END{for(clo in allp){a1=pp[clo,1];a2=pp[clo,2];if (a1 > 0 && a2 > 0 && a2-a1 > 500 && a2-a1 < 2000)for(x=a1+1;x<a2;x++)zz[x]++;}for (x in zz)printf("%d\t%d\n",x,zz[x]);}' | $tab_sort -k 1n >   tmp/Transplicing/$tissue.deletion.histo
end
# histogram of pair lengths
foreach tissue ($tissues)
  cat  tmp/Transplicing/mito/$tissue/*hits | grep chondria | gawk -F '\t' '/HIT/{p=$1;score=0+$2;if(score<50)next;a1=$8;a2=$9; if (a1<10000)a1+=16600;if(a2<10000)a2+=16600;i=index(p,"/");clo=substr(p,1,i-1);s=0+substr(p,i+1);if(a1<a2)pp[clo,1]=a1;if(a1>a2)pp[clo,2]=a1;allp[clo]=1;}END{for(clo in allp){a1=pp[clo,1];a2=pp[clo,2];if (a1 > 0 && a2 > 0)zz[a2-a1]++;}for (x in zz)printf("%d\t%d\n",x,zz[x]);}' | $tab_sort -k 1n >   tmp/Transplicing/$tissue.pairlength.histo
  cat tmp/Transplicing/$tissue.pairlength.histo | gawk '{if($2>30)$2=30;print}' > tmp/Transplicing/$tissue.clippedpairlength.histo
end

gnuplot -bg white
plot [1:20000] 'tmp/Transplicing/Brain.histo' title 'Brain' , 'tmp/Transplicing/UHR.histo' title 'UHR'
plot [1:2000] 'tmp/Transplicing/Brain.histo' title 'Brain' , 'tmp/Transplicing/UHR.histo' title 'UHR'
plot [300:620] 'tmp/Transplicing/Brain.good.histo' title 'Brain' , 'tmp/Transplicing/UHR.good.histo' title 'UHR'
plot [15000:18000] 'tmp/Transplicing/Brain.clipped.histo' title 'Brain' , 'tmp/Transplicing/UHR.clipped.histo' title 'UHR'
plot [15000:18000] 'tmp/Transplicing/Brain.deletion.histo' title 'Brain' , 'tmp/Transplicing/UHR.deletion.histo' title 'UHR'
plot  'tmp/Transplicing/Brain.pairlength.histo' title 'Brain' , 'tmp/Transplicing/UHR.pairlength.histo' title 'UHR'


#######################################################################################
#######################################################################################
## phase LA: measure the autocorrelation of the polyA sites'

phaseLA:
 echo -n "Phase LA "
 date

# position chrom
foreach chrom ($chromSetAll)
end
if (! -d tmp/pA) mkdir tmp/pA
set toto=tmp/pA/$species.pA.correl.txt
date > $toto
echo "Autocorrelation of the polyA sites" >> $toto
echo -n "Limit\tManip\tTissue" >> $toto
echo toto | gawk '{for(i=0;i<=200;i++)printf("\t%d",i);printf("\n");}' >> $toto
foreach limit (5 2 1)
  foreach manip ($manips any)
    foreach tissue ($tissues)
      if (-e tmp/pA/$chrom/pA.candidate.$manip.$tissue.limit$limit) then
        echo -n "$limit\t$manip\t$tissue" >> $toto
        set m2=$manip
        if ($manip == "any") set m2='*'
        cat tmp/pA/*/pA.candidate.$m2.$tissue.limit$limit | $tab_sort | gawk -F '\t' '{c=$2 $3;x=$4;mult=$7;cc[c]++;i=cc[c];ccx[c,i]=x;mx[c,i]=mult;}END{for (c in cc){for (i=1;i<=cc[c];i++){x=ccx[c,i];a=mx[c,i];for(j=i;j<=cc[c];j++){y=ccx[c,j];b=mx[c,j];dx=y-x;if(dx<=200)correl[dx]+=a*b;else j=cc[c];}}}for(i=0;i<=200;i++)printf("\t%d",correl[i]);printf("\n");}' >> $toto
      endif
    end
  end
end
echo >> $toto
echo >> $toto
echo >> $toto
echo >> $toto

echo "Autocorrelation of the polyA sites, counted in sites" >> $toto
echo -n "Limit\tManip\tTissue" >> $toto
echo toto | gawk '{for(i=0;i<=200;i++)printf("\t%d",i);printf("\n");}' >> $toto
foreach limit (1)
  foreach manip ($manips any)
    foreach tissue ($tissues)
      if (-e tmp/pA/$chrom/pA.candidate.$manip.$tissue.limit$limit) then
        echo -n "$limit\t$manip\t$tissue" >> $toto
        set m2=$manip
        if ($manip == "any") set m2='*'
        cat tmp/pA/*/pA.candidate.$m2.$tissue.limit$limit | $tab_sort | gawk -F '\t' '{c=$2 $3;x=$4;mult=$7;cc[c]++;i=cc[c];ccx[c,i]=x;mx[c,i]=mult;}END{for (c in cc){for (i=1;i<=cc[c];i++){x=ccx[c,i];a=mx[c,i];for(j=i;j<=cc[c];j++){y=ccx[c,j];b=mx[c,j];dx=y-x;if(dx<=200)correl[dx]+=(a+b)/2;else j=cc[c];}}}for(i=0;i<=200;i++)printf("\t%d",correl[i]);printf("\n");}' >> $toto
      endif
    end
  end
end

cat $toto
\cp $toto RESULTS/$MAGIC.$species.pA.correl.txt
goto phaseLoop

#######################################################################################
#######################################################################################
##  pA3: report the polyA features

phasepA3:
echo -n "phase pA3: report the polyA statistics and features "
date

if (! -d tmp/pA) goto phaseLoop
set toto=tmp/pA/$MAGIC.pA_support_statistics.txt
echo -n '#' >! $toto
date >> $toto
echo "# Number of polyA addition site with given minimal support at least dx bases from each other" >> $toto
echo "# dx\tMinimal support\tpolyA" >> $toto
if (! -e tmp/pA/$MAGIC.pApT) then
  foreach run (`cat MetaDB/$MAGIC/RunList`)
    cat tmp/pA/$run/*/$run.1.?.txt >> tmp/pA/$MAGIC.pApT
    cat tmp/pT/$run/*/$run.1.?.txt | sed -e 's/^pA/pT/' >> tmp/pA/$MAGIC.pApT
  end
endif
foreach zz (1 2 5 10 20 50 100 1000 10000)
  cat tmp/pA/$MAGIC.pApT | gawk '{z=$2 "\t" $3 "\t" int((0+$4)/zz);if($1=="pA")nAT[z,1]+= $7;if($1=="pT")nAT[z,2]+= $7;nAT[z,0]+=$7;n[z]+= $7;}END{for(k in n)for (i=0;i<3;i++){x=nAT[k,i];nn[x]++;nnAT[x,i]++;n1AT[i]+=x;if(x>0)npaAT[i]++;}for(x in nn)for (i=0;i<3;i++){for(z=1;z<=1000000;z=10*z){for(a=1;a<=5;a++)if ((a==1 || a==2 || a==5) && 0+x>= a*z){nnz[a*z]=1;nnzAT[a*z,i]+=nnAT[x,i];}}}for(z in nnz)printf("%d\t%d\t%d\t%d\t%d\n",zz,z,nnzAT[z,0],nnzAT[z,1],nnzAT[z,2]);printf("%d\tTotal\t%d\tin %d pA/T %d pA %d pT %d both\n",zz,n1,npaAT[0],npaAT[1],npaAT[2],npaAT[1]+npaAT[2]-npaAT[0]);}' zz=$zz | scripts/tab_sort -k 1nr -k 2nr >> $toto
end

echo $toto
\cp $toto  RESULTS/Introns_exons_polyA

foreach chrom ($chromSetAll)
  if (! -d tmp/pA/$chrom) mkdir  tmp/pA/$chrom
  set toto=tmp/pA/$chrom/$MAGIC.pA_positions_and_support.$chrom.txt
  echo -n '#' >! $toto
  date >> $toto
  echo "# Position and total support of polyA addition sites" >> $toto
  echo "# Chromosome\tPosition\tStrand\tSupport\tpA\tpT" >> $toto
  cat tmp/pA/$MAGIC.pApT |  gawk -F '\t'  '{if($3 == chrom)print;}' chrom=$chrom | scripts/tab_sort -k 1,1 -k 4,4n |  gawk -F '\t' '{z=$3 "\t" int($4) "\t" $2;if($1=="pA")nA[z]+= $7;if($1=="pT")nT[z]+= $7;n[z]+= $7;}END{for(k in n)if(n[k]>=5)printf("%s\t%d\t%d\t%d\n",k,n[k],nA[k],nT[k]);}'  chrom=$chrom  | scripts/tab_sort -k 1,1n -k 2,2n >> $toto

  echo $toto
  \cp $toto  RESULTS/Introns_exons_polyA


  echo "$chrom\t$chrom\t1\t500000000" >  tmp/pA/$chrom/titi2
  cat tmp/pA/$MAGIC.pApT | gawk -F '\t'  '{if($3 == chrom)print;}' chrom=$chrom | scripts/tab_sort -k 1,1 -k 4,4n |  gawk -F '\t' '{if($3 != chrom)next;z=$3 "\t" int($4) "\t" $5;if($1=="pA")nA[z]+= $7;if($1=="pT")nT[z]+= $7;n[z]+= $7;}END{for(k in n)if(n[k]>=8)for(i=1;i<=n[k];i++)printf("%s\t%d\t%d\t%d\n",k,n[k],nA[k],nT[k]);}' chrom=$chrom > tmp/pA/$chrom/pA.coord

  bin/geneelements -stranded -cosmidWiggle tmp/pA/$chrom/titi2 -hitFile tmp/pA/$chrom/pA.coord -trackName $MAGIC -feature AAA_Sx_$MAGIC >  tmp/pA/$chrom/$MAGIC.pA.$chrom.feature.preace
  echo "Method AAA_Sx_$MAGIC\nScore_by_width\nScore_bounds 1 2\n\n" >  tmp/pA/$chrom/$MAGIC.pA.$chrom.feature.ace
  cat tmp/pA/$chrom/$MAGIC.pA.$chrom.feature.preace | grep Sequence >>  tmp/pA/$chrom/$MAGIC.pA.$chrom.feature.ace
  cat tmp/pA/$chrom/$MAGIC.pA.$chrom.feature.preace  | grep Feature | sort -k 3,3n >>  tmp/pA/$chrom/$MAGIC.pA.$chrom.feature.ace
  echo $chrom ; wc   tmp/pA/$chrom/$MAGIC.pA.$chrom.feature.ace
end

echo -n "pA3 done "
date
goto phaseLoop

 cat tmp/pA/*/pA.candidate.any.any.limit50 | cut -f 7,8 | gawk '{for(i=1;i<=$2;i++)print $1;}' | bin/dna2dna -I raw -O tc | bin/dna2dna -I tc -O fastc -complement > toto.fastc
 bin/dnamotif -p toto.fastc -hexamers 6 -width 30 -strand | more
 bin/dnamotif -p toto.fastc5 -Rhexamers 6 -c1 1 -c2 30 -a1 1 -a2 7 -strand | $tab_sort -k 3n

#######################################################################################
#######################################################################################
#######################################################################################
#######################################################################################
##  d0 collect aceview annotations 

phased0:

 echo -n "Phase d0 collect aceview annotations "
 date

cd TARGET/MRNAS

## grep the coordinates of all the known tg
if (-d ~/ee/SERVER/$species'_1' && ! -e mrnaStructure.txt) then
  echo "exporting mrnaStructure.txt from yk"
  bin/tacembly ~/ee/SERVER/$species'_1' <<EOF > /dev/null
    query find intron from_genefinder
    list -a -f introns.RefSeq.list
    query find intron from_gene // AND (gt_ag || gc_ag)
    list -a -f introns.av.list
    query find predicted_gene Model_of AND  nm_id
    dna $species.RefSeq.fasta
    bql -a -o  $species.RefSeq.transcript2gene.txt select pg,g from pg in @ , g in pg->Model_of
    query find mrna from_gene
    query find gene 
    query ! cloud && ! IS G_*
    query >transcribed_gene ; >mrna
    kstore my_mrnas
    kget my_mrnas
     dna -noClassName $species.av.fasta   // avoid writing MRNA:
    kget my_mrnas
    bql -a -o mrnaStructure.txt select mrna,chrom,m1,m2,a1,a2,x1,x2,type,feet,tg,g from mrna in @, tg in mrna->From_gene, g in tg->gene,chrom in mrna->intmap, m1 in chrom[1], m2 in m1[1], a1 in mrna->Splicing , a2 in a1[1], x1 in a2[1], x2 in x1[1], type in x2[1], feet in type[1]
    query find predicted_gene  Model_of AND  nm_id
    bql -a -o RefSeqStructure.txt select pg,chrom,a1,a2,x1,x2,type,g from pg in @, g in pg->model_of, chrom in pg->intmap, a1 in chrom[1], a2 in a1[1], x1 in pg->Source_Exons , x2 in x1[1], type in x2[1]
    kget my_mrnas
    query valid3p 
    bql -a -o mrnaStructurepA.txt select mrna,chrom,a1,a2,x1,g from mrna in @,tg in mrna->from_gene,g in tg->gene, chrom in mrna->intmap, a1 in chrom[1], a2 in a1[1], x1 in mrna->valid3p
    kget my_mrnas
    query Transpliced_to = SL* AND Transpliced_to > SL0 
    bql -a -o mrnaStructureSL.txt select mrna,chrom,a1,a2,sl,g from mrna in @,tg in mrna->from_gene,g in tg->gene, chrom in mrna->intmap, a1 in chrom[1], a2 in a1[1], sl in mrna->Transpliced_to
    kget my_mrnas
    query  COUNT {>Product ; good_product} > 0
    bql -a -o mrnaStructureCDS.txt select mrna,product,chrom,m1,m2,a1,a2,x1,x2,p1,p2,gene from mrna in @, product in mrna->product where (exists_tag product->Good_product and exists_tag product->Best_product) or exists_tag product->Very_good_product, chrom in mrna->intmap, m1 in chrom[1], m2 in m1[1], a1 in mrna->Splicing , a2 in a1[1], x1 in a2[1], x2 in x1[1], type in x2[1] where type like "xon", p1 in product[1], p2 in p1[1], gene in product->geneBox

    query find mrna 1* ; COUNT {>Product ; good_product} > 0
    aql -active -o toto1 select mrna,product,chrom,m1,m2,a1,a2,x1,x2,p1,p2,gene from mrna in @active:1, product in mrna->product where (exists_tag product->Good_product and exists_tag product->Best_product) or exists_tag product->Very_good_product, chrom in mrna->intmap, m1 in chrom[1], m2 in m1[1], a1 in mrna->Splicing , a2 in a1[1], x1 in a2[1], x2 in x1[1], type in x2[1] where type like "xon", p1 in product[1], p2 in p1[1], gene in product->geneBox
    undo
    bql -a -o toto2 select mrna,product,chrom,m1,m2,a1,a2,x1,x2,p1,p2,gene from mrna in @, product in mrna->product where (product#Good_product &&  product#Best_product) || product#Very_good_product, chrom in mrna->intmap, m1 in chrom[1], m2 in m1[1], a1 in mrna->Splicing , a2 in a1[1], x1 in a2[1], x2 in x1[1], type in x2[1] where type like "xon", p1 in product[1], p2 in p1[1], gene in product->geneBox



    query find gene genefinder && ! transcribed_gene ; > genefinder ; CDS && nm_id
    bql -a -o pgStop.txt select pg,chrom,a1,a2,x1,x2 from pg in @, chrom in pg->intmap, a1 in chrom[1], a2 in a1[1], x1 in pg->source_exons, x2 in x1[1]
    table -o tg2intron2support.txt -f /home/mieg/gall/tables/tg2intron2support.def 
    query find tg Intron_boundaries
    acem
      gene_intron 
      quit
    save
    find intron
    show -a -f $species.introns.ace
    quit
EOF
endif


# 2014_04_27  : all this code should be superseded by metadata.tcsh : acedb->gffdump->dna2dna
#               but I have not yet verified the equivalence

 mkdir ../WIGGLEREMAP
 cat  mrnaStructure.txt | gawk -F '\t' '/\"/{gsub(/\"/,"",$0);if($9~/xon/){mrna=$1;c=$2;m1=$3;m2=$4;a1=$5;a2=$6;x1=$7;x2=$8;gene=$12;if(m1<m2){u1=m1+a1-1;u2=m1+a2-1;}else {u1=m1-a1+1;u2=m1-a2+1;}printf("%s\t%s\t%d\t%d\t%s\t%d\t%d\t%s\n",targetClass,mrna,x1,x2,c,u1,u2,gene);}}' targetClass=ET_av > ../WIGGLEREMAP/mrnaRemap.av.txt33

 cat   mrnaStructureCDS.txt |  gawk -F '\t' '/\"/{gsub(/\"/,"",$0);mrna=$1;p=$2;c=$3;m1=$4;m2=$5;a1=$6;a2=$7;x1=$8;x2=$9;p1=$10;p2=$11;gene=$12;d1=0;if(x1<p1)d1=p1-x1;d2=0;if(x2>p2)d2=x2-p2;if(x1+d1>=x2-d2)next;a1=a1+d1;a2=a2-d2;if(m1<m2){u1=m1+a1-1;u2=m1+a2-1;}else {u1=m1-a1+1;u2=m1-a2+1;}printf("%s\t%s_CDS\t%d\t%d\t%s\t%d\t%d\t%s_CDS\n",target,mrna,x1+d1,x2-d2,c,u1,u2,gene);}' target=ET_av  > ../WIGGLEREMAP/cdsRemap.av.txt

 cat  ../WIGGLEREMAP/cdsRemap.av.txt | gawk -F '\t' '{if($2!=old)n=0;old=$2;n++;printf("%s\t%d\t%s\t%d\t%d\t%s\n",$2,n,$5,$6,$7,$8);}' > ../WIGGLEREMAP/av_cds.ns.sponge
# cat  ../WIGGLEREMAP/cdsRemap.seqc.txt | gawk -F '\t' '{if($2!=old)n=0;old=$2;n++;printf("%s\t%d\t%s\t%d\t%d\t%s\n",$2,n,$5,$6,$7,$8);}' > ../WIGGLEREMAP/seqc_cds.ns.sponge
cat  ../WIGGLEREMAP/cdsRemap.EBI.txt | gawk -F '\t' '{if($2!=old)n=0;old=$2;n++;printf("%s\t%d\t%s\t%d\t%d\t%s\n",$2,n,$5,$6,$7,$8);}' > ../WIGGLEREMAP/EBI_cds.ns.sponge

 cat   mrnaStructure.txt | gawk -F '\t' '/\"/{gsub(/\"/,"",$0);if($9~/xon/){mrna=$1;c=$2;m1=$3;m2=$4;if(m1<m2)dm=m2-m1+1;else dm=m1-m2+1;printf("%s\t%s\t%d\t%d\t%s\t%d\t%d\n",target,mrna,1,dm,c,m1,m2);}}' target=av | $tab_sort -u > ../WIGGLEREMAP/premrnaRemap.av.txt
  cat RefSeqStructure.txt | gawk '/NULL/{next}/\"/{gsub(/\"/,"",$0);m1=$3;m2=$4;a1=$5;a2=$6;if(m1<m2){u1=m1+a1-1;u2=m1+a2-1;}else{u1=m1-a1+1;u2=m1-a2+1;}if($1!=old){z2=0;}printf("%s\t%s\t%d\t%d\t%s\t%d\t%d\n",target,$1,z2+1,z2+$6-$5+1,$2,u1,u2);old=$1;z2+=$6-$5+1;}' target=RefSeq > ../WIGGLEREMAP/mrnaRemap.RefSeq.txt

 cat TARGET/WIGGLEREMAP/mrnaRemap.RefSeq.txt | gawk -F '\t' '{g=$8;chrom[g]=$5;m1=$6;m2=$7;if(m1<m2){if(g1[g]<1 || g1[g]>m1)g1[g]=m1;if(g2[g]<m2)g2[g]=m2;}else{if(g1[g]<1 || g1[g]<m1)g1[g]=m1;if(g2[g]<1 || g2[g]>m2)g2[g]=m2;}}END{for(g in chrom)printf("%s\t1\t%s\t%d\t%d\t%s\n",g,chrom[g],g1[g],g2[g],g);}' | $tab_sort > TARGET/WIGGLEREMAP/RefSeq.ns.gene.sponge


# some genes have no source_exons, because of format problem while parsing the NCBI models
# for these, like KIF5C in march 2011, we get a premessenger region as the dna, 55kb for KIF5C rather than a 6kb mRNA
# we want to kill them in the fasta file and in the mrnaRamap file
 cat RefSeqStructure.txt | gawk '/NULL/{gsub(/\"/,"",$0);m1=$3;m2=$4;if(m1<m2){u1=1;u2=m2-m1+1}else{u1=1;u2=m1-m2+1;}printf("%s\t%s\t%d\t%d\t%s\t%d\t%d\n",target,$1,u1,u2,$2,m1,m2);}' target=RefSeq > ../WIGGLEREMAP/mrnaRemap.bad_RefSeq.txt
cat ../WIGGLEREMAP/mrnaRemap.bad_RefSeq.txt | cut -f 2 | $tab_sort > ../WIGGLEREMAP/mrnaRemap.bad_RefSeq.names


$tacembly ../../ZZ <<EOF > /dev/null
  find sequence mito
  show -a -f mito.subseq.ace subsequence
EOF
cat mito.subseq.ace | gawk '/^Sub/{a1=$3;a2=$4;if(a1<a2)da=a2-a1+1;else da=a1-a2+1;gsub(/\"/,"",$0);printf("KT_RefSeq\t%s\t%d\t%d\tmito\t%d\t%d\n",$2,1,da,a1,a2);}' | sed -e 's/mito/gi|251831106|ref|NC_012920.1|/' | gzip  >  ..//WIGGLEREMAP/mrnaRemap.mito.txt.gz

# av_RefSeq is used by bestali.c: intron support, so we scan the best hits file only once
cd ..
cat  WIGGLEREMAP/mrnaRemap.RefSeq.txt | sed -e 's/^RefSeq/KT_RefSeq/' > WIGGLEREMAP/mrnaRemap.av_RefSeq.txt
cat WIGGLEREMAP/mrnaRemap.av.txt | sed -e 's/c_>gi/mito/g' > WIGGLEREMAP/mrnaRemap.av.txt1
mv  WIGGLEREMAP/mrnaRemap.av.txt1  WIGGLEREMAP/mrnaRemap.av.txt
cat  WIGGLEREMAP/mrnaRemap.av.txt | gawk -F '\t' '{printf("ET_av\t%s\t%s\t%s\t%s\t%s\t%s\n",$2,$3,$4,$5,$6,$7);}' >>  WIGGLEREMAP/mrnaRemap.av_RefSeq.txt
gzip WIGGLEREMAP/mrnaRemap.av_RefSeq.txt

cd MRNAS
mv $species.RefSeq.fasta.gz $species.RefSeq_including_bad.fasta.gz
$bin/dna2dna -i $species.RefSeq_including_bad.fasta.gz -I fasta -reject ../WIGGLEREMAP/mrnaRemap.bad_RefSeq.names -O fasta | gzip > $species.RefSeq.fasta.gz
\rm  $species.RefSeq_including_bad.fasta

gunzip -c $species.av.fasta.gz | gawk '/^>/{split($1,aa, "|");printf("\"%s\"\t\"%s\"\n",substr(aa[1],2),aa[3]);}' > $species.av.transcript2gene.txt
gunzip -c $species.RefSeq.fasta.gz | gawk '/^>/{split($1,aa, "|");printf("\"%s\"\t\"%s\"\n",substr(aa[1],2),aa[3]);}' > $species.RefSeq.transcript2gene.txt
gzip $species.av.fasta 
# gzip $species.introns.ace
gzip $species.RefSeq.transcript2gene.txt

# element
gunzip -c $species.RefSeq.transcript2gene.txt.gz | gawk -F '\t' '{printf("Genefinder %s\nModel_of %s\n\n",$1,$2);}' | gzip >  $species.RefSeq.RefSeq2g2mrna.ace.gz


cat $species.av.tg2g2mrna.txt | gawk -F '\t' '{printf("%s\t%s\n",$3,$1);}' > $species.av.transcript2gene.txt
gzip $species.av.transcript2gene.txt

cd ..


gunzip -c WIGGLEREMAP/mrnaRemap.av_RefSeq.txt.gz | gawk -F '\t' '/KT_RefSeq/{mrna=$2;chrom=$5;a1=$6;a2=$7;if(mrna==old  &&  (a1 > b2 + 10 || a1 < b2 - 10)){if(a1<a2){u1=b2+1;u2=a1-1;}else{u1=b2-1;u2=a1+1;}printf("Intron %s__%d_%d\nRefSeq\nIntMap %s %d %d\nFrom_genefinder %s\n\n",chrom,u1,u2,chrom,u1,u2,mrna);}old=mrna;b1=a1;b2=a2;}' > WIGGLEREMAP/mrnaRemap.RefSeq2introns.ace
gunzip -c WIGGLEREMAP/mrnaRemap.av_RefSeq.txt.gz | gawk -F '\t' '/ET_av/{mrna=$2;gsub(/MRNA:/,"",mrna);chrom=$5;a1=$6;a2=$7;if(mrna==old && (a1 > b2 + 10 || a1 < b2 - 10)){if(a1<a2){u1=b2+1;u2=a1-1;}else{u1=b2-1;u2=a1+1;}printf("Intron %s__%d_%d\nav\nIntMap %s %d %d\nIn_mRNA %s\n\n",chrom,u1,u2,chrom,u1,u2,mrna);}old=mrna;b1=a1;b2=a2;}' >> WIGGLEREMAP/mrnaRemap.RefSeq2introns.ace

if (-e  WIGGLEREMAP/mrnaRemap.av_RefSeq_seqc.txt.gz) then
  foreach chrom ($chromSetAll)
    gunzip -c WIGGLEREMAP/mrnaRemap.av_RefSeq_seqc.txt.gz | gawk -F '\t' '{if ($5 == chrom)print}END{printf("Z_genome\t%s\nZ_genome\tCHROMOSOME_%s\n",chrom,chrom);}' chrom=$chrom | gzip >  WIGGLEREMAP/mrnaRemap.av_RefSeq_seqc.$chrom.txt.gz &
  end
endif

foreach chrom ($chromSetAll)
  gunzip -c WIGGLEREMAP/mrnaRemap.av_RefSeq.txt.gz | gawk -F '\t' '{if ($5 == chrom)print}END{printf("Z_genome\t%s\nZ_genome\tCHROMOSOME_%s\n",chrom,chrom);}' chrom=$chrom | gzip >  WIGGLEREMAP/mrnaRemap.av_RefSeq.$chrom.txt.gz &
  cat WIGGLEREMAP/mrnaRemap.av.txt | gawk '{if ($5 == chrom || $5 == "CHROMOSOME_" chrom)print}' chrom=$chrom >  WIGGLEREMAP/mrnaRemap.av.$chrom.txt
  cat WIGGLEREMAP/cdsRemap.av.txt  | gawk '{if ($5 == chrom || $5 == "CHROMOSOME_" chrom)print}' chrom=$chrom >  WIGGLEREMAP/mrnaRemap.avcds.$chrom.txt
  cat WIGGLEREMAP/premrnaRemap.av.txt | gawk '{if ($5 == chrom || $5 == "CHROMOSOME_" chrom)print}' chrom=$chrom >  WIGGLEREMAP/mrnaRemap.avpremrna.$chrom.txt
  cat WIGGLEREMAP/mrnaRemap.RefSeq.txt | gawk '{if ($5 == chrom || $5 == "CHROMOSOME_" chrom)print}' chrom=$chrom >  WIGGLEREMAP/mrnaRemap.RefSeq.$chrom.txt
end

gunzip -c WIGGLEREMAP/mrnaRemap.av_RefSeq.txt.gz > WIGGLEREMAP/mrnaRemap.av_RefSeq_genome.txt
foreach chrom ($chromSetAll)
  echo toto | gawk  '{printf("Z_genome\t%s\nZ_genome\tCHROMOSOME_%s\n",chrom,chrom);}' chrom=$chrom >> WIGGLEREMAP/mrnaRemap.av_RefSeq_genome.txt
end
gzip WIGGLEREMAP/mrnaRemap.av_RefSeq_genome.txt

foreach chrom ($chromSetAll)
  foreach target (av RefSeq avcds avpremrna)
    cat WIGGLEREMAP/mrnaRemap.$target.$chrom.txt | gawk -F '\t' '{c=$5;a1=$6;a2=$7; if(a1<a2)printf("%s\t%d\t%d\n",c,a1,a2);}'  | $tab_sort -u -k 1,1 -k 2,2n -k 3,3n |  gawk -F '\t' '{c=$1;a1=$2;a2=$3;if(a1>olda2){if(oldc)printf("%s\t%d\t%d\n",oldc,olda1,olda2);oldc=c;olda1=a1;olda2=a2;}if(a2>olda2)olda2=a2;}END{printf("%s\t%d\t%d\n",oldc,olda1,olda2);}' >  WIGGLEREMAP/filterRemap.$target.$chrom.txt
    cat WIGGLEREMAP/mrnaRemap.$target.$chrom.txt | gawk -F '\t' '{c=$5;a1=$7;a2=$6; if(a1<a2)printf("%s\t%d\t%d\n",c,a1,a2);}'  | $tab_sort -u -k 1,1 -k 2,2n -k 3,3n |  gawk -F '\t' '{c=$1;a1=$2;a2=$3;if(a1>olda2){if(oldc)printf("%s\t%d\t%d\n",oldc,olda2,olda1);oldc=c;olda1=a1;olda2=a2;}if(a2>olda2)olda2=a2;}END{printf("%s\t%d\t%d\n",oldc,olda2,olda1);}' >>  WIGGLEREMAP/filterRemap.$target.$chrom.txt
  end
end

cd MRNAS
cat introns.RefSeq.list |  sed -e 's/CHROMOSOME_//g' | gawk -F '_' '/Intron/{gsub(/Intron \"/,"",$1);printf("%s\t%09d\t%09d\n",$1,$3,$4);}' | $tab_sort -u >  introns_RefSeq.txt
cat introns.av.list |  sed -e 's/CHROMOSOME_//g' | gawk -F '_' '/Intron/{gsub(/Intron \"/,"",$1);printf("%s\t%09d\t%09d\n",$1,$3,$4);}' | $tab_sort -u >  introns_av.txt

goto phaseLoop

################

goto phaseLoop

###################################################################################
## export known introns other mysterious version

phased0b:

 echo -n "Phase d0b mysterious "
 date

  if (! -e  tmp/introns/$chrom/introns_nm.txt) then
    echo "get introns_nm $chrom"
    bin/tacembly ../ZH$chrom <<EOF > /dev/null
      query find intron NM
      list -a -f tmp/introns/$chrom/intron_nm.list
      quit
EOF
    cat tmp/introns/$chrom/intron_nm.list | gawk -F '\t' '/^Intron/{gsub(/\"/,"",$1);gsub(/_/," ",$1);print $1}' | gawk '{printf("%s\t%09d\t%09d\n",$2,$3,$4);}' | $tab_sort -u  > tmp/introns/$chrom/introns_nm.txt
  endif


goto phaseLoop 

####################################################################################
query find intron from_gene && NOT fuzzy
list -a -f intron_from_gene_not_fuzzy.list
cat  intron_from_gene_not_fuzzy.list | gawk '/^Intron/{gsub(/\"/,"",$2);print $2}' | gawk -F '_' '{printf("%s_%s\t%09d\t%09d\n",$1,$2,$4,$5);}' | $tab_sort > tmp/introns/introns_cDNA_non_fuzzy.txt

cat tmp/OR/III/OR.candidate.YK.any.limit1 | gawk '{c=$3;a1=$4+0;a2=$5+0;gsub(/CHROMOSOME_/,"",c);printf("%s__%d_%d\n",c,a1,a2);}' > toto.yk

# introns found de novo using the clones, compared to non fuzzy introns in aceview classic
gunzip -c  tmp/OR/*/d1.*.de_uno.txt.gz |  grep CHROMOSOME_III | cut -f 2,3,4 | $tab_sort -u > toto1
echo ZZZZZ >> toto1
cat introns/introns_cDNA.txt | grep CHROMOSOME_III | $tab_sort -u >> toto1
cat toto1 | gawk '/^ZZZZZ/{zz=1;next;}{a1=$2+0;a2=$3+0;ii[$1 "\t" a1 "\t" a2]+=zz+1;}END{for (k in ii)if(ii[k]!=3)printf("%s\t%d\n",k,ii[k]);}' | $tab_sort -k 1,1 -k 2,2n -k 3,3n > toto2
cat toto2 | gawk 'BEGIN{printf("Sequence CHROMOSOME_III\n");}{a[1]="Intron_new";a[2]="Intron_missed";printf ("Feature %s  %d %d\n",a[$4],$2+0,$3+0);}' > toto2.ace

# introns spanned (double search) using the clones, compared to non fuzzy introns in aceview classic
grep Intron tmp/EHITS.$MAGIC/III/double.any.Classic.III.ace | $tab_sort -u | gawk '{print $2}' | gawk -F '_' '{printf("CHROMOSOME_%s\t%09d\t%09d\n",$1,$3,$4);}' | $tab_sort > toto3
cat toto3 | $tab_sort -u > toto1
echo ZZZZZ >> toto1
cat tmp/introns/introns_cDNA_non_fuzzy.txt | grep CHROMOSOME_III | $tab_sort -u >> toto1
cat toto1 | gawk '/^ZZZZZ/{zz=1;next;}{ii[$1 "\t" $2 "\t" $3]+=zz+1;}END{for (k in ii)if(ii[k]!=3)printf("%s\t%d\n",k,ii[k]);}' | $tab_sort > toto2
cat toto2 | gawk 'BEGIN{printf("Sequence CHROMOSOME_III\n");}{a[1]="Intron_spanned";a[2]="Intron_not_spanned";printf ("Feature %s  %d %d\n",a[$4],$2+0,$3+0);}' > toto3.ace

# introns spanned (double search) using the clones, compared to introns found de novo using the clones
grep Intron tmp/EHITS.$MAGIC/III/double.any.Classic.III.ace | $tab_sort -u | gawk '{print $2}' | gawk -F '_' '{printf("CHROMOSOME_%s\t%09d\t%09d\n",$1,$3,$4);}' | $tab_sort > toto3
cat toto3 | $tab_sort -u > toto1
echo ZZZZZ >> toto1
cat tmp/OR/III/OR.candidate.YK.any.limit1 | cut -f 3,4,5 >> toto1
cat toto1 | gawk '/^ZZZZZ/{zz=1;next;}{ii[$1 "\t" $2 "\t" $3]+=zz+1;}END{for (k in ii)if(ii[k]!=3)printf("%s\t%d\n",k,ii[k]);}' | $tab_sort > toto2
cat toto2 | gawk 'BEGIN{printf("Sequence CHROMOSOME_III\n");}{a[1]="Intron_missed_but_spanned";a[2]="Intron_denovo_not_spanned";printf ("Feature %s  %d %d\n",a[$4],$2+0,$3+0);}' > toto4.ace
grep -c Intron_denovo_not_spanned toto4.ace
grep -c Intron_missed_but_spanned  toto4.ace


#######################################################################################
#######################################################################################
## phase d1:   collect the de_uno introns

phased1:
  echo -n "Phase d1:   collect the de_uno introns $Strategy "
  date

if (! -d RESULTS/Introns_exons_polyA) mkdir RESULTS/Introns_exons_polyA


if (1 || $Strategy == RNA_seq) then
  if (! -d tmp/OR) mkdir tmp/OR
  foreach run (`cat MetaDB/$MAGIC/RunList`) 
      if ((-d tmp/MAGICBLAST/$run ||-d tmp/PHITS_genome/$run || -d tmp/PHITS_SpikeIn/$run)  && ! -e tmp/OR/$run/d1.de_uno.done) then
        if (! -d  tmp/OR/$run) $mkDir OR $run
        scripts/submit tmp/OR/$run/d1.de_uno  "scripts/d1.de_uno.tcsh $run"
      endif
  end 
endif

goto phaseLoop

#######################################################################################
## phase SLpA1:   Collect the pA, pT, SL in each run
phaseSLpA1:

if (! -d tmp/SLpA) mkdir tmp/SLpA
foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (! -e tmp/SLpA/$run.SLpA.gz) then
    scripts/submit "tmp/SLpA/$run.SLpA1" "scripts/SLpA.tcsh collect $run"
  endif
end

goto phaseLoop

#######################################################################################
## phase SLpA2:   Collect the pA, pT, SL in each run
phaseSLpA2:

if (! -d tmp/SLpA) mkdir tmp/SLpA

set groupLevelMax=`cat  MetaDB/$MAGIC/g2r | cut -f 3 | sort -k 1n | tail -1`
foreach level (0)
  echo level=$level
  foreach group (`cat MetaDB/$MAGIC/r2sublib | gawk '{print $1;}' | sort -u`)
    scripts/SLpA.tcsh merge $group
  end
end
foreach level (`seq 1 1 $groupLevelMax`)
  echo level=$level
  foreach group (`cat MetaDB/$MAGIC/g2r | gawk '{if($3==level)print $1;}' level=$level | sort -u`)
    scripts/SLpA.tcsh merge $group
  end
end

goto phaseLoop

#######################################################################################
phaseSLpA3:

if (-d tmp/SLpA) then
  echo -n "## SLpA $MAGIC " >  tmp/SLpA/$MAGIC.txt
  date >>  tmp/SLpA/$MAGIC.txt
  foreach run (`cat MetaDB/$MAGIC/RunList  MetaDB/$MAGIC/RunsList   MetaDB/$MAGIC/GroupList | sort -u`)
    zcat tmp/SLpA/$run.SLpA.gz | gawk -F '\t' '{n[$1]++;nn[$1]+=$5;}END{for (k in n)printf("%s\t%s\t%d\t%d\n",run,k,n[k],nn[k]);}' run=$run | sort -V >> tmp/SLpA/$MAGIC.txt
  end
  cat tmp/SLpA/$MAGIC.txt | sort -V | gawk -F '\t' '/^#/{next}{if(NF>3){if($1 != old){printf("\nAli \"%s\"\n-D SLs\n",$1);old=$1;}printf("SLs %s %d sites %d supports\n",$2,$3,$4);}}END{printf("\n");}' >  tmp/SLpA/$MAGIC.ace
  echo "pparse  tmp/SLpA/$MAGIC.ace" | bin/tacembly MetaDB -noprompt
endif
goto phaseLoop

#######################################################################################
#######################################################################################
## phase tgf1: collect the RNA-seq gene-fusions

phasetgf1:
if ($Strategy != RNA_seq) goto phaseLoop

  echo -n "Phase tgf1 collect the gene_fusions: "
  date
if (! -d RESULTS/GeneFusion) mkdir RESULTS/GeneFusion

set target=av
foreach run (`cat MetaDB/$MAGIC/RunsList`)
   if (! -d RESULTS/GeneFusion/$run) $mkDir GeneFusion $run
   if (! -e tmp/GeneFusion/$run/t1.gene_fusion.av.txt.gz) then
    scripts/submit tmp/GeneFusion/$run/t1 "scripts/t1.gene_fusion.tcsh t1 $run $target"
  endif
end

goto phaseLoop

#######################################################################################
## phase tgf2:   report the RNA-seq gene-fusions

# ATTENTION scripts/GeneFusion.tcsh draft  has lots of stuff on geneLinks developped at the time of the NB project

phasetgf2: 
if ($Strategy != RNA_seq) goto phaseLoop
foreach level (1 2 3 4 5 6 7 8 9)
  foreach target (av)
    foreach group (`cat MetaDB/$MAGIC/g2r | gawk -F '\t' '{if ($3 == level)print $1;}' level=$level | sort -u`)
      set ok=0
      foreach g (`cat MetaDB/$MAGIC/GroupGeneFusionList`)
        if ($g == $group) set ok=1
      end
      if ($ok == 0) continue 
      if (! -d  tmp/GeneFusion/$group) mkdir  tmp/GeneFusion/$group
      if (! -e tmp/GeneFusion/$group/t1.gene_fusion.$target.txt.gz) then 
        scripts/submit tmp/GeneFusion/$group/t2 "scripts/t1.gene_fusion.tcsh t2 $group $target"
      endif
    end
  end
  echo "tgf2 $level done"
  scripts/submit wait
end

goto phaseLoop

phaset3: 
   scripts/t1.gene_fusion.tcsh t3 
goto phaseLoop

#######################################################################################
#######################################################################################
## phase t1: collect the RNA-seq transloc

phaset1:
  echo -n "Phase t1 collect the translocations runs: "
  date
if (! -d RESULTS/Transloc) mkdir RESULTS/Transloc

set target=genome
if ($Strategy == RNA_seq) set target=av
foreach run (`cat MetaDB/$MAGIC/RunsList`)
  if (! -d RESULTS/Transloc/$run) $mkDir Transloc $run
  if (! -e tmp/Transloc/$run/t1.transloc.$target.txt.gz) then
    scripts/submit tmp/Transloc/$run/t1 "scripts/t1.transloc.tcsh t1 $run $target"
  endif
end

goto phaseLoop

#######################################################################################
## phase t2:   report the RNA-seq gene-fusions

# ATTENTION scripts/Transloc.tcsh draft  has lots of stuff on geneLinks developped at the time of the NB project

phaset2: 

if (! -d tmp/Transloc) goto phaseLoop

set target=genome
if ($Strategy == RNA_seq) set target=av
foreach level (1 2 3 4 5 6 7 8 9)
  foreach target (av)
    foreach group (`cat MetaDB/$MAGIC/g2r | gawk -F '\t' '{if ($3 == level)print $1;}' level=$level | sort -u`)
      set ok=0
      foreach g (`cat MetaDB/$MAGIC/GroupTranslocList`)
        if ($g == $group) set ok=1
      end
      if ($ok == 0) continue 
      if (! -d  tmp/Transloc/$group) mkdir  tmp/Transloc/$group
      if (! -e tmp/Transloc/$group/t1.transloc.$target.txt.gz) then 
        scripts/submit tmp/Transloc/$group/t2 "scripts/t1.transloc.tcsh t2 $group $target"
      endif
    end
  end
  echo "t2 $level done"
  scripts/submit wait
end

goto phaseLoop

phaset3: 
   scripts/t1.transloc.tcsh t3 
goto phaseLoop

#######################################################################################
## phase d2:   Ventilate overhangs  results per chromosome

phased2:
  echo -n "Phase d2 collect the alignment overhangs per chromosome"
  date
if ($Strategy != RNA_seq || $USEMAGICBLAST == 1) goto phaseLoop

  if (! -d tmp/OR) mkdir tmp/OR
  foreach run (`cat MetaDB/$MAGIC/RunList`)
    if (! -e tmp/OR/$run/d2.$run.ventilate.err ) then
      scripts/submit "tmp/OR/$run/d2.$run.ventilate" "scripts/d2.ventilate.tcsh $run"
    endif
  end


echo "phase d2 done"
goto phaseLoop

###############################################################
## phase d3:  compute the de_duo introns

phased3:
 echo -n "Phase d3 "
 date

# the pA2d3 reentry is called for pA2
phasepA2d3:
# 2019-10-21 SEQC2 project, i think this is obolete, the new d4 intron search combining MRNA and geneome discovery seems better
goto phaseLoop

# if ($Strategy != RNA_seq) goto phaseLoop

if ($Strategy == Exome) then
  if (! -d  RESULTS/SNV) mkdir RESULTS/SNV
   if (! -d RESULTS/SNV/TRANSLOC) mkdir RESULTS/SNV/TRANSLOC

  if (! -d tmp/Transloc) mkdir tmp/Transloc

   # collate the de_uno accross all runs
  if (! -e  tmp/Transloc/any.transloc.txt) then
    set ok=0
    if (-e tmp/Transloc/_t) \rm tmp/Transloc/_t
    touch  tmp/Transloc/_t
    foreach run (`cat MetaDB/$MAGIC/RunList`)
       if (-e  tmp/Transloc/$run/d1.transloc.txt.gz) then
         if ($ok == 0) then
           zcat  tmp/Transloc/$run/d1.transloc.txt.gz | head -30 | gawk -F '\t' '/^#/{printf("%s\t%s\tNumber of supporting runs\t%s\t%s\t%s\t%s\t%s\t%s",$1,$2,$3,$4,$5,$6,$7,$8);;exit}' > tmp/Transloc/d1.anyrun.transloc.txt
           set ok=1
         endif
         gunzip -c tmp/Transloc/$run/d1.transloc.txt.gz >>  tmp/Transloc/_t
       endif
    end
    # the _t file has the coordinates of the last base of the donor acceptor exon, we want the coordinates of the del or dup 
    cat  tmp/Transloc/_t | gawk -F '\t' '/^#/{next;}/DELETION/{$7++;$9--;}/DUPLICATION/{a=$7;$7=$9;$9=a;}{z = $4 "\t" $5 "\t" $6 "\t" $7 "\t" $8 "\t" $9 ;n1[z]+=$1;n2[z]+=$2;n3[z]++;}END{for(z in n1)printf("%d\t%d\t%d\t%s\n",n1[z],n2[z],n3[z],z);}' | sort -k 1,1nr >>  tmp/Transloc/d1.anyrun.transloc.txt
    cat  tmp/Transloc/d1.anyrun.transloc.txt | gawk '/^#/{print;next;}{if($1 >=4) print;}' > RESULTS/SNV/$MAGIC.transloc.de_uno.txt
  endif

  foreach run (`cat MetaDB/$MAGIC/RunList`)
    if (! -d  tmp/Transloc/$run) $mkDir  Transloc $run
    if (! -e  tmp/Transloc/$run/d3.$run.de_duo.txt) then
      scripts/submit tmp/Transloc/$run/d3.$run "scripts/d3.transloc.tcsh $run"
    endif
  end

  goto phaseLoop
endif



if (! -d tmp/introns) mkdir tmp/introns

set ici=`pwd`
#  GroupDeDuoList Rhs4 Rhs5 Rhs6 Rhs7 Rhs8
foreach run (`cat MetaDB/$MAGIC/RunList`)
  foreach chrom ($chromSetAll)
# useless if we only scan RunList

    foreach section (0 1 2 3 4 5 6 )
      set minX=1
      set maxX=1000000000
      if ($chrom == 1 || $chrom == 2 || $chrom == 3 || $chrom == 4 || $chrom == 5) then
        @ minX = $section * 50000000
        @ maxX = (1 + $section) * 50000000 + 30000
        # echo "$minX $maxX $section"
      else
        if ($section > 0) continue
      endif
      if ($species == worm && $chrom == "I") set maxX=15060281
  # $manips any  20 10 5 3 2 1)
      if (! -d tmp/OR/$run/$chrom) continue
      if (-e tmp/OR/$run/$chrom/d3.de_duo_loop.$run.$section.all.done) continue
      echo "d3.de_duo_loop.tcsh $chrom $run $section  $minX $maxX $Strategy "
      scripts/submit tmp/OR/$run/$chrom/d3.de_duo_loop.$run.$section "scripts/d3.de_duo_loop.tcsh $chrom $run $section  $minX $maxX $Strategy"
    end
  end

end

goto phaseLoop

# export the introns directly found by clipalign

####################################################################################
## phase d4SLs: compare the known introns

phased4SLs:
 echo -n "Phase d4sls export the SL counts to the Ali "
 date

if ($Strategy != RNA_seq) goto phaseLoop
if ($species != worm) goto phaseLoop

echo ' ' > tmp/SL1/$MAGIC.SLS.txt
foreach run (`cat MetaDB/$MAGIC/RunList`)
  foreach SL (1 2 3 4 5 6 7 8 9 10 11 12)
    if (-d  tmp/SL1/$run) then
       cat tmp/SL$SL/$run/*/$run.1.0.txt | gawk -F '\t' '{n+=$7;nn++;}END{if(nn>0)printf("%s\tSL%d\t%d\t%d\n",run,SL,n,nn);}' run=$run SL=$SL>> tmp/SL1/$MAGIC.SLS.txt
    endif
  end
end
cat  tmp/SL1/$MAGIC.SLS.txt | gawk -F '\t' '{if($3+0<1)next;if ($1!=old)printf("\nAli \"%s\"\n",$1) ; old=$1; printf("SLS %s %d support %d position\n",$2,$3,$4);}END{printf("\n\n")};' > tmp/SL1/$MAGIC.SLS.ace

echo "pparse tmp/SL1/$MAGIC.SLS.ace" | bin/tacembly MetaDB -noprompt
goto phaseLoop

# export the introns directly found by clipalign

####################################################################################
## phase d4: compare the known introns

phased4:
 echo -n "Phase d4 compare to known introns "
 date

if (! -d RESULTS/Introns_exons_polyA) mkdir RESULTS/Introns_exons_polyA
if ($Strategy != RNA_seq) goto phaseLoop
if (! -d tmp/introns) mkdir tmp/introns

# compare to known introns  (ILM_35 ILM_100 LIF_Bev LIF_WT LIF_X R454_Ti R454_X ANY)
#20 10 5 3 2 1) 

date >! tutu.$$
echo "de novo intron discovery in project $MAGIC" >> tutu.$$
echo "Chromosome $chromSetAll" >> tutu.$$

set chromFilter=.
set RefSeq_count=1
set all_counts=""
if (0 && $species == worm) then
  cat TARGET/MRNAS/introns_cDNA.txt >  tmp/introns/introns.known.$$
  set RefSeq_count=`cat  TARGET/MRNAS/introns_RefSeq.txt | grep -v NULL | grep "$chromFilter" | wc | gawk '{printf ("%d", $1);}'`
  set av_count=`cat  TARGET/MRNAS/introns_av.txt | grep -v NULL | grep "$chromFilter" | wc | gawk '{printf ("%d", $1);}'`
  echo "Wormbase: $RefSeq_count introns, AceView: $av_count introns" >> tutu.$$
  echo "Group\tSupport\tde novo intron\tIn WormBase-190\tNot in WormBase-190\t%in WormBase\t% of WormBase\tIn AceView cDNAs\tNot previously in cDNAs\t% in cDNAs\t% of cDNAs" >> tutu.$$
else if (0) then
  date > tmp/introns/introns.known.$$

  set RefSeq_count=`cat  TARGET/MRNAS/introns_RefSeq.txt | grep -v NULL |  grep "$chromFilter" |wc | gawk '{printf ("%d", $1);}'`
  set av_count=`cat  TARGET/MRNAS/introns_av.txt | grep -v NULL |   grep "$chromFilter" |wc | gawk '{printf ("%d", $1);}'`
  echo "RefSeq: $RefSeq_count introns, AceView: $av_count introns" >> tutu.$$
  echo "Group\tSupport\tde novo intron\tIn RefSeq-nov09\tNot in RefSeq-nov09\t%in RefSeq\t% of RefSeq\tIn AceView cDNAs\tNot previously in cDNAs\t% in cDNAs\t% of cDNAs" >> tutu.$$
else
  set tutu=tmp/introns/introns.known.$$
  echo -n "##  tmp/introns/introns.known " > $tutu
  date >>  $tutu
  echo -n "## " >> $tutu 
  set all_counts=""
  foreach target ($Etargets)
    set count=`cat tmp/METADATA/$target.[fr].introns | wc | gawk '{printf ("%d", $1);}'`
    set all_counts=$all_counts"_"$target"-"$count
  end
  echo "# Group\tSupport\tde novo intron" >> $tutu
  echo $all_counts >> $tutu
  foreach target ($Etargets)
     echo -n "\tIn $target\tNot in $target" >> $tutu
  end
  echo ' ' >>  $tutu

endif

foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (-e tmp/INTRONRUNS/$run/$run.u.intronSupport.ace.gz  && ! -e tmp/INTRONRUNS/$run/$run.u.intronSupport.counts.gz) then
    gunzip -c tmp/INTRONRUNS/$run/$run.u.intronSupport.ace.gz | gawk '/^Intron/{split($2,aa,"__");split(aa[2],bb,"_");printf("%s\t%09d\t%09d",aa[1],bb[1],bb[2]);}/^Run_U/{printf("\t%d\n",$6);}END{printf("\n");}' | gzip >  tmp/INTRONRUNS/$run/$run.u.intronSupport.counts.gz
  endif
end

# candidate introns computed on uno list recursivelly
set toto=tmp/introns/d4.$MAGIC.candidate_introns.ace
echo '//' > $toto

set ok=0
foreach run (`cat MetaDB/$MAGIC/RunsList`)
   if (! -e  tmp/OR/$run/d4.candidate_introns.ace.gz) then 
      if (! -d  tmp/OR/$run)  mkdir tmp/OR/$run
      scripts/submit tmp/OR/$run/d4.candidate_introns "scripts/d4.candidate_introns.tcsh $run"
      set ok=1
   endif 
   zcat tmp/OR/$run/d4.candidate_introns.ace.gz  >> $toto
end
if ($ok == 1) goto phaseLoop

set groupLevelMax=`cat  MetaDB/$MAGIC/g2r | cut -f 3 | sort -k 1n | tail -1`
foreach level (`seq 1 1 $groupLevelMax`)
echo level=$level
  foreach group (`cat MetaDB/$MAGIC/GroupIntronList`)
    set gLevel=`cat MetaDB/$MAGIC/g2r |  gawk -F '\t' '{if($1==g)level=$3}END{print 0+level}' g=$group` 
    if ($gLevel != $level) continue
    if (! -e  tmp/OR/$group/d4.candidate_introns.ace.gz) then
      if (! -d  tmp/OR/$group)  mkdir  tmp/OR/$group
      echo "scripts/d4.candidate_introns.tcsh $group"
      scripts/d4.candidate_introns.tcsh $group
    endif 
    zcat tmp/OR/$group/d4.candidate_introns.ace.gz >> $toto
  end
end

echo "pparse $toto" | bin/tacembly MetaDB -noprompt
#rm $toto

goto phaseLoop

# GroupDeDuoList

set ok=1
foreach group (`cat MetaDB/$MAGIC/RunList MetaDB/$MAGIC/GroupDeDuoList ` )
  if (! -e tmp/introns/$group/d4.discovery.counts) then
    scripts/submit tmp/introns/$group/d4.discovery.counts "scripts/d4.discovery.counts.tcsh $group  $all_counts"
    set ok=0
  endif
end
if ($ok == 0) goto phaseLoop

set toto=tmp/introns/$MAGIC.introns_discovered.ace
echo -n "// " > $toto
date >> $toto
set tt="x"
foreach target ($Etargets)
  if ($tt == "x") set tt=$target
end

foreach group (`cat MetaDB/$MAGIC/RunList MetaDB/$MAGIC/GroupDeDuoList ` )
  cat tmp/introns/$group/d4.discovery.counts >> tutu.$$
  cat tmp/introns/$group/d4.discovery.counts | gawk '/uno.duo/{n=0+$3;if(n>0)printf("Ali %s\nCandidate_introns uno_duo %d In_%s %s Not_in_%s %s Specificity %s Sensitivity %s\n\n", group, n, t, $4, t, $5, $6, $7);}' group=$group t=$tt >> $toto
end
 
bin/tacembly MetaDB <<EOF
  read-models
  parse $toto
  save
  quit 
EOF

echo "d4: $group done"

\rm   tmp/introns/introns.known.$$

cat tutu.$$ | gawk -F '\t' '{if($5=="0")next;print}' > RESULTS/Introns_exons_polyA/$MAGIC.Introns_discovered.txt
\rm tutu.$$
cat  RESULTS/Introns_exons_polyA/$MAGIC.Introns_discovered.txt
echo "##### results are in:   cat  RESULTS/Introns_exons_polyA/$MAGIC.Introns_discovered.txt"

goto phaseLoop

foreach group (`cat MetaDB/$MAGIC/GroupDeDuoList`)
  set chrom=X
  cat tmp/OR/$chrom/$group.*.*.txt | gawk -F '\t' '/^INTRON/{if($10~/g[ct]_ag/)printf("%s\t%s\t%s\t%s\n",$3,$4,$5,$10);}'  > tmp/introns/totoc1
  foreach run2 (`cat MetaDB/$MAGIC/g2r | gawk -F '\t' '{if($1==g)print $2);}' g=$group`)
     if (-e  tmp/OR/$run/d1.$run2.de_uno.txt.gz) then
       gunzip -c tmp/OR/$run/d1.$run2.de_uno.txt.gz | gawk -F '\t' '{if($9~/g[ct]_ag/ && $3 == chrom){a2=$5;b1=$7;if(a2<b1)da=1;else da=-1;printf("%s\t%09d\t%09d\t%s\n",chrom,a2+da,b1-da,$11);}' chrom=$chrom >> tmp/introns/totoc1
     endif
   end
   date > RESULTS/Introns_exons_polyA/$MAGIC.$group.introns_de_novo.chromosome_X.txt
   echo "De novo introns on chromosome X, in $MAGIC $group" >> RESULTS/Introns_exons_polyA/$MAGIC.$group.introns_de_novo.chromosome_X.txt
   echo "The complete set of introns is in directory `pwd`/tmp/introns" >> RESULTS/Introns_exons_polyA/$MAGIC.$group.introns_de_novo.chromosome_X.txt
   echo "Chromosome\tMost 5'base of the intron\tMost 3'base\tType" >> RESULTS/Introns_exons_polyA/$MAGIC.$group.introns_de_novo.chromosome_X.txt
   cat tmp/introns/totoc1 | $tab_sort -u -k 1,1 -k 2,2n -k 3,3n >> RESULTS/Introns_exons_polyA/$MAGIC.$group.introns_de_novo.chromosome_X.txt
end

goto phaseLoop

###################################################################################
## Gene Expression index
## d5:  Importation des comptages dans la base GeneIndexDB

phased5:
  echo "phase d5: Importation of intron support in GeneIndexDB using the files tmp/OR/run/d5.de_uno.txt.gz"

if ($Strategy != RNA_seq || -e GeneIndexDB/ii1.doneZZZ) then
  goto phaseLoopaa
endif


if (! -e  tmp/OR/d5.$MAGIC.minS) then
  bin/tacembly MetaDB <<EOF
    bql -o MetaDB/$MAGIC/GroupIntronList select g from p in  ?project where p == "$MAGIC", g in p->run where g#intron
    bql -o tmp/introns/d5.$MAGIC.minS select g,m from p in  ?project where p == "$MAGIC", g in p->run where g#intron, a in g->ali, m in a->Candidate_introns[18]
    quit
EOF
endif

if (! -e tmp/introns/d5.$MAGIC.chromCumul.done) then
  foreach chrom ($chromSetAll)
    if (! -e tmp/introns/d5.$MAGIC.de_uno.$chrom.ace.gz) then
      scripts/submit INTRON_DB/$chrom/d5.$MAGIC.parse "scripts/d5.intronDB.tcsh chromCumul $MAGIC $chrom"
    endif
  end
  touch tmp/introns/d5.$MAGIC.chromCumul.done

endif

if (0 && ! -e  tmp/introns/d5.$MAGIC.donorAcceptor.done) then
  scripts/d5.intronDB.tcsh donorAcceptor $MAGIC 
endif

foreach chrom ($chromSetAll)
  if (0 && ! -e  tmp/INTRON_DB/$chrom/d5.$MAGIC.capture.done) then
    scripts/submit tmp/INTRON_DB/$chrom/d5.$MAGIC.capture "scripts/d5.intronDB.tcsh capture $MAGIC $chrom"
  endif 
end
scripts/submit wait

if (! -d tmp/INTRON_DB) mkdir tmp/INTRON_DB
foreach chrom ($chromSetAll)
  if (! -e tmp/INTRON_DB/$chrom/d5.$MAGIC.done) then
    if (! -d tmp/INTRON_DB/$chrom) mkdir tmp/INTRON_DB/$chrom
    scripts/submit  tmp/INTRON_DB/$chrom/d5 "scripts/d5.intronDB.tcsh chromDB $MAGIC $chrom"
  endif
end

goto phaseLoop

####################################################################################
## phase d5x:prepare de_uno de_duo.ace

phased5x: 
  echo "d5 Construct the list of de-uno/de-duo introns"

if ($Strategy != RNA_seq) goto phaseLoop
if (! -d tmp/introns) mkdir tmp/introns

#mv tutu introns_oct15_no.3.bestsofar.txt
#mv tutu introns_nov4.any.txt
# 
if (! -e  tmp/introns/d5.done) then

  if (-e tmp/introns/toto.introns.de_duo.any) \rm tmp/introns/toto.introns.de_duo.any
  set nr=`cat MetaDB/$MAGIC/RunList | gawk '{n++}END{printf("%d",int(n/20)+1);}'`
  foreach run (`cat MetaDB/$MAGIC/RunsList `)
    if (! -e tmp/introns/introns.de_duo.$run.txt) then
      echo ZZZZZ >! tmp/introns/toto 
      foreach jj (50 20 10 5 3 2 1)
        cat tmp/OR/*/$run.$jj.?.txt | gawk '/^INTRON/{printf("%s__%d_%d\t%s\t%s\t%s\n",$3,0+$4,0+$5,run,jj,$10) ; }' run=$run jj=$jj | $tab_sort -u >> tmp/introns/toto
      end
      cat tmp/introns/toto | $tab_sort -k 1,1 -k 2,2 -k 3,3nr | gawk '/^ZZZZZ/{next;}{z=$1;r=$2;n=$3;if(z==oldz && r==oldr)next;oldz=z;oldr=r;print;}' > tmp/introns/introns.de_duo.$run.txt
      \rm tmp/introns/toto 
    endif
    cat tmp/introns/introns.de_duo.$run.txt >>  tmp/introns/toto.introns.de_duo.any
    #\rm  tmp/introns/introns.de_duo.$run.txt
  end
  cat tmp/introns/toto.introns.de_duo.any | gawk -F '\t' '{n[$1]+=$3 ;typ[$1]=$4;}END{for(k in n)if(n[k]>=nr)printf("%s\tzzz\t%d\t%s\n",k,n[k],typ[k]);}' nr=$nr | $tab_sort -k 1,1 -k 2,2  >  tmp/introns/introns.de_duo.any.txt
  \rm tmp/introns/toto.introns.de_duo.any

  cat tmp/introns/introns.de_duo.any.txt |  $tab_sort -k 1,1 -k 2,2 | gawk  '{z=$1;if(z!=oldz){split(z,aa,"_");ln=aa[4]-aa[3];if(ln<0)ln=-ln;ln++; type=$4;other="";if(type != "gt_ag" && type != "gc_ag" && type != "ct_ac" && type != "at_ac")other="Other ";printf("\nIntron %s\nIntMap %s %d %d\nLength %d\n%s%s\n",z,aa[1],aa[3],aa[4],ln,other,type);}gsub(/zzz/,"any",$2);printf("de_duo %s %d\n",$2,$3);oldz=z;}END{printf("\n");}' > tmp/introns/introns.de_duo.ace
  cat tmp/introns/introns.de_duo.ace | gawk '/^Intron/{print}' > tmp/introns/introns.de_duo.list

  if (! -e  tmp/OR/d5.de_uno.any) then
    echo "# chrom\ta1\ta2\tlength\ttype\tde_uno" > tmp/OR/d5.de_uno.any
    foreach run (`cat MetaDB/$MAGIC/RunList`)
      gunzip -c  tmp/OR/d1.$run.de_uno.txt.gz | gawk -F '\t' '{if(NF != 11)next;chrom=$3;a1=$5;a2=$7;ln=a2-a1;da=1;if(ln<0){da=-1;ln=-ln;}a1+=da;a2-=da;ln--;type=$9;z=chrom "\t" a1 "\t" a2 "\t" ln "\t" type ; nn[z] += $11;}END{for(k in nn)printf("%s\t%s\t%d\n",k,run,nn[k]);}' run=$run >>  tmp/OR/d5.de_uno.any
    end
  endif

  if (! -e  tmp/introns/introns.de_uno.ace) then
    cat  tmp/OR/d5.de_uno.any | $tab_sort -k 1,1  -k 2,2n -k 3,3n -k 4,4n -k 5,5 -k 6,6 -k 7,7   | gawk -F '\t' '/^#/{next;}{if(NF != 7)next;chrom=$1;a1=$2;a2=$3;ln=$4;type=$5;run=$6;n=$7;if(type != "gt_ag" && type !="gc_ag"  && type !="ct_ac"  && type !="at_ac")type="Other " type; zz= chrom "__" a1 "_" a2 ; if(zz!=old){if(oldn>0)printf("de_uno %s %d\t", oldrun,oldn);oldn=0;if(oldn2>0)printf("de_uno any %d\t", oldn2);oldn2=0;printf("\t\nIntron %s\t%s\tLength %d\tIntMap %s %d %d\t",zz,type,ln,chrom,a1,a2);} old=zz; if(oldn>0 && run != oldrun){printf("de_uno %s %d\t", oldrun,oldn);oldn=0;}oldn+=n;oldn2+=n;oldrun=run;}END {if(oldn>0)printf("de_uno %s %d\t", oldrun,oldn);if(oldn2>0)printf("de_uno any %d\n", oldn2);printf("\t\n");}' >  tmp/introns/introns.de_uno.preace

    cat  tmp/introns/introns.de_uno.preace | gawk -F '\t' '{isOther=index($0,"Other ");i=index($0,"de_uno any");split(substr($0,i),aa,"\t");n=0+substr(aa[1],12); nmin=1;if(isOther > 0)nmin=2*nr+5;if(n>nmin)print;}' nr=$nr > tmp/introns/introns.de_uno.preace.filtered
    cat tmp/introns/introns.de_uno.preace.filtered | sed -e 's/\t/\n/g' > tmp/introns/introns.de_uno.ace

    \rm  tmp/introns/introns.de_uno.preace  tmp/introns/introns.de_uno.preace.filtered

  endif
  cat  tmp/introns/introns.de_uno.ace | gawk '/^Intron/{ii=$2;next;}/^de_uno any/{printf("%s\t%s\n",ii,$3);}' > tmp/introns/introns.de_uno.count
  cat  tmp/introns/introns.de_uno.ace | gawk '/^Intron/{print}' > tmp/introns/introns.de_uno.list

  if (-e tmp/introns/d5.parse.done) \rm  tmp/introns/d5.parse.done
  touch  tmp/introns/d5.done
else
  echo "tmp/introns/d5.done already present"
endif

ls -ls  tmp/introns/introns.de_uno.ace  tmp/introns/introns.de_duo.ace
wc  tmp/introns/introns.de_uno.list tmp/introns/introns.de_duo.list 
echo -n "Union de_uno de_duo "
cat  tmp/introns/introns.de_uno.list tmp/introns/introns.de_duo.list  | $tab_sort -u | wc -l
# exit 0

# export a file restricted to introns.with_at_least_100_support_or_seen_in_at_least_10_runs or seen in DICER region
cat  tmp/introns/introns.de_uno.ace | gawk '/^#/{print}/^Intron/{if(nr>=10 || n>=100)printf("%s\t%d\t%d\n",ii,nr,n); ii=$2;nr=0;n=0;}/de_uno any/{next;}/de_uno/{nr++;n+=$3;}' > RESULTS/Introns_exons_polyA/introns.de_uno.with_at_least_100_supports_or_seen_in_10_runs.txt

set toto=RESULTS/Introns_exons_polyA/introns.de_uno.with_at_least_n_supports.txt
echo -n '# ' > $toto
date >> $toto
echo "# Number of introns in project $MAGIC dicovered at least n times in de_uno method" >> $toto
echo "# limited to introns with standard boundaries (gt_ag, gc_ag or at_ac) or non classic with over 50 support" >> $toto
cat  tmp/introns/introns.de_uno.ace  | gawk '/^#/{next;}/de_uno any/{n=$3;jj=1;for (i=0;n>jj && i < 30;i++){jj=2*jj;}nn[i]++;}END{printf("Support\tNumber of intron\tCumul\n");jj=1;s=0;for(i=30;i>=0;i--){s+=nn[i];nnn[i]=s;}for(i=1;i<=30;i++){printf("%d\t%d\t%d\n",jj,nn[i],nnn[i]);jj=2*jj;}}' >> $toto


if (-d GeneIndexDB && ! -e  tmp/introns/d5.parse.done) then
 bin/tacembly GeneIndexDB << EOF  > /dev/null
    find intron
    kstore old
    pparse tmp/introns/introns.de_uno.ace
    query find intron Other AND de_uno=="any" AND NEXT <= 5
    edit -D de_Uno
    pparse tmp/introns/introns.de_duo.ace
    query find intron de_uno || de_duo
    list -a -f tmp/introns/introns.candidates.list
    query find intron ! de_uno && ! de_duo && ! From_gene && ! from_genefinder
    kill
    save
    quit
EOF

### cumulate the introns counts from several projects to produce the intron.fasta file
# cat ~/NB/tmp/introns/introns.de_??o.ace ~/BodyMap_2012/tmp/introns/introns.de_??o.ace tmp/introns/introns.de_??o.ace ~/Fatigue/tmp/introns/introns.de_??o.ace | gawk '/^Intron/{g=$2;}/^de_uno any/{ n1[g]+=$3;n[g]+=$3;}/^de_duo any/{ n2[g]+=$3;n[g]+=$3;}END{for(g in n)printf("%d\t#%d#\t%s\t%d\t%d\n",n[g],n[g],g,n1[g],n2[g]);}' > tutu1
# cat tutu1 | $tab_sort -k 1nr tutu1 | gawk '{n++;printf("%d\t",n);print;}' > tutu1s
# cat tutu1s | grep '#1000#' | head -1

   
foreach run (`cat MetaDB/$MAGIC/RunList`)
  if (-e tmp/PHITS_introns/$run/introns_validated.txt)  \rm  tmp/PHITS_introns/$run/introns_validated.txt
  if (-e  tmp/PHITS_introns/$run.introns.confirmed.ace) \rm  tmp/PHITS_introns/$run.introns.confirmed.ace
end

if (-d  tmp/introns/introns.candidates) \rm -rf  tmp/introns/introns.candidates
if (! -d  tmp/introns/introns.candidates) mkdir  tmp/introns/introns.candidates

# cat tmp/introns/introns.de_uno.count ~/SEQC_2013/tmp/introns/introns.de_uno.count | gawk '{nn[$1]+=$2;}END{for(k in nn)printf("%s\t%d\n",k,nn[k]);}' | $tab_sort -k 2nr | gawk '{if($2>=10)print}' > tmp/introns/introns.candidates.count

cat tmp/introns/introns.de_uno.ace tmp/introns/introns.de_duo.ace | gawk '/^Intron/{ii=$2;next;}/de_uno any/{nn[ii]+=$3;nu[ii]+=$3;}/de_duo any/{nn[ii]+=$3;nd[ii]+=$3;}END{for(ii in nn)if(nn[ii]>=10)printf("%s\t%d\t%d\t%d\n",ii,nn[ii],nu[ii],nd[ii]);}' | $tab_sort -k 2,2nr > tmp/introns/introns.candidates.count

foreach chrom ($chromSetAll)

    if (! -d  tmp/introns/introns.candidates/$chrom) mkdir  tmp/introns/introns.candidates/$chrom

   #    cat tutu1s | gawk -F '\t' '{if($1>=10)print $4;}' 

    cat tmp/introns/introns.candidates.count  | gawk '{gsub(/\"/,"",$1);split ($1,aa,"__");split(aa[1],cc,"|");split(aa[2],bb,"_");if(chrom != cc[1])next;a1=bb[1];a2=bb[2];if (a1<a2){c1=a1-100;c2 =a2+100;a1--;a2++;}else{c1=a1+100;c2=a2-100;a1++;a2--;}printf("ZI_Dicer_%s\t%d\t%d\t%s\t%d\t%d\n",$1,1,100,aa[1],c1,a1);printf("ZI_Dicer_%s\t%d\t%d\t%s\t%d\t%d\n",$1,101,200,aa[1],a2,c2);}' chrom=$chrom >  tmp/introns/introns.candidates/$chrom/shadow
    scripts/submit  tmp/introns/introns.candidates/$chrom/shadow  "bin/dna2dna -i TARGET/CHROMS/$species.chrom_$chrom.fasta.gz -shadow tmp/introns/introns.candidates/$chrom/shadow -O fasta -gzo -o tmp/introns/introns.candidates/$chrom/introns"

end

cat  tmp/introns/introns.candidates.count ZZZZZ tmp/introns/introns.de_uno.ace tmp/introns/introns.de_duo.ace | gawk '/^ZZZZZ/{zz++;next;}{if(zz<1){ok[$1]=1;next;}}/^Intron/{k=0;if(ok[$2]==1)k=1;}{if(k==1)print;}' >  tmp/introns/introns.count.ace



  touch tmp/introns/d5.parse.done
endif   # GeneIndeDB

goto phaseLoop

####################################################################################
## Recover the U_introns confirmations
## NB phased6 is defined close to phasea123
phased7: 

echo -n "phase d7:  Recover the U_introns confirmations start "
date

foreach run (`cat MetaDB/$MAGIC/RunList`)  
  if (! -d tmp/PHITS_introns/$run || -e tmp/PHITS_introns/$run.introns.confirmed.ace) continue
  set ok=1
  foreach lane (`cat Fastc/$run/LaneList`)
    if (! -e tmp/PHITS_introns/$lane.hits.gz) set ok=0
  end
  if ($ok == 1 && ! -e tmp/PHITS_introns/$run/introns_validated.txt) then
    scripts/submit tmp/PHITS_introns/$run/introns_validated "gunzip -c tmp/PHITS_introns/$run/*.hits.gz | gawk -f scripts/d7.introns_validated.awk run=$run >  tmp/PHITS_introns/$run/introns_validated.txt"
  endif
end

echo -n "d7 done "
date
goto phaseLoop

####################################################################################
## Collate the U_introns confirmations
phased8: 

echo -n "phase d8:  Collate the U_introns confirmations start "
date

set mytmp=$TMPDIR/AceView.d8.$$
mkdir $mytmp

foreach run (`cat MetaDB/$MAGIC/RunList | grep Rhs53`)
  ls -ls  tmp/PHITS_introns/$run/introns_validated.txt
  cat   tmp/PHITS_introns/$run/introns_validated.txt | gawk -F '\t' '{split($1,aa,"_");print >> tt "/" aa[1];}' tt=$mytmp
end  

if (-e tmp/PHITS_introns/introns_validated.ace) \rm tmp/PHITS_introns/introns_validated.ace
foreach ff (`ls $mytmp/*`)
  cat $ff | $tab_sort |  gawk '{z=$1;ii[$1]=1;rr[$2]=1;nn_u[$1,$2]=$3;nn_nu[$1,$2]=$4;}END{for (i in ii){zu = 0 ; znu = 0 ; printf ("Intron %s\n",i);for(r in rr){n = nn_u[i,r]; zu += n ;if(n>0) printf ("Validated_u %s %d\n", r, n);n = int(nn_nu[i,r]); znu += n ;if(n>0) printf ("Validated_nu %s %d\n", r, n);}if(zu>0) printf ("Validated_u any %d\n", zu);if(znu>0) printf ("Validated_nu any %d\n", znu);printf("\n");}}' >>   tmp/PHITS_introns/introns_validated.ace
end
\rm -rf  $mytmp

bin/tacembly GeneIndexDB <<EOF > /dev/null
  pparse   tmp/PHITS_introns/introns_validated.ace
  save
  query find intron deep OR Validated_u OR Validated_nu
  show -a -f    tmp/PHITS_introns/d8.introns_with_support.ace
  quit
EOF

# create a summary table from the ace file, using the max between the Deep tag and the Validated tag, using the nU  counts as well as the U counts
echo "Intron" > tmp/PHITS_introns/ZZZZZi
set toto=tmp/PHITS_introns/d8.introns_with_support.txt
echo -n "# " > $toto
date >> $toto
cat MetaDB/$MAGIC/GroupList ZZZZZMetaDB/$MAGIC/RunList ZZZZZ  tmp/PHITS_introns/d8.introns_with_support.ace  tmp/PHITS_introns/ZZZZZi | gawk -f scripts/d8.introns2table.awk uu=u RG="$Reference_genome" >> $toto

\cp $toto  RESULTS/Introns_exons_polyA

# histo of number of runs supporting the intron at depth 1,2,5,10,50,100
cat $toto | gawk -F '\t' '{if ($7 == "-")next ; print;}' | bin/histo -w 600 -plain  -plot -columns 12,13,14,15,16,17  -o tyty
mv tyty.txt RESULTS/Introns_exons_polyA/IntronSupportedInNruns.in_gene.histo.txt
cat $toto |  gawk -F '\t' '{if ($7 == "-") print;}' | bin/histo -w 600 -plain  -plot -columns 12,13,14,15,16,17  -o tyty
mv tyty.txt RESULTS/Introns_exons_polyA/IntronSupportedInNruns.orphans.histo.txt
# number of introns in a gene
cat $toto | gawk -F '\t' '{g=$7;if(g == "-")n0++;else n1++;{g2i[g]++;if(g2i[g]==1)ng++;}}END{printf("%d introns in %d genes, %d orphan introns\n",n1,ng,n0);}'
# distrib
cat $toto | gawk -F '\t' '{if ($7 == "-")next ; print;}'  | gawk -F '\t' -f scripts/d8.intronsTableStats.awk > RESULTS/Introns_exons_polyA/IntronInNruns.in_gene.histo.txt
cat $toto | gawk -F '\t' '{if ($7 == "-") print;}'  | gawk -F '\t' -f scripts/d8.intronsTableStats.awk > RESULTS/Introns_exons_polyA/IntronInNruns.orphans.histo.txt


# restrict to introns with at least 5/1000 of most abundant intron of that gene 
# we rather want to reject local alternative below 5/1000 of another exon or intron
cat $toto ZZZZZ $toto | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{g=$7;n=$11;if(g=="-")next;}{if(zz<1){if(gMx[g]<n)gMx[g]=n;next;}if(200*n>gMx[g]){n1++;next;}n0++;g2i[g]++;if(g2i[g]==1)ng++;}END{printf("%d low introns in %d genes, %d high introns\n",n0,ng,n1);}'
cat $toto ZZZZZ $toto | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{g=$7;n=$11;if(g=="-")next;}{if(zz<1){if(gMx1[g]<n){gMx2[g]=gMx1[g];gMx1[g]=n;}else{if(gMx2[g]<n)gMx2[g]=n;}next;}if(200*n>gMx2[g]){n1++;next;}n0++;g2i[g]++;if(g2i[g]==1)ng++;}END{printf("%d low introns relative to secong highest intron  in %d genes, %d high introns\n",n0,ng,n1);}'

# export a file restricted to introns with at least 5/1000 of the second most abundant intron of that gene 
# not good
# cat $toto ZZZZZ $toto | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{g=$7;n=$11;if(g=="-")next;}{if(zz<1){if(gMx1[g]<n){gMx2[g]=gMx1[g];gMx1[g]=n;}else{if(gMx2[g]<n)gMx2[g]=n;}next;}if(200*n>gMx2[g])print}' |  RESULTS/Introns_exons_polyA.with_5per1000_of_second_most_supported_intron_of_same_gene.txt


# export a file restricted to introns with at least 100 support or seen in at least 10 runs
cat $toto | gawk -F '\t' '/^#/{print}{if($11 >= 100 || $12 >= 10)print}' > RESULTS/Introns_exons_polyA/introns.with_at_least_100_supports_or_seen_in_10_runs.txt

# same for export to Leming. restricted to known genes
cat $toto | gawk -F '\t' '/^# Chromo/{nchromo++;if(nchromo==1)print}{if($7 != "-" && $8+$9 > 0 && ($11 >= 100 || $12 >= 10))print;}' | gawk -F '\t' '{if(substr($1,1,1)!="#"){printf("chr");}printf("%s:%d-%d\t%s\t%s\t%s\t%s",$1,$2,$3,$4,$5,$6,$7);for(i=8;i<=17;i++)printf("\t%s",$i);for(i=44;i<=58;i++)printf("\t%s",$i);for(i=71;i<=583;i++)printf("\t%s",$i);printf("\n");}' > toto765



echo -n "# Exon junctions annotated in AceView and supported in $MAGIC : " > toto766
date >> toto766 
echo "# For each intron and each sample the number given is log2(10^6*(1 + number_of_supporting_reads)/number_of_aligned_reads_in_the_sample)" >> toto766 
echo "# For each sample, the denominator is given in the second line of the table"  >> toto766 
cat MetaDB/$MAGIC/gtitle.txt ZZZZZ MetaDB/$MAGIC/runAligned.txt  ZZZZZ toto765 | head -10000 | gawk -F '\t' '/^ZZZZZ/{zz++;next;}{if(zz<1){gsub(/\"/,"",$0);tt[$1]=$6;next;}}{if(zz<2){gsub(/\"/,"",$0);ali[$1]=$2;next;}}/^# Chro/{for(i=6;i<=NF;i++)run[i]=$i;printf("# Chromosome:from-to\tStrand\tIntron boundaries\tIntron length (bp)\tGene\tRefSeq\tGenbank cDNA spliced in AceView\tRNA-seq bodymap\tSupporting reads in %s\tNumber of runs with at least 1 support\tRuns with at least 2 supports\tRuns with at least 5 supports\tRuns with at least 10 supports\tRuns with at least 50 supports\tRuns with at least 100 supports\tChromosome:from-to",project);for(i=16;i<=NF;i++)printf("\t%s",$i);for(i=6;i<=NF;i++)run[i]=$i;printf("\n# Chromosome:from-to\tStrand\tIntron boundaries\tIntron length (bp)\tGene\tRefSeq\tGenbank cDNA spliced in AceView\tRNA-seq bodymap\tSupporting reads in %s\tNumber of runs with at least 1 support\tRuns with at least 2 supports\tRuns with at least 5 supports\tRuns with at least 10 supports\tRuns with at least 50 supports\tRuns with at least 100 supports\tChromosome:from-to",project);for(i=16;i<=NF;i++)printf("\tSEQC_%s",tt[run[i]]);printf("\n");printf("\n#Aligned reads\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t");for(i=16;i<=NF;i++)printf("\t%d",ali[run[i]]);printf("\n");next;}{printf("%s",$1);for(i=2;i<=15;i++)printf("\t%s",$i);printf("\t%s",$1);for(i=16;i<=NF;i++){z=log(1000000.0)+log(1+$i);a=ali[run[i]];if(a>0)z=z-log(a);if(0)printf("\t%d#%.3f",$i,z/log(2));printf("\t%.3f",z/log(2));}printf("\n");}'  project=$MAGIC | gawk -F '\t' '{for(i=1;i<=15;i++)printf("\t%s",$i);for(i=16;i<=NF;i++)printf("\t%s",$i);printf("\n");}' >> toto766


# TARGET/Targets/$species.av.mask.txt : beware of satoyo
cat  TARGET/Targets/$species.av.mask.txt ZZZZZ  toto766 | gawk -F '\t' '/ZZZZZ/{zz++;next;}/For each/{next;}/Chromosome/{nchromo++;if(nchromo<2)next;}/denominator/{next;}/#Aligned/{next;}/^#/{gsub(/ 2 runs/,"",$0);print;next;}/^\t#/{gsub(/ 2 runs/,"",$0);print;next;}{if(zz<1){split($1,aa,".");bad[aa[1]]=1;next;}}{if(bad[$1]>0 || bad[$6]>0)next;print;}' | gawk -F '\t' '/^#/{print;next;}{printf("%s",$2);for(i=3;i<=NF;i++)printf("\t%s",$i);printf("\n");}' >  toto767

# look in NB/OTHER*/README 

# create the global sum of all RNA-seq experiments
# cat $toto | gawk -F '\t' '/^#/{next}{n=$9;if(n>0)printf("Intron %s__%d_%d\nRNA_seq %d\n\n",$1,$2,$3,n);}' > titi.ace

set toto2=tmp/PHITS_introns/d8.introns_with_support.juncs.txt
echo -n "# " > $toto2
date >> $toto2
echo "# MAGIC Intron and support, project $MAGIC" >> $toto2
echo "# .juncs format, coordinates are zero based and mark the extreme bases of the bordering exons" >> $toto2
echo "# Chromosome\tLast base of upstream exon\tFirst base of down strean exon\tStrand\tType\tLength\tGene\tTotal support" >> $toto2
cat $toto | gawk -F '\t' '/^#/{next;}{chrom=$1;a1=$2;a2=$3;s=$4;type=$5;ln=$6;gene=$7;total=$9;if(a1<a2){a1-=2;s="+";}else{x=a1;a1=a2-2;a2=x;s="-";}if (total > 0)printf("%s\t%d\t%d\t%s\t%s\t%d\t%s\t%d\n", chrom,a1,a2,s,type,ln,gene,total);}' >> $toto2
\cp $toto2  RESULTS/Introns_exons_polyA


set toto3=tmp/PHITS_introns/d8.1000_introns_with_best_support.txt
cat $toto | head -30 | gawk '/^#/{print}' > $toto3
cat $toto | gawk '/^#/{next;}{print}' | $tab_sort -k 11nr | head -1000 >> $toto3
\cp $toto3  RESULTS/Introns_exons_polyA

set toto3=tmp/PHITS_introns/d8.introns_support_statistics_per_run.txt
echo -n "# " > $toto3
date >> $toto3
echo "# Number of introns with at given number of supporting reads per run" >> $toto3
cat  MetaDB/$MAGIC/GroupListSorted MetaDB/$MAGIC/RunListSorted ZZZZZ MetaDB/$MAGIC/gtitle.txt ZZZZZ $toto  | gawk -F '\t' -f scripts/d8.introns_support_statistics.awk  >> $toto3

\cp $toto3  RESULTS/Introns_exons_polyA

set nam1="75F_runs9.10" 
set nam2="100F_runs9.10"
set nam1="Rrn1"
set nam2="Spinal_ganglion"
set nam2="EST"
set toto3=tmp/PHITS_introns/d8.introns_support_different_in.$nam1.$nam2.txt
echo -n "# " > $toto3
date >> $toto3
echo "# Exon-exon junctions with significantly different support between $nam1 and $nam2" >> $toto3
echo "Only junctions with at least 20 supporting reads and delta^2 > lower value are listed" >> $toto3
cat $toto | gawk -F '\t' '/^# Chromosome/{printf("\n%s",$1);for (i=2;i<=11;i++)printf("\t%s",$i); printf("\t%s\t%s\tFraction %s/(%s+%s)\n",nam1,nam2,nam1,nam1,nam2);}' nam1=$nam1 nam2=$nam2  >> $toto3
cat  $toto  | gawk -F '\t' '/^# Chromosome/{for(i=1;i<=NF;i++){if($i==nam1)u1=i;if($i==nam2)u2=i;}}/^#/{next}{a=$u1;b=$u2;if (a+b>20){da=a-b;c=a;if(da<0){c=b;da=-da;}if(da*da > 50*c){printf("%s",$1);for (i=2;i<=11;i++)printf("\t%s",$i);printf("\t%s\t%s\t%.1f\n",a,b,100*a/(a+b+1));}}}' nam1=$nam1 nam2=$nam2 >> $toto3

\cp $toto3  RESULTS/Introns_exons_polyA
cat $toto3 | gawk '/#/{next;}{n[int((5+$14)/10)*10]++;}END{for(k in n)printf("%d\t%d\n", k,n[k])}' | $tab_sort -k 1n >  RESULTS/Introns_exons_polyA/d8.introns_support_different_in.$nam1.$nam2.stats.txt

echo -n "d8 done "
date
goto phaseLoop

####################################################################################
####################################################################################

phased4SL:


goto phaseLoop

set path = ( $path /home/mieg/aa/TOPHAT/bin )
tophat -o tmp/THITS_genome BT/worm.genome Fastc/Fraser1/Mixed/SRX007173.1.fastc,Fastc/Fraser1/Mixed/SRX007173.2.fastc,Fastc/Fraser1/Mixed/SRX007173.3.fastc,Fastc/Fraser1/Mixed/SRX007173.4.fastc,Fastc/Fraser1/Mixed/SRX007173.5.fastc,Fastc/Fraser1/Mixed/SRX007173.6.fastc,Fastc/Fraser1/Mixed/SRX007173.7.fastc,Fastc/Fraser1/Mixed/SRX007173.8.fastc,Fastc/Fraser1/Mixed/SRX007173.9.fastc,Fastc/Fraser1/Mixed/SRX007173.10.fastc,Fastc/Fraser1/Mixed/SRX007173.11.fastc,Fastc/Fraser1/Mixed/SRX007173.12.fastc,Fastc/Fraser1/Mixed/SRX007173.13.fastc,Fastc/Fraser1/Mixed/SRX007173.14.fastc,Fastc/Fraser1/Mixed/SRX007173.15.fastc

if (! -e tmp/bwintrons_unknown_candidate.txt) then
  echo "filtering out the known introns"
  cat  MRNAS/introns_av.txt > toto
  echo ZZZZZ >> toto
  cat tmp/THITS_genome/junctions.bed | gawk '{if($6=="+")printf("%s\t%09d\t%09d\n",$1,1+$2,1+$3);}' >> toto
  cat tmp/THITS_genome/junctions.bed | gawk '{if($6=="-")printf("%s\t%09d\t%09d\n",$1,1+$3,1+$2);}' >> toto
  cat toto | gawk -F '\t' '/ZZZZZ/{zz=1;next;}{if(zz==0){u=$1 $2 $3;uu[u]=1;next;}u=$3 $4 $5;if(uu[u]==1)next;print}' >  tmp/bwintrons_unknown_candidate.txt
endif
wc  tmp/THITS_genome/junctions.bed  tmp/bwintrons_unknown_candidate.txt
cat tmp/THITS_genome/junctions.bed |  gawk -F '\t' '/CHROMOSOME_III/{if($6=="+"){a1=$2+31;a2=$3-31;}else{a1=$3-31;a2=$2+31;}printf("%s\t%d\t%d\n",$1,a1,a2);}' > tmp/THITS_genome/junctions.bed3
bin/geneelements -cosmidWiggle tm/XH$chrom/f3.cosmid2map.txt -stranded -hitFile  tmp/THITS_genome/junctions.bed3 -trackName TopHat -feature TopHat > tmp/THITS_genome/tophat.feature.ace

goto phaseLoop
cat tmp/introns.candidate.all.txt4 | gawk -F '\t' '/^\//{next}{c=$6;gsub(/CHROMOSOME_/,"",c);a1=0+$8;a2=0+$9;printf("Intron %s__%d_%d\nDeep\n\n",c,a1,a2);}' > deep2introns_elements.ace
grep Intron  deep2introns_elements.ace >  tmp/deep2introns_elements.list

## total known 101345 (from somewhere) , 88730 supported by cDNA
##        all    new   known   %known  %seen
jun15    81519  44656     36863   46%  38%
jun24    71786  20772     51014   71%  49%
aug5/1  104576  15641     88935   85%  88%
aug8/1  112438  23483     88955   79%  88%

aug8/2   90168  10573     79595   88%  78%
aug5/2   87165   7587     79578   91%  78%
aug13/2  93020  11650     81370   87%  80% with marra data added
aug13/2  90564  xx11650   xx370   x%  x0% with marra data added removing doubles
aug23/2  91395  10018     81377   89%  80% better filtering of gt-ag gc-ag feet


aug5/3   80250   5372     74878   93%  73%
aug8/3   84484   8062     76422   90%  76% with marra data added
aug13/3  84963   8195     76768   90%  76% with marra data added

## total  88730 supported by cDNA
aug23/2  89050  xx018     xx77    xx%  x% better filtering of gt-ag gc-ag feet  removing doubles
oct7/2   86911   15666    71245   82%  80% 

# octobre 15, without the .3 filter
Manip   Limit   Intron  In CDNA Not CDNA        % in CDNA       % of CDNA       AV      Not AV  % in AV % of AV
any     50      29847   28851   996     96.7    27.1    28313   1534    94.9    31.9
any     20      60187   56874   3313    94.5    53.5    54425   5762    90.4    61.3
any     10      75697   69722   5975    92.1    65.6    65778   9919    86.9    74.1
any     5       86971   77708   9263    89.3    73.1    72467   14504   83.3    81.7
any     3       94631   81768   12863   86.4    76.9    75799   18832   80.1    85.4
any     2       101660  84388   17272   83.0    79.4    77776   23884   76.5    87.7
any     1       124949  87776   37173   70.2    82.6    80197   44752   64.2    90.4

####################################################################################

### count the number of tags supporting the introns donor and acceptor sites, 
### we get nice power laws
cd  tmp/introns/20
cat tmp/OR/*/*ndiv.1.*.txt  | grep DONOR | gawk '{n[$7]++;n[$9]++;}END{for(k in n)printf("%d\t%d\n",k,n[k]);}' | $tab_sort -k 2nr > tutu
cat tutu | gawk '{k=$1;n=$2;printf("%g\t%g\n",log(k),log(n));}' | $tab_sort -T $TMPDIR  -k 1n > tutuLL

gnuplot -bg white
 plot [1:8] 'tutuLL', 13.4 - .83*x


###################################################################################
###################################################################################
## compare for Richa

## sep 2010 on bodymap
# Richa has no strand, every file must be reformatted without strand
cd RICHA
ln -s /panfs/pan1.be-md.ncbi.nlm.nih.gov/trace_work/backup/agarwala/refseq/RNAseq/bodymap/results RICHA
cat RICHA/models | cut -f 1 | gawk -F ':' '{a=1+$2;b=-1+$3;printf("%s\t%09d\t%09d\n",substr($1,4),a,b);}' | grep -v laced | $tab_sort > richa.ns
# reformat de novo
cat ../tmp/OR/*/OR.candidate.*.any.limit* ../tmp/OR/*/OR.candidate.Mix*.any.limit* | cut -f 3,4,5 | $tab_sort -u > denovo.pm
cat ../../Seqc37/tmp/OR/*/OR.candidate.*.any.limit* ../tmp/OR/*/OR.candidate.Mix*.any.limit* | cut -f 3,4,5 | $tab_sort -u > denovo.pm.seqc

cat denovo.pm | gawk '{if($2<$3)printf("%s\t%09d\t%09d\n",$1,$2,$3);}' | $tab_sort -u > denovo.p
cat denovo.pm | gawk '{if($2>$3)printf("%s\t%09d\t%09d\n",$1,$3,$2);}' | $tab_sort -u > denovo.m
cat denovo.p denovo.m | $tab_sort -u > denovo.ns

# extract just the g[tc]_ag from de_uno et de_novo
cat ../tmp/OR/OR.ali_candidate.*.txt | gawk '/g[tc]_ag/{printf("%s\t%09d\t%09d\n",$2,$3,$4);}' | $tab_sort -u >  deuno.pm
cat ../../Seqc37/tmp/OR/OR.ali_candidate.*.txt | gawk '/g[tc]_ag/{printf("%s\t%09d\t%09d\n",$2,$3,$4);}' | $tab_sort -u > deuno.pm.seqc

cat all_introns_un_deux.feb.txt | gawk '{if($2<$3)printf("%s\t%09d\t%09d\n",$1,$2,$3);}' | $tab_sort -u > denovo.p
cat all_introns_un_deux.feb.txt | gawk '{if($2>$3)printf("%s\t%09d\t%09d\n",$1,$3,$2);}' | $tab_sort -u > denovo.m
cat denovo.p denovo.m | $tab_sort -u > denovo.ns

# reformat RefSeq
cat ../MRNAS/introns_RefSeq.txt | cut -f 1,2,3 | $tab_sort -u > refseq.pm
cat refseq.pm | gawk '{if($2<$3)printf("%s\t%09d\t%09d\n",$1,$2,$3);}' | $tab_sort -u > refseq.p
cat refseq.pm | gawk '{if($2>$3)printf("%s\t%09d\t%09d\n",$1,$3,$2);}' | $tab_sort -u > refseq.m
cat refseq.p refseq.m | $tab_sort -u > refseq.ns

# reformat av.2020_08
cat ../MRNAS/introns_av.txt | cut -f 1,2,3 | $tab_sort -u > refseq.pm
cat refseq.pm | gawk '{if($2<$3)printf("%s\t%09d\t%09d\n",$1,$2,$3);}' | $tab_sort -u > refseq.p
cat refseq.pm | gawk '{if($2>$3)printf("%s\t%09d\t%09d\n",$1,$3,$2);}' | $tab_sort -u > refseq.m
cat refseq.p refseq.m | $tab_sort -u > refseq.ns


set nrp=`cat  refseq.p | wc | gawk '{print $1}'`
set nrm=`cat  refseq.m | wc | gawk '{print $1}'`
set ndp=`cat  denovo.p | wc | gawk '{print $1}'`
set ndm=`cat  denovo.m | wc | gawk '{print $1}'`
set nins=`cat  richa.ns | wc | gawk '{print $1}'`


set nrip=`cat refseq.p richa.ns | $tab_sort | wc | gawk '{print $1}'`
set nripu=`cat refseq.p richa.ns | $tab_sort -u | wc | gawk '{print $1}'`
set nrim=`cat refseq.m richa.ns | $tab_sort | wc | gawk '{print $1}'`
set nrimu=`cat refseq.m richa.ns | $tab_sort -u | wc | gawk '{print $1}'`

set ndip=`cat denovo.p richa.ns | $tab_sort | wc | gawk '{print $1}'`
set ndipu=`cat denovo.p richa.ns | $tab_sort -u | wc | gawk '{print $1}'`
set ndim=`cat denovo.m richa.ns | $tab_sort | wc | gawk '{print $1}'`
set ndimu=`cat denovo.m richa.ns | $tab_sort -u | wc | gawk '{print $1}'`

set nrdp=`cat refseq.p denovo.p | $tab_sort | wc | gawk '{print $1}'`
set nrdpu=`cat refseq.p denovo.p | $tab_sort -u | wc | gawk '{print $1}'`
set nrdm=`cat refseq.m denovo.m | $tab_sort | wc | gawk '{print $1}'`
set nrdmu=`cat refseq.m denovo.m | $tab_sort -u | wc | gawk '{print $1}'`

set n3=`cat refseq.m denovo.m refseq.p denovo.p richa.ns | $tab_sort | wc | gawk '{print $1}'`
set n3u=`cat refseq.m denovo.m refseq.p denovo.p richa.ns | $tab_sort -u | wc | gawk '{print $1}'`

echo "Strand\tRefSeq\tSeen in Richa\tSeen in Jean" > toto1
echo x | gawk '{xrdp=nrdp-nrdpu;xrip=nrip-nripu;printf("+\t%d\t%d\t%d\t%.1f\t%.1f\n",nrp,xrip,xrdp,100*xrip/nrp,100*xrdp/nrp);}' nrp=$nrp nrip=$nrip nrdp=$nrdp nripu=$nripu nrdpu=$nrdpu >> toto1
echo x | gawk '{xrdm=nrdm-nrdmu;xrim=nrim-nrimu;printf("-\t%d\t%d\t%d\t%.1f\t%.1f\n",nrm,xrim,xrdm,100*xrim/nrm,100*xrdm/nrm);}' nrm=$nrm nrim=$nrim nrdm=$nrdm  nrimu=$nrimu nrdmu=$nrdmu >> toto1
echo "Strand\tJean\tSeen in Richa" >> toto1
echo x | gawk '{xdip=ndip-ndipu;printf("+\t%d\t%d\t%.1f\n",ndp,xdip,100*xdip/ndp);}' ndp=$ndp ndip=$ndip ndipu=$ndipu >> toto1
echo x | gawk '{xdim=ndim-ndimu;printf("-\t%d\t%d\t%.1f\n",ndm,xdim,100*xdim/ndm);}' ndm=$ndm ndim=$ndim ndimu=$ndimu >> toto1
echo x | gawk '{n=ndp+ndm;x=ndip-ndipu+ndim-ndimu;printf("ns\t%d\t%d\t%.1f\n",n,x,100*x/n);}' ndp=$ndp ndip=$ndip ndipu=$ndipu ndm=$ndm ndim=$ndim ndimu=$ndimu  >> toto1
echo "ns\tRicha\tSeen in Jean" >> toto1
echo x | gawk '{x=ndip-ndipu+ndim-ndimu;printf("+\t%d\t%d\t%.1f\n",nins,x,100*x/nins);}' nins=$nins ndip=$ndip ndipu=$ndipu ndim=$ndim ndimu=$ndimu >> toto1
echo -n "Triple intersect " >> toto1
cat refseq.m refseq.p  denovo.m denovo.p  richa.ns | gawk '{nn[$0]++;if(nn[$0]==3)n3++;}END{print n3}' >> toto1

cat toto1

 

## dec 2009 on worm

pushd tmp/introns
# Richa has no strand, every file must be reformatted without strand
# reformat Richa
cat introns_candidate.Richa.2009_11_04.txt | gawk '{c=$1;gsub(/CHROMOSOME_/,"",c);a1=$2;a2=$3;if(a1>a2){a=a1;a1=a2;a2=a;}printf("%s_%09d_%09d\n",c,0+a1,0+a2);}' | $tab_sort -u  > richa.ns
# reformat wormbase
cat  MRNAS/introns_RefSeq.txt | gawk '{c=$1;gsub(/CHROMOSOME_/,"",c);a1=$2;a2=$3;if(a1>a2){a=a1;a1=a2;a2=a;}printf("%s_%09d_%09d\n",c,0+a1,0+a2);}' | $tab_sort -u > RefSeq.ns
# reformat AceView cDNA
cat tmp/introns/introns_cDNA.txt | gawk '{c=$1;gsub(/CHROMOSOME_/,"",c);a1=$2;a2=$3;if(a1>a2){a=a1;a1=a2;a2=a;}printf("%s_%09d_%09d\n",c,0+a1,0+a2);}' | $tab_sort -u > av.ns
# reformat mieg/bob3
cat tmp/introns/*/introns_candidate.BOB3.txt.3_limit1* | gawk '{c=$1;gsub(/CHROMOSOME_/,"",c);a1=$2;a2=$3;if(a1>a2){a=a1;a1=a2;a2=a;}printf("%s_%09d_%09d\n",c,0+a1,0+a2);}' | $tab_sort -u  > bob3.ns
# reformat mieg/any
cat tmp/introns/*/introns_candidate.any.clean.limit1 | gawk '{c=$3;gsub(/CHROMOSOME_/,"",c);a1=$4;a2=$5;if(a1>a2){a=a1;a1=a2;a2=a;}printf("%s_%09d_%09d\n",c,0+a1,0+a2);}' | $tab_sort -u  > any.ns
# reformat mieg/any.nov4
cat tmp/introns.2009_11_04/*/introns_candidate.any.txt.limit1* | grep INTRON | gawk '{c=$3;gsub(/CHROMOSOME_/,"",c);a1=$4;a2=$5;if(a1>a2){a=a1;a1=a2;a2=a;}printf("%s_%09d_%09d\n",c,0+a1,0+a2);}' | $tab_sort -u  > any.ns

date >! venn.txt
echo "Number of introns seen in Waterston data by Richa and mieg" >> venn.txt
cat venn.ns | gawk '{n[$2]++}END{for (k in n) printf("%s\t%d\n",k,n[k]);}'
wc RefSeq.ns  richa.ns bob3.ns 
# construct the Venn diagram WormBase, Richa Mieg

cat RefSeq.ns  richa.ns richa.ns bob3.ns bob3.ns bob3.ns bob3.ns | gawk '{n[$1]++}END{for (k in n)printf("%s\t%d\n",k, n[k]);}' > venn.ns
echo Total >! venn.txt
cat venn.ns | gawk '{n[$2]++}END{printf("Triple intersect\tWb only\tRicha only\tde novo only\tWb+Richa NOT denovo\tWb+de novo NOT Richa\tRicha+de novo NOT Wb\n%d\t%d\t%d\t%d\t%d\t%d\t%d\n",n[7],n[1],n[2],n[4],n[3],n[5],n[6]);}' >>  venn.txt
cat venn.txt

# construct the Venn diagram WormBase, AceView cDNA, de novo

wc RefSeq.ns  av.ns any.ns 
cat RefSeq.ns  av.ns av.ns any.ns any.ns any.ns any.ns | gawk '{n[$1]++}END{for (k in n)printf("%s\t%d\n",k, n[k]);}' > venn.ns
echo Total >! venn.txt

cat venn.ns | gawk '{n[$2]++}END{printf("Triple intersect\tWb only\tAv only\tde novo only\tWb+Av NOT denovo\tWb+denovo NOT Av\tAv+de novo NOT Wb\n%d\t%d\t%d\t%d\t%d\t%d\t%d\n",n[7],n[1],n[2],n[4],n[3],n[5],n[6]);}' >>  venn.txt
cat venn.txt
cp venn.txt RESULTS/$MAGIC.wormbase.av.denovo.nov4.introns.venn.txt  


# create a feature table with the Richa specific introns we do not have even in the combined data
cat richa.ns any.ns any.ns | gawk '{n[$1]++}END{for (k in n)printf("%s\t%d\n",k, n[k]);}' > venn2.ns
cat venn2.ns | gawk '{if($2==1)print $1}' | sed -e 's/_/ /g' | gawk '{printf("CHROMOSOME_%s\t%d\t%d\n",$1,$2+0,$3+0);}' > Richa.feature.txt

bin/geneelements -cosmidWiggle s1.cosmid2map.txt -hitFile tmp/introns/Richa.feature.txt -trackName Richa -feature Richa >> tmp/introns/Richa.feature.ace

###########################################################################
## count the introns in all the aceview releases since 2001
date > totoii
echo "Count all introns in different aceview realeases and in today's RefSeq" >> totoii
echo "Release\tIntrons gt_ag\tgc_ag\tany" >> totoii
foreach tissue ($tissues)
  echo -n "$tissue" >> totoii
  gunzip -c tmp/PHITS_genome/Clones/$tissue/*introns.gz | cut -f 3,5,7,9 | $tab_sort -u | gawk '/gt_ag/{nt++}/gc_ag/{nc++}END{printf("\t%d\t%d\t%d\n",nt,nc,nt+nc);}'  >> totoii
end
cat totoii
\cp totoii  RESULTS/AceView.Introns-accross_ages.txt

# to count the transcript with introns in previous relase (verified on 2007_04 release
cat *.gff | gawk '/exon_number 2/{i=index($0,"transcript_id");print substr($0,i);}' | grep -v product | gawk '{if($4==2)print}' | $tab_sort -u | wc


goto phaseloop

###########################################################################
###########################################################################
## phase f0:  Ventilate the genome alignments 

phasef0:

echo -n "Phase f0: Obsolete Ventilate the genome alignments : scripts/f0.ventilate.tcsh"
date

# 2019-05-15: surprisingly i notice that this code never worked in the MiniTest system
# may be i do not need it
goto phaseLoop

foreach lane (`cat MetaDB/$MAGIC/LaneList`)
  if (-e tmp/PHITS_genome/$lane.hits.gz && ! -e tmp/PHITS_genome/$lane.BG.err) then
     if (1) then  
        scripts/submit tmp/PHITS_genome/$lane.BG "scripts/f0.ventilate.tcsh $lane"
        set ok=0
     endif
  endif
end

goto phaseLoop

###########################################################################
## phase f1: Construct the yellow quasi EST from the ali->INTRONS

phasef1:
 date
echo $chromSetAll

if (0 && $Strategy != RNA_seq) goto phaseLoop

if (! -e tmp/f1.strategy.ace) then
  cat << EOF >  tmp/f1.strategy.ace
Clone R
Main_Clone
Name_by_section
useLeucine
MinIntronSize 40
MaxGapSize 100 kb
MultipleORF  // look for several orfs 
MarkDoubleFuzzy

EOF
endif

echo -n "Phase f1: Construct the doubleintrons, start:"
 date

pushd TARGET/CHROMS
  if (! -e NC2chrom.done) then
    touch NC2chrom.done
    if (-e toto) \rm toto
    foreach ff (`ls $species.chrom_chr*.fasta.gz`)
      echo -n "$ff\t" >> toto
      zcat $ff | head -1 >> toto
    end
    cat toto | gawk -F '\t' '/NC_/{f=$1;split($2,aa," ");nc=substr(aa[1],2);printf("ln -s %s  %s.chrom_%s.fasta.gz\n", f,sp,nc);}' sp=$species  > _m
    source _m
    \rm _m
    cat toto | gawk -F '\t' '/NC_/{f=$1;split ($1,cc,"chrom_");split(cc[2],ccc,".fasta");chr=ccc[1];split($2,aa," ");nc=substr(aa[1],2);printf("%s\t%s\n", nc,chr);}' > nc2chr.txt
  endif
popd


if (! -e TARGET/CHROMS) then
  echo "f1: missing TARGET/CHROMS dir"
  goto phaseLoop
endif

foreach chrom ($chromSetAll)
  if (0 && ! -e TARGET/CHROMS/$species.chrom_$chrom.fasta.gz) then
    echo "f1: missing file  TARGET/CHROMS/$species.chrom_$chrom.fasta.gz"
    goto phaseLoop
  endif
end

if (! -d tmp/EHITS.$MAGIC) mkdir tmp/EHITS.$MAGIC

# consolidate the de uno introns in a single pass
foreach chrom ($chromSetAll)
  echo $chrom 
  if (! -d tmp/EHITS.$MAGIC/$chrom) mkdir tmp/EHITS.$MAGIC/$chrom
end

if (0 && ! -e  tmp/PHITS_genome/$MAGIC.f1.consolidate_intron.done) then
    foreach run (`cat MetaDB/$MAGIC/RunList`)
      # gunzip -c  tmp/PHITS_genome/$run/*.introns.gz | gawk -F '\t' '/INTRON/{if(length($3)<=5)print > "tmp/EHITS/"MAGIC".any."$3".de_uno_introns";}' MAGIC=$MAGIC 
      # may be we could use a simpler count without the read extension ?
      # gunzip -c tmp/OR/d1.$run.de_uno.txt.gz  | gawk -F '\t' '{if(length($2)<=5)print >  "tmp/EHITS/"MAGIC".any."$2".de_uno_introns_new";}' MAGIC=$MAGIC 
    end 
    touch tmp/PHITS_genome/$MAGIC.f1.consolidate_intron.done
endif

foreach chrom ($chromSetAll)
  if (! -e TARGET/CHROMS/$species.chrom_$chrom.fasta.gz) then
    echo "Missing file  TARGET/CHROMS/$species.chrom_$chrom.fasta.gz"
    continue 
  endif

        if (! -e tmp/EHITS.$MAGIC/$chrom/f1.done) then
          echo "scripts/submit tmp/EHITS.$MAGIC/$chrom/f1"
          scripts/submit "tmp/EHITS.$MAGIC/$chrom/f1" "scripts/f1.double_collect_by_section.tcsh $MAGIC $chrom" 32G
        endif

end

goto phaseLoop

###########################################################################
###########################################################################
## phase f2: Construct the new exons introns using the wiggles

phasef2:   
echo -n "Phase f2: collate the double introns"
if (0 && $Strategy != RNA_seq) goto phaseLoop
  if (! -d tmp/EHITS.$MAGIC) mkdir tmp/EHITS.$MAGIC
  if (! -e  tmp/EHITS.$MAGIC/f2.done) then
    scripts/submit "tmp/EHITS.$MAGIC/f2.doubleIntrons" "scripts/f2.geneelements.tcsh "
  endif
goto phaseLoop

###########################################################################
###########################################################################
## phase f3: Parse the yellow/green pseudo est in the XH databases

phasef3:
 echo -n "Parse the yellow/green pseudo est  in the XH databases"
 date

if (0 && $Strategy != RNA_seq) goto phaseLoop
if (! -e tmp/EHITS.$MAGIC/f2.done) goto phaseLoop

foreach chrom ($chromSetAll)
  if (! -d tmp/XH$chrom)  mkdir tmp/XH$chrom
  if (-e  tmp/EHITS.$MAGIC/f2.done && -e tmp/EHITS.$MAGIC/$chrom/f1.done && ! -e tmp/XH$chrom/f3.parse.done ) then
    scripts/submit tmp/XH$chrom/f3.parse "scripts/f3.parse.tcsh $chrom"
  endif
end

date
goto phaseLoop

###########################################################################
###########################################################################
## phase f4: Assemble the yellow/green pseudo est in the XH databases

phasef4:
 echo -n "Assemble the yellow/green pseudo est in the XH databases"
 date

if (0 && $Strategy != RNA_seq) goto phaseLoop

foreach chrom ($chromSetAll)
  if (! -d tmp/XH$chrom)  continue 
  if ( -e tmp/XH$chrom/f3.parse.done && ! -e tmp/XH$chrom/f4.assemble.done) then
    scripts/submit tmp/XH$chrom/f4 "scripts/f4.assemble.tcsh $chrom" 
  endif
end

date
goto phaseLoop

###########################################################################
###########################################################################
## phase f5: Reexport the new transcriptome

phasef5:
 echo -n "Export the new transcriptome "
 date

set XYH=YH
set XYH=XH

if ($Strategy != RNA_seq) goto phaseLoop

foreach chrom ($chromSetAll)
  if (1 || (-e tmp/$XYH$chrom/f4.assemble.done && (! -e tmp/$XYH$chrom/f5.mrna.done || ! -e tmp/$XYH$chrom/f5.cds.done || ! -e tmp/$XYH$chrom/f5.unspliced.done || ! -e tmp/$XYH$chrom/f5.dump.done) )) then
    scripts/submit tmp/$XYH$chrom/f5.export  "scripts/f5.export_new_genes.tcsh $XYH $chrom"
  endif
end

echo done 

goto phaseLoop

###########################################################################
###########################################################################
## phase f6: Collate the new mrna structure and fasta sequence

phasef6:
 echo -n "Export the new transcriptome "
 date
# YH is in SEQC_2013/tmp/OK

set XYH=YH
set XYH=XH

if ($Strategy != RNA_seq) goto phaseLoop

if (! -d TARGET/GTF) mkdir TARGET/GTF
cat tmp/$XYH*/f5.genes.gtf.gz  > TARGET/GTF/$species.magic.gtf.gz
cat tmp/$XYH*/f5.mrnas.fasta.gz > TARGET/Targets/$species.magic.fasta.gz 
# bin/dna2dna -getTm -i TARGET/Targets/$species.magic.fasta.gz -gzo -o  tmp/METADATA/$species.magic
cat tmp/$XYH*/f5.good_product.ace.gz | gzip > TARGET/GTF/$species.magic.good_product.ace.gz

  if (-e tmp/METADATA/gtf.magic.done) \rm  tmp/METADATA/*magic*
  if (-e TARGET/Targets/$species.magic.mask.txt) \rm TARGET/Targets/$species.magic.mask.txt

goto phaseLoop

###########################################################################
###########################################################################
## phase f7: Export import the Kantor

phasek1:
phasek2:
phasek9:
 
if ($Strategy != RNA_seq) goto phaseLoop

echo -n "Export/Import the Kantor phase $phase : start "
 date

if (! -d ~/MEGA3) then
  echo "Kantorizing the proteins only works inside ncbi"
else

  if (! -d Kantor) mkdir Kantor
  foreach chrom ($chromSetAll)
    if (! -e tmp/XH$chrom/f4.assemble.done) continue
    if (! -d Kantor/$chrom) mkdir Kantor/$chrom
    if (! -d Kantor/$chrom/tmp) mkdir Kantor/$chrom/tmp
    if (! -d Kantor/$chrom/tmp/$species_kantor.data) mkdir Kantor/$chrom/tmp/$species_kantor.data
    if (! -d Kantor/$chrom/tmp/$species_kantor.data/$chrom) mkdir Kantor/$chrom/tmp/$species_kantor.data/$chrom

    if ($phase == k1 && ! -e tmp/XH$chrom/k1.kantor_parse.done) then
       scripts/Kantor.tcsh $phase $chrom
    endif

    if ($phase == k2) then
        echo "phase $phase is obsolete"
    endif

    if ($phase == k9 &&  -e tmp/XH$chrom/k1.kantor_parse.done  && ! -e tmp/XH$chrom/k9.megaRun.done && ! -e tmp/XH$chrom/k9.megaRun.start) then
       scripts/Kantor.tcsh $phase $chrom
    endif

  end

endif

goto phaseLoop

###########################################################################
###########################################################################
## phase ff1: Cumul different project in YH$chrom

phaseff1:
 echo -n "ff1: Cumul different project "
 date

set XYH=YH
set XYH=XH

if ($Strategy != RNA_seq) goto phaseLoop
foreach chrom ($chromSetAll)
  if (! -d tmp/$XYH$chrom) mkdir tmp/$XYH$chrom
  if (-e tmp/$XYH$chrom/ff1.done) continue

  scripts/submit tmp/$XYH$chrom/ff1 "scripts/ff1.multi_project.parse.tcsh $chrom"
end

goto phaseLoop

###########################################################################
###########################################################################
## phase ff5: Reexport the new transcriptome

phaseff5:
 echo -n "Export the new transcriptome "
 date

set XYH=XH

if ($Strategy != RNA_seq) goto phaseLoop

foreach chrom ($chromSetAll)
  if (-e tmp/$XYH$chrom/ff1.done && (! -e tmp/YH$chrom/f5.mrna.done || ! -e tmp/$XYH$chrom/f5.cds.done || ! -e f5.unspliced.done || ! -e tmp/$XYH$chrom/f5.dump.done) ) then
    scripts/submit tmp/$XYH$chrom/f5.export  "scripts/f5.export_new_genes.tcsh $XYH $chrom"
  endif
end

echo done 

goto phaseLoop


###########################################################################
###########################################################################
## phase 12:  

phase12:
 echo -n "Phase 12 "
 date

foreach target ($targets)
  echo "$target"
  foreach run (`cat MetaDB/$MAGIC/RunList`) 
  end
end

goto phaseLoop 

###########################################################################
###############################################################
## phase 13:  

 echo -n "Phase 13 "
 date
goto phaseLoop


# guess the introns
###############################################################
## phase 14:  Measure the size of the double ended reads

phase14:
 echo -n "Phase 14 "
 date

goto phaseLoop

gnuplot -bg white
  plot  [100:300] 'MARRA.L1.2.length.histo.txt' , 'MARRA.L1.3.length.histo.txt'
  quit

exit  
###############################################################
## phase 11:  

phase11:
 echo -n "Phase 11 "
 date

foreach target ($targets)
  echo "$target"
  foreach run (`cat MetaDB/$MAGIC/RunList`) 
  end
end

exit  

###############################################################
## phase d8old:  construct the exon-exon fasta file, for detected introns

# off line, get the support for the UTRome features
# only the clones with visible polyA are true walls
cat ../../UTROME/feat.txt |  gawk -F '\t' '/ZFPpool/{next;}/ZFPclone/{next;}/ZAAA_454_FPpool_k/{next;}/ZAAA_454_FPclone_k/{next;}/ZAAA_Sx_FPclone_m/{next;}/AAA_/{gsub(/\"/,"",$0);nn++;ch=$2;a1=$3;a2=$4;m=$5;pa="pa";if(m~/_454_Kim/)pa="paw";x1=$6;x2=$7;u1=a1+x1-1;u2=a1+x2-1;if(u1<u2)s="Forward";else {s="Reverse";u1 = 900000000 - u1 ; u2 = 900000000 - u2 ;}printf("%s\t%s\t%s\t%09d\t%09d\n",pa,s,ch,u1,u2);}' | $tab_sort | gawk -F '\t' '{a1=$4;if(old1 && a1+0<old1+1 && $2==old2 && $3==old3)next;old1=a1;old2=$2;old3=$3;print;}' | gawk -F '\t' '/Reverse/{$4=900000000-$4;$5=900000000-$5;}{printf("%s\t%s\t%s\t%09d\t%09d\n",$1,$2,$3,$4,$5);}' | $tab_sort -u > pA_feature_candidates.txt2

cat ../../UTROME/EXPORT/UTROME_down_for_kris.2009_08_31.txt | grep PolyA |  gawk -F '\t' '{gsub(/\"/,"",$0);if ($27=="PolyA")printf("pA\tForward\t%s\t%09d\t%09d\n",$3,$30+0,$30+1);}' | $tab_sort -u >> pA_feature_candidates.txt2
cat ../../UTROME/EXPORT/UTROME_up_for_kris.2009_08_31.txt | grep PolyA |  gawk -F '\t' '{gsub(/\"/,"",$0);if ($27=="PolyA")printf("pA\tReverse\t%s\t%09d\t%09d\n",$3,$30+0,$30-1);}' | $tab_sort -u >> pA_feature_candidates.txt2

# export the primers and extend them by 30bp to kill local attemtps of extending
cat ../../UTROME/feat.txt | gawk -F '\t' '/Primer/{gsub(/\"/,"",$0);nn++;ch=$2;a1=$3;a2=$4;x1=$6;x2=$7;u1=a1+x1-1;u2=a1+x2-1;if(u1<u2){s="Forward";u2+=30;}else {s="Reverse";u2-=30;u1 = 900000000 - u1 ; u2 = 900000000 - u2 ;}printf("pA\t%s\t%s\t%09d\t%09d\n",s,ch,u1,u2);}' | $tab_sort | gawk -F '\t' '{a1=$4;if(old1 && a1+0<old1+10 && $2==old2 && $3==old3)next;old1=a1;old2=$2;old3=$3;print;}' | gawk -F '\t' '/Reverse/{$4=900000000-$4;$5=900000000-$5;}{printf("Primer\t%s\t%s\t%09d\t%09d\n",$2,$3,$4,$5);}' | $tab_sort -u > tmp/introns/Primer_feature.verbose.txt

phased8old:
goto phaseLoop

# get the dna
set dd=2009_11_15
echo $dd

 cat tmp/introns/*/intron_unknown_support.txt  >  toto

 cat toto | gawk '/^INTRON/{nn++;if ($2=="Forward")dx=1;else dx=-1;ch=$3;if(ch != oldch)printf("\nSequence %s\n",ch);oldch = ch ; printf("Subsequence XI_%s__%d_%d_%s_A %d %d\nSubsequence XI_%s__%d_%d_%s_B %d %d\n",$3,$5+dx,$6-dx,dd,$4,$5+2*dx,ch,$5+dx,$6-dx,dd,$6-2*dx,$7);}END{printf("\n");}' dd=$dd > tmp/XXXX.preace
  cat toto | gawk '/^INTRON/{nn++;if ($2=="Forward")dx=1;else dx=-1;ch=$3;gsub(/CHROMOSOME_/,"",ch);printf("Sequence XI_%s__%d_%d_%s\ncdna_clone XI_%s__%d_%d_%s\nIntMap %s  %d %d\nComposite %d %d %d %d %d\n\n",ch,$5+dx,$6-dx,dd,ch,$5+dx,$6-dx,dd,$3,$4-100*dx,$7+100*dx,$8,$9,$10, $11, $12);}' dd=$dd > tmp/XXXX.ace
 
  cat toto | gawk '/^SL/{nn++;ch=$3;if(ch != oldch)printf("\nSequence %s\n",ch);oldch = ch ;printf("Subsequence XS_%s__%d_%s %d %d\n",$3,$4,dd,$4,$5);}END{printf("\n");}' dd=$dd >> tmp/XXXX.preace
  cat toto | gawk '/^SL/{nn++;if ($2=="Forward")dx=1;else dx=-1;ch=$3;gsub(/CHROMOSOME_/,"",ch);printf("Sequence XS_%s__%d_%s\ncdna_clone XS_%s__%d_%s\nIntMap %s  %d %d\nComposite %d\nIs_read\nColour GREEN4\nForward\n",ch,$4,dd,ch,$4,dd,$3,$4-100*dx,$5+100*dx, $6);if($1~/SL[1-9]/)printf("Transpliced_to %s 0\n",$1); printf("\n");}' dd=$dd >> tmp/XXXX.ace
 
  cat toto | gawk '/^EXON/{nn++;ch=$3;if(ch != oldch)printf("\nSequence %s\n",ch);oldch = ch ;printf("Subsequence XE_%s__%d_%d_%s %d %d\n",$3,$4,$5,dd,$4,$5);}END{printf("\n");}' dd=$dd >> tmp/XXXX.preace
  cat toto | gawk '/^EXON/{nn++;if ($2=="Forward")dx=1;else dx=-1;ch=$3;gsub(/CHROMOSOME_/,"",ch);printf("Sequence XE_%s__%d_%d_%s\ncdna_clone XE_%s__%d__%d_%s\nIntMap %s  %d %d\nComposite %d %d %d\nIs_read\nColour RED4\nForward\n\n",ch,$4,$5,dd,ch,$4,$5,dd,$3,$4-100*dx,$5+100*dx, $6, $7, $8);}' dd=$dd >> tmp/XXXX.ace

 cat toto | gawk '/^pA/{nn++;ch=$3;if(ch != oldch)printf("\nSequence %s\n",ch);oldch = ch ;printf("Subsequence XA_%s__%d_%s %d %d\n",$3,$4,dd,$4,$5);}END{printf("\n");}' dd=$dd >> tmp/XXXX.preace
  cat toto | gawk '/^pA/{nn++;if ($2=="Forward")dx=1;else dx=-1;ch=$3;gsub(/CHROMOSOME_/,"",ch);printf("Sequence XA_%s__%d_%s\ncdna_clone XA_%s__%d_%s\nIntMap %s  %d %d\nComposite %d\nIs_read\nColour RED2\nReverse\n// PolyA_after_base 1\n\n",ch,$4,dd,ch,$4,dd,$3,$4+100*dx,$5-100*dx, $6);}' dd=$dd >> tmp/XXXX.ace

 cat toto | gawk '/^STOP/{nn++;ch=$3;if(ch != oldch)printf("\nSequence %s\n",ch);oldch = ch ;printf("Subsequence XP_%s__%d_%s %d %d\n",$3,$4,dd,$4,$5);}END{printf("\n");}' dd=$dd >> tmp/XXXX.preace
  cat toto | gawk '/^STOP/{nn++;if ($2=="Forward"){ln=$5-$4+1;dx=1;}else {ln = $4-$5+1;dx=-1;}ch=$3;gsub(/CHROMOSOME_/,"",ch);printf("Sequence XP_%s__%d_%s\ncdna_clone XP_%s__%d_%s\nIntMap %s  %d %d\nComposite 0\nIs_read\nColour GRAY\nForward\nPolyA_after_base %d\n\n",ch,$4,dd,ch,$4,dd,$3,$4-100*dx,$5+100*dx, ln);}' dd=$dd >> tmp/XXXX.ace


cat tmp/XXXX.preace | gawk '/^Subsequence/{printf("Sequence %s\n",$2);}' | $tab_sort -u  > tmp/XXXX.list

# Create a pseudo feature table to be used in correl analysis in README.newexons
cat toto | gawk '/^p/{t=bizare;if($1~/paIncluded/ || $1~/paInExonSameStrand/ || $1~/pA/)t="Expressed";if($1~/paInExonOppositeStrand/)t="Antisense";if($1~/paInCDS/)t="in_CDS";if($1~/paFailed/)t="Failed";dx=1;if($2~/Reverse/)dx=-1;printf("pA\t%s\t0\t0\t%s\t%d\t%d\t%s\n",$3,t,$4,$4+dx,$1);}' >  paFeat.txt 
#\cp paFeat.txt ../../UTROME

grep -c XI_  tmp/XXXX.list
grep -c XS_  tmp/XXXX.list
grep -c XE_  tmp/XXXX.list
grep -c XA_  tmp/XXXX.list
grep -c XP_  tmp/XXXX.list

cat tmp/toto_candidates | gawk '/^p/{nn[$3,$4,$5]++;if(nn[$3,$4,$5]==1)n++;}END{printf("distinct pA candidates %d\n",n);}'
cat tmp/toto_candidates | gawk '/^p/{n++} END{print n}'
grep -c paInExonSameStrand toto
grep -c paInCDS toto
grep -c paInExonOppositeStrand toto
grep -c pA toto
grep -c paIncluded toto
grep -c paFailed toto

grep -c Failed paFeat.txt
grep -c Expressed  paFeat.txt

date
bin/tacembly ../../WormGenomeDb <<EOF > /dev/null
  parse -NOXREF tmp/XXXX.preace
  query find sequence subsequence
  table -o tmp/XXXX.dna.txt -f tables/chrom2subseq2dna.def
  quit
EOF
date

cat tmp/XXXX.dna.txt | gawk -F '\t' '{gsub(/\"/,"",$0);gsub(/CHROMOSOME_/,"",$0);if($2~/XA_/)printf (">%s\n%s\n",$2,$5);}' >  tmp/XXXX.pA.dna
cat tmp/XXXX.dna.txt | gawk -F '\t' '{gsub(/\"/,"",$0);gsub(/CHROMOSOME_/,"",$0);if($2~/XP_/)printf (">%s\n%s\n",$2,$5);}' >  tmp/XXXX.Stop.dna
cat tmp/XXXX.dna.txt | gawk -F '\t' '{gsub(/\"/,"",$0);gsub(/CHROMOSOME_/,"",$0);if($2~/XS_/)printf (">%s\n%s\n",$2,$5);}' >  tmp/XXXX.SL.dna
cat tmp/XXXX.dna.txt | gawk -F '\t' '{gsub(/\"/,"",$0);gsub(/CHROMOSOME_/,"",$0);if($2~/XE_/)printf (">%s\n%s\n",$2,$5);}' >  tmp/XXXX.EXON.dna

cat tmp/XXXX.dna.txt | gawk -F '\t' '{gsub(/\"/,"",$0);gsub(/CHROMOSOME_/,"",$0);if($2~/XI_/)print;}' > tmp/XXXX.Intron.tmp
cat tmp/XXXX.Intron.tmp | gawk -F '\t' '{s=$2;i=length(s);d=$5;j=length(d);z=substr(s,i-1);if(z=="_A"){sA=substr(s,1,i-2);dA=substr(d,1,j-2);iA=substr(d,j-1,2);next;}if(z=="_B"){sB=substr(s,1,i-2);dB=substr(d,3);iB=substr(d,1,2);iAB = iA "_" iB ; if(iAB=="gt_ag" || iAB == "gc_ag" || iAB == "ct_ac"|| iAB == "at_ac") other = "" ; else other="Other " ; if(sA==sB){printf("Sequence %s\ncDNA_clone %s\nForward\nIs_read\nComposite\nColour GREEN\n%s %s\n\n",sB,sB,other,iAB); printf(">%s\n%s%s\n\n",sB,dA,dB);}}}' > tmp/XXXX.INTRON.ace

grep 'Sequence XI_' tmp/XXXX.INTRON.ace | $tab_sort -u > tmp/XXXX.INTRON.list

### make a set of pink composite for the predicted models
if (0 && ! -e tmp/RefSeq.composite.dna) then
  cat tmp/RefSeq.solexa.ace | gawk '/^mRNA/{mm=$2;next;}/^Solexa/{t=$2;x=$3;h=$4;if(h<hMin)h=0;'
endif

bin/tacembly ~/yk/TEST <<EOF > /dev/null
  read-models
  query find sequence (Composite && IS X?_*2009_10_18)
  spush
  follow dna
  sor
  undo
  follow cdna_clone
  sor
  spop
  kill
  save
  parse tmp/XXXX.ace 
  parse tmp/XXXX.pA.dna
  parse tmp/XXXX.Stop.dna
  parse tmp/XXXX.SL.dna
  parse tmp/XXXX.EXON.dna
  parse tmp/XXXX.INTRON.ace
  query find est IS XP_* && Composite 
  query find sequence (Composite && IS X?_*2009_10_18) && bad_quality && Is_read
  edit -D IS_Read
  query find sequence (Composite && IS X?_*2009_10_18) ; ! from_gene
  acem   
    cdna_2   Chromosome_III
    quit
  save
      find tg
      acem
        // cdna_73 -repeats // will kill all the non_best_mrna resize and construct the repeats
        quit 
      query find tg to_be_fused_with
      acem
        cdna_73 // -fuse_locally // needed after repeats
        quit 
      acem
        // cdna_31 // recomputes -locally
        quit
      query find tg
      acem
        cdna_73 -split_cloud // -split_cloud prevents fuse
        quit
      query find mrna
      acem
        polyatag
        quit
  save
  quit
EOF

goto phaseLoop

cd ~/yk
bin/tacembly . <<EOF > /dev/null
  dump -s dumpdir.2009_10_28
EOF
cd dumpdir.2009_10_28
rr
bin/tacembly . < _r > /dev/null

###############################################################
## analyse the strand of the EST
 
# best method may be to compute the stranded wiggle, then the shadow of the cloud genes
# then reorient the cloud genes then the ESTs in the reoriented cloud genes

phaseest1:

if ($Strategy != RNA_seq) goto phaseLoop

cat tmp/PHITS_est/FABIOfa/*/*off*.hits | gawk '{n[$1]++;if($2<$3)p[$1]++;else m[$1]++;}END{for(k in n)printf("%s\t%d\t%d\t%d\n",k,n[k],p[k],m[k]);}' > est.strand.count

# 1358379
grep -c '>' MRNAS/worm.est.fasta 
grep  '>' MRNAS/worm.est.fasta | grep -v U454 | wc

# 925876
wc est.strand.count
# 89710/577925 only of the U454 can be stranded
grep -c 'U454' MRNAS/worm.est.fasta 
grep -c U454 est.strand.count
grep -v U454 est.strand.count | wc

# separate the strands
cat est.strand.count | gawk -F '\t' '{if($3 > 3 && $3 > 3*$4)print}' | grep -v U454 > est.strand.plus
cat est.strand.count | gawk -F '\t' '{if($4 > 3 && $4 > 3*$3)print}' | grep -v U454 > est.strand.minus
wc est.strand.*us
wc est.strand.*
# create acedb .lists
cat est.strand.plus  | gawk '{printf("Sequence \"%s\"\ndForward %d %d\n\n",$1, $3, $4);}' >  est.strand.plus.ace
cat est.strand.minus | gawk '{printf("Sequence \"%s\"\ndReverse %d %d\n\n",$1, $4, $3);}' >  est.strand.minus.ace

###############################################################
###############################################################
cat tmp/PHITS_mito/FABIO/Mixed/pA.4*hits | gawk '/^#/{next}{if($5==1 && $6==51)print $4}' | $tab_sort -u | gawk '{i=index($1,"#");n=0+substr($1,i+1);k++;nn+=n;}END{print k,nn}' 

cat tmp/PHITS_est/FABIOfa/Mixed/pA.4*hits | gawk '/^#/{next}{if($5==1 && $6==51)print $4}' | $tab_sort -u > totoest
cat totoest | gawk '{i=index($1,"#");n=0+substr($1,i+1);k++;nn+=n;}END{print k,nn}' 

cat tmp/PHITS_av/FABIOfa/Mixed/pA.4*hits | gawk '/^#/{next}{if($5==1 && $6==51)print $4}' | $tab_sort -u > totoav
cat totoav | gawk '{i=index($1,"#");n=0+substr($1,i+1);k++;nn+=n;}END{print k,nn}' 

cat tmp/PHITS_est/FABIOfa/Mixed/pA.*hits | gawk '/^#/{next}{print $4}' | $tab_sort -u > totoest2
cat totoest2 | gawk '{i=index($1,"#");n=0+substr($1,i+1);k++;nn+=n;}END{print k,nn}' 

cat tmp/PHITS_av/FABIOfa/Mixed/pA.*hits | gawk '/^#/{next}{print $4}' | $tab_sort -u > totoav2
cat totoav2 | gawk '{i=index($1,"#");n=0+substr($1,i+1);k++;nn+=n;}END{print k,nn}' 
cat totoest2 totoav2 | $tab_sort -u | gawk '{i=index($1,"#");n=0+substr($1,i+1);k++;nn+=n;}END{print k,nn}' 
cat totoest2 totoav2 totoav2 | gawk '{n[$1]++;}END{for(k in n)printf("%s\t%d\n",k,n[k]);}' > totob
cat totob |  gawk '{n[$2]++;i=index($1,"#");nn[$2]+=0+substr($1,i+1);}END{for(k in n)printf("%s\t%d\t%d\n",k,n[k],nn[k]);}'

############################################################################################################
############################################################################################################

#######################################################################################
# Create an ace file as output, analyse the counts is done in README.elements
# and centralized in acedb database ELEMENTS/ZE

#######################################################################################
#######################################################################################
cd ~/36a_3
foreach dd (`ls -d EstMarkInfo*`)
  echo $dd
  if (! -e $dd/database/lock.wrm) then
    $bin/tacembly $dd <<EOF > /dev/null
      query find sequence full_name
      edit -D full_name
      save
      quit
EOF
  endif
end
##############################################################
## Helicos stats
## analyse the alignments given by Helicos
pushd DATA/SeQC_Heliscope_040809/aligns/

date > totoH2
foreach tissue (Brain UHRR)
  echo "Alignments by Helicos of their second $tissue dataset"  >> totoH
  tail -n +2 $tissue.align.filt.txt | gawk -F '\t' '{ne=$9+$10+$11;NX=6*$6;if(0*ne>NX)next;if(ne>NN)next;nali++;p=$2;n[p]++;k=n[p];if(k==1)ntag++;else nn[k-1]--;nn[k]++;if(k>kmax)kmax=k;st[$5]++;if($5>stmax)stmax=$5;se[$6]++;if($6>semax)semax=$6;if(ne>nemax)nemax=ne;nne[ne]++;nmm[$9]++;ndel[$10]++;ni[$11]++;}END{printf("%d\talignments\t%d\ttags aligned\n",nali,ntag);printf("Number of tags aligned n times\nAny");for (k=1;k<=kmax;k++)printf("\t%d",k);printf("\n%d",ntag);for (k=1;k<=kmax;k++)printf("\t%d",nn[k]);printf("\nNumber of tags with n errors\nAny");for (k=1;k<=nemax;k++)printf("\t%d",k);printf("\n%d",ntag);for (k=0;k<=nemax;k++)printf("\t%d",nne[k]);printf("\nPosition of the first aligned base\nAny");for (k=1;k<=stmax;k++)printf("\t%d",k);printf("\n%d",ntag);for (k=1;k<=stmax;k++)printf("\t%d",st[k]);printf("\nPosition of the last aligned base\nAny");for (k=20;k<=semax;k++)printf("\t%d",k);printf("\n%d",ntag);for (k=1;k<=semax;k++)printf("\t%d",se[k]);printf("\n");}' NN=1000 >> totoH2
end
cat totoH2
cp totoH2 RESULTS/$MAGIC.helicos2.helicos_any_quality_alignments.txt


###########################################################################################
phase99:
# remove the junk
foreach run (`cat MetaDB/$MAGIC/RunList`) 
   echo cleanup $run
   \rm consolidate*$run*
   \rm count.target.*$run*
   \rm count*$manip*$run*
   \rm multiplicity*$run*
   \rm verif_*$manip*$run*
end

exit


### test on bowtie
## we have
grep 'HWI-EAS107:1:46:1508:477#0/1' tmp/PHITS_genome/ILM_100.UHR.1.genome.X.hits
X       1335281 1335380 HWI-EAS107:1:46:1508:477#0/1    1       100     4       0       1       95      95      0       -       -       96      a>t     ttacc      96

# but it does not show as a bowtie genome ali, why ?
tail -n +18965985 Fasta/ILM_100/UHR.1.fastq | head -4 > toto.fastq
bowtie -q -l 35 -n 2  -k 10 --best BT/$species.genome  toto.fastq


###############################################################
###############################################################
ls | gawk '/^count/{printf("\\rm \"%s\"\n",$0);}' > _k2
source _k2
ls | gawk '/^verif_/{printf("\\rm \"%s\"\n",$0);}' > _k2
source _k2

exit 1

phaseTimer:

grep memory tmp/LOGS/*genome*err | gawk '{n=int($10/100);nn[n]++;}END{for(k in nn)printf("%d\t%d\n",k,nn[k]);}' | $tab_sort -k 1nr

#  OR.candidate pA.candidate SL.candidate)
echo > toto
foreach run (`cat MetaDB/$MAGIC/RunList`)  
  if ($2 != "" && ! ($run =~ $2*)) continue
  if (-d Fastc/$run) then
    cat Fastc/$run/*.count | gawk '/Tags_kept/{print}/Bases_tags_kept/{print}' >> toto
  endif
end

cat toto | gawk '/Tags_kept/{nt+=$2;}/Bases_tags_kept/{n1++;nn+=$2;}END{n2=int(nn/1000000);printf("%d Fastc files %.1f Mtags %dMb %dMb/file\n",n1,nt/1000000,n2,n2/(1+n1));}'

foreach target ($targets)
  echo -n "$target "
  echo $target >! toto
  foreach run (`cat MetaDB/$MAGIC/RunList`)  
    if ($2 != "" && ! ($run =~ $2*)) continue
      if (-d tmp/PHITS_$target/$run) then
        foreach ff (`ls tmp/PHITS_$target/$run/*.err`)
          cat $ff | gawk '/Wallclock|CPU|User Time/{gsub(/ Time/,"",$0);n[$1]=$0;}END{for (k in n)print n[k]}' >> toto
        end
        grep Status  tmp/PHITS_$target/$run/*.err | grep -v '= 0' 
      endif
  end
  cat toto | grep CPU | gawk '{n++;t=$3;split(t,z,":");h+=z[1];m+=z[2];s+=z[3];}END{m+=int(s/60);s=s%60;h+=int(m/60);m=m%60;if(n>0)printf("%d processes: CPU %sh %sm %ss, %d s/process\n",n,h,m,s,(3600*h+60*m+s)/n);}'
end

echo " " >! toto

cat toto | gawk '/CPU/{n++;t=$3;split(t,z,":");h+=z[1];m+=z[2];s+=z[3];}END{if(n>0)printf("Introns %d processes: CPU %sh %sm %ss, %d s/process\n",n,h,m,s,(3600*h+60*m+s)/n);m+=int(s/60);s=s%60;h+=int(m/60);m=m%60;if(n>0)printf("Introns %d processes: CPU %sh %sm %ss, %d s/process\n",n,h,m,s,(3600*h+60*m+s)/n);}'

goto phaseLoop

### worm alignment seed every 5bp, low queue, 2010_09_09, WS217
239 Fastc files 1903.1 Mtags 72008Mb 301Mb/file
mito 239 processes: CPU 3h 27m 55s, 52 s/process 85Mb/h
SpikeIn 239 processes: CPU 3h 33m 20s, 53 s/process
rrna 239 processes: CPU 3h 44m 45s, 56 s/process
rnaGene 239 processes: CPU 3h 35m 28s, 54 s/process
av 239 processes: CPU 16h 40m 35s, 251 s/process
RefSeq 239 processes: CPU 23h 2m 18s, 347 s/process
EBI 239 processes: CPU 16h 45m 37s, 252 s/process
HINV 239 processes: CPU 20h 15m 44s, 305 s/process
genome 239 processes: CPU 20h 12m 4s, 304 s/process  15Mb/h, 100Mtags/h

### worm alignment seed every 10bp, low queue, 2010_09_08, WS217
mito 239 processes: CPU 3h 4m 2s, 46 s/process
SpikeIn 239 processes: CPU 3h 5m 59s, 46 s/process
rrna 239 processes: CPU 3h 14m 15s, 48 s/process
rnaGene 239 processes: CPU 2h 51m 53s, 43 s/process
av 239 processes: CPU 12h 15m 35s, 184 s/process
RefSeq 239 processes: CPU 16h 19m 5s, 245 s/process
EBI 239 processes: CPU 11h 56m 45s, 179 s/process
HINV 239 processes: CPU 16h 5m 49s, 242 s/process
genome 239 processes: CPU 13h 44m 35s, 207 s/process

### worm alignment seed every 5bp, low queue,  2010_09_07, WS217
SpikeIn 239 processes: CPU 4h 11m 7s, 63 s/process
rrna 239 processes: CPU 4h 27m 0s, 67 s/process
rnaGene 239 processes: CPU 4h 0m 25s, 60 s/process
av 239 processes: CPU 15h 55m 30s, 239 s/process
RefSeq 239 processes: CPU 21h 30m 35s, 323 s/process
EBI 239 processes: CPU 16h 25m 41s, 247 s/process
HINV 239 processes: CPU 18h 55m 1s, 284 s/process
genome 239 processes: CPU 21h 29m 39s, 323 s/process

### worm alignment calculation, optimized associators seed 2010_08_31, WS217
mito 239 processes: CPU 3h 15m 52s
SpikeIn 239 processes: CPU 3h 8m 20s
rrna 239 processes: CPU 3h 21m 59s
rnaGene 239 processes: CPU 3h 5m 33s
av 239 processes: CPU 8h 28m 46s
RefSeq 239 processes: CPU 10h 55m 50s
EBI 239 processes: CPU 8h 39m 11s
HINV 239 processes: CPU 10h 50m 43s
genome 239 processes: CPU 20h 54m 52s

### worm alignment calculation, shifting seed 2010_08_25, every 10bp, WS217
# total 45h CPU in 1h elapsed on the farm
mito 466 processes: CPU 4h 48m 3s
SpikeIn 239 processes: CPU 2h 25m 36s
rrna 239 processes: CPU 2h 30m 17s
rnaGene 239 processes: CPU 2h 21m 53s
av 239 processes: CPU 7h 56m 24s
RefSeq 239 processes: CPU 14h 2m 31s
EBI 239 processes: CPU 7h 58m 49s
HINV 239 processes: CPU 10h 24m 51s
genome 239 processes: CPU 21h 50m 50s (28h 37 in the next run)

### worm alignment calculation, shifting seed 2010_22_07, denser: one word every 10bp in genome
rnaGene 230 processes: CPU 3h 3m 50s
mito 230 processes: CPU 2h 44m 6s
av 230 processes: CPU 11h 11m 5s
RefSeq 230 processes: CPU 6h 35m 26s
genome 230 processes: CPU 27h 1m 50s

### worm alignment calculation, shifting seed 2010_06_07
rnaGene 213 processes: CPU 3h 25m 42s
mito 213 processes: CPU 3h 17m 49s
RefSeq 213 processes: CPU 9h 23m 26s
genome 213 processes: CPU 29h 22m 21s

### worm complete calculation, including intron search 2010_02_09
rnaGene 1373 processes: CPU 13h 47m 38s
mito 1373 processes: CPU 20h 37m 10s
av 1373 processes: CPU 49h 55m 6s
RefSeq 1373 processes: CPU 25h 36m 28s
genome 1373 processes: CPU 34h 26m 37s

### worm complete calculation, including intron search 2010_02_17, adding the minEntropy4 filter
rnaGene 1373 processes: CPU 7h 51m 10s
mito 1373 processes: CPU 9h 32m 38s
av 1373 processes: CPU 40h 24m 45s
RefSeq 1373 processes: CPU 22h 11m 26s
genome 1373 processes: CPU 33h 20m 51s

#### Body2 2011_01_11 // just Mixed,  no multiplexing
235 Fastc files 1179.8 Mtags 117982Mb 499Mb/file
SpikeIn 235 processes: CPU 9h 10m 6s, 140 s/process
mito 235 processes: CPU 9h 49m 14s, 150 s/process
rrna 235 processes: CPU 9h 30m 22s, 145 s/process
rnaGene 235 processes: CPU 10h 42m 59s, 164 s/process
RefSeq 231 processes: CPU 35h 9m 29s, 547 s/process
av 231 processes: CPU 73h 45m 3s, 1149 s/process
genome 231 processes: CPU 154h 21m 8s, 2405 s/process
Introns 1 processes: CPU 0h 0m 0s, 0 s/process

#### Body2 2010_12_11 // just Feb50, Feb75,  no multiplexing
####  to be compared with Bodymap Feb which is multiplexed
298 Fastc files 3818.7 Mtags 222510Mb 744Mb/file
SpikeIn 298 processes: CPU 6h 54m 39s, 83 s/process
mito 298 processes: CPU 7h 14m 18s, 87 s/process
rrna 298 processes: CPU 6h 56m 20s, 83 s/process
rnaGene 298 processes: CPU 7h 37m 5s, 92 s/process
RefSeq 298 processes: CPU 34h 38m 36s, 418 s/process
av 298 processes: CPU 72h 31m 24s, 876 s/process
genome 298 processes: CPU 170h 14m 8s, 2056 s/process

#### Body2 2010_12_11 // 16_Tissues, Feb50, Feb75, not Mixed_tissues, no multiplexing
####  the sequences are as below, but now correctly sorted alphabetically and merged
571 Fastc files 6972.8 Mtags 380215Mb 664Mb/file
SpikeIn 571 processes: CPU 12h 9m 28s, 76 s/process
mito 571 processes: CPU 12h 43m 38s, 80 s/process
rrna 571 processes: CPU 12h 10m 24s, 76 s/process
rnaGene 571 processes: CPU 13h 20m 18s, 84 s/process
RefSeq 571 processes: CPU 62h 57m 38s, 396 s/process
av 571 processes: CPU 131h 34m 7s, 829 s/process
genome 571 processes: CPU 322h 1m 32s, 2030 s/process
Introns 14305 processes: CPU 66h 59m 18s, 16 s/process

#### Body2 2010_12-01 // without seqs rationalised in tags
####  the sequences have kept their identifiers and are not sorted alphabetically
# feb50 + feb75 + 16_tissues, mixed_tissues is missing
# genome and av are incomplete, some codes crashed
# 
phase timer start Thu Dec  2 09:49:15 EST 2010
1446 Fastc files 6970.3 Mtags 380090Mb 262Mb/file
SpikeIn 1446 processes: CPU 52h 58m 50s, 131 s/process
mito 1446 processes: CPU 94h 3m 59s, 234 s/process
rrna 1446 processes: CPU 54h 32m 29s, 135 s/process
rnaGene 1446 processes: CPU 55h 40m 56s, 138 s/process
RefSeq 1444 processes: CPU 278h 24m 8s, 694 s/process       many error codes  
av 1446 processes: CPU 505h 28m 54s, 1258 s/process     many error codes  
genome 1446 processes: CPU 890h 9m 30s, 2216 s/process  very many error codes  
 

#### Bodymap 2010_11-11 // added HEL data
570 Fastc files 8065.6 Mtags 489696Mb 857Mb/file
SpikeIn 557 processes: CPU 13h 38m 53s, 88 s/process
mito 557 processes: CPU 14h 28m 57s, 93 s/process
rrna 557 processes: CPU 13h 51m 43s, 89 s/process
rnaGene 557 processes: CPU 15h 26m 56s, 99 s/process
RefSeq 557 processes: CPU 71h 53m 20s, 464 s/process
av 557 processes: CPU 156h 38m 0s, 1012 s/process
genome 557 processes: CPU 365h 6m 33s, 2359 s/process
gdecoy 557 processes: CPU 196h 39m 3s, 1270 s/process

#### Bodymap 2010_09_09 // every 5bp all (all including mixed which  is twice as slow)
491 Fastc files 8127.3 Mtags 494630Mb 1007Mb/file
SpikeIn 491 processes: CPU 12h 47m 8s, 93 s/process
mito 491 processes: CPU 13h 1m 52s, 95 s/process
rrna 491 processes: CPU 12h 54m 52s, 94 s/process
rnaGene 491 processes: CPU 14h 25m 36s, 105 s/process
RefSeq 491 processes: CPU 62h 39m 32s, 459 s/process  130 Mtgas/h
RefSeq 491 processes: CPU 61h 5m 40s, 447 s/process
av 491 processes: CPU 155h 19m 1s, 1138 s/process
genome 491 processes: CPU 364h 22m 35s, 2671 s/process 22 Mtags/h
gdecoy 491 processes: CPU 283h 11m 48s, 2076 s/process

#### Bodymap 2010_11-11 // just Feb*
202 Fastc files 3818.1 Mtags 222476Mb 1101Mb/file
SpikeIn 202 processes: CPU 3h 48m 47s, 67 s/process
mito 202 processes: CPU 4h 0m 33s, 71 s/process
rrna 202 processes: CPU 3h 51m 1s, 68 s/process
rnaGene 202 processes: CPU 4h 20m 16s, 77 s/process
RefSeq 202 processes: CPU 19h 47m 58s, 352 s/process
av 202 processes: CPU 40h 14m 54s, 717 s/process
genome 202 processes: CPU 113h 40m 49s, 2025 s/process
gdecoy 202 processes: CPU 71h 50m 20s, 1280 s/process

#### Bodymap 2010_09_09 // every 5bp just Feb* == 
202 Fastc files 3818.1 Mtags 222476Mb 1101Mb/file
SpikeIn 202 processes: CPU 3h 48m 49s, 67 s/process
mito 202 processes: CPU 3h 53m 11s, 69 s/process
rrna 202 processes: CPU 3h 49m 17s, 68 s/process
rnaGene 202 processes: CPU 4h 24m 0s, 78 s/process
RefSeq 202 processes: CPU 18h 42m 54s, 333 s/process  207 Mtgas/h
RefSeq 202 processes: CPU 19h 43m 48s, 351 s/process
av 202 processes: CPU 41h 49m 20s, 745 s/process
genome 202 processes: CPU 120h 14m 45s, 2142 s/process, 31 Mtags/h
gdecoy 202 processes: CPU 110h 40m 46s, 1972 s/process

#### Bodymap 2010_08_31 // just ali: == a2 with optimized associator
SpikeIn 492 processes: CPU 21h 13m 31s
mito 492 processes: CPU 24h 1m 5s
RefSeq 492 processes: CPU 55h 18m 2s  147 Mtags/h
genome 492 processes: CPU 298h 4m 28s 27 Mtags/h
#### Bodymap 2010_08_31 // idem, but just the Feb50 and Feb75 manips
SpikeIn 202 processes: CPU 2h 33m 50s
mito 202 processes: CPU 2h 50m 43s
rrna 202 processes: CPU 2h 37m 39s
RefSeq 202 processes: CPU 13h 28m 42s 240s/process 282 Mtags/h
genome 202 processes: CPU 74h 43m 23s  1330 s/process, 51 Mtags/h

#### Bodymap 2010_08_31 // just ali: == a2 with optimized associator
SpikeIn 492 processes: CPU 21h 13m 31s
mito 492 processes: CPU 24h 1m 5s
RefSeq 492 processes: CPU 55h 18m 2s
genome 492 processes: CPU 298h 4m 28s
#### Bodymap 2010_08_31 // idem, but just the Feb50 and Feb75 manips
SpikeIn 202 processes: CPU 2h 33m 50s
mito 202 processes: CPU 2h 50m 43s
rrna 202 processes: CPU 2h 37m 39s
RefSeq 202 processes: CPU 13h 28m 42s
genome 202 processes: CPU 74h 43m 23s

#### Bodymap 2010_06_14 // just ali: == a2 tout court dans cette nouvelle 
mito 202 processes: CPU 2h 50m 43s
rrna 202 processes: CPU 2h 37m 39s
SpikeIn 315 processes: CPU 4h 34m 11s
av 315 processes: CPU 311h 38m 1s

#SEQC every 5bp 2010_11_11, should be less biased for first genome strand
452 Fastc files 3401.3 Mtags 167525Mb 369Mb/file
rrna 452 processes: CPU 9h 2m 6s, 71 s/process
rnaGene 452 processes: CPU 10h 7m 35s, 80 s/process
mito 452 processes: CPU 9h 35m 1s, 76 s/process
SpikeIn 452 processes: CPU 9h 9m 3s, 72 s/process
av 452 processes: CPU 94h 52m 29s, 755 s/process
RefSeq 452 processes: CPU 44h 45m 58s, 356 s/process
EBI 452 processes: CPU 65h 27m 12s, 521 s/process
genome 452 processes: CPU 295h 42m 42s, 2355 s/process
gdecoy 452 processes: CPU 178h 33m 56s, 1422 s/process

#SEQC every 5bp 2010_10_10
rrna 452 processes: CPU 9h 19m 20s, 74 s/process
rnaGene 452 processes: CPU 10h 31m 1s, 83 s/process
mito 452 processes: CPU 9h 58m 32s, 79 s/process
SpikeIn 452 processes: CPU 9h 46m 11s, 77 s/process
av 452 processes: CPU 100h 56m 45s, 803 s/process
RefSeq 452 processes: CPU 45h 55m 9s, 365 s/process
RefSeq 452 processes: CPU 42h 47m 8s, 340 s/process
EBI 450 processes: CPU 66h 16m 19s, 530 s/process
genome 452 processes: CPU 302h 26m 9s, 2408 s/process
gdecoy 452 processes: CPU 170h 49m 53s, 1360 s/process

#SEQC every 5bp 2010_09_09
rrna 453 processes: CPU 8h 47m 55s, 69 s/process
rnaGene 453 processes: CPU 10h 8m 59s, 80 s/process
mito 453 processes: CPU 9h 30m 42s, 75 s/process
SpikeIn 453 processes: CPU 9h 14m 14s, 73 s/process
av 453 processes: CPU 104h 49m 28s, 833 s/process
RefSeq 462 processes: CPU 44h 6m 34s, 343 s/process
RefSeq 453 processes: CPU 47h 32m 32s, 377 s/process
EBI 453 processes: CPU 75h 22m 1s, 598 s/process
genome 453 processes: CPU 315h 52m 29s, 2510 s/process
gdecoy 453 processes: CPU 273h 33m 38s, 2173 s/process

#SEQC with bloom/hash
rrna 452 processes: CPU 6h 10m 16s, 49 s/process
rnaGene 452 processes: CPU 6h 49m 37s, 54 s/process
mito 452 processes: CPU 6h 58m 56s, 55 s/process
SpikeIn 452 processes: CPU 6h 4m 7s, 48 s/process
av 452 processes: CPU 52h 10m 58s, 415 s/process
RefSeq 460 processes: CPU 21h 14m 30s, 166 s/process
RefSeq 452 processes: CPU 23h 3m 11s, 183 s/process
EBI 452 processes: CPU 33h 10m 4s, 264 s/process
genome 452 processes: CPU 202h 44m 5s, 1614 s/process

# ABYSS mouse, date
31 Fastc files 209.4 Mtags 10495Mb 327Mb/file
SpikeIn 31 processes: CPU 0h 39m 23s, 76 s/process
rrna 31 processes: CPU 0h 38m 9s, 73 s/process
mito 31 processes: CPU 0h 38m 39s, 74 s/process
av 31 processes: CPU 4h 15m 18s, 494 s/process
RefSeq 31 processes: CPU 2h 11m 55s, 255 s/process
genome 31 processes: CPU 13h 43m 17s, 1593 s/process  15M tags/h
gdecoy 31 processes: CPU 8h 40m 23s, 1007 s/process
Introns 24 processes: CPU 0h 32m 51s, 82 s/process

#### tabix

gunzip -c LIF_S.UHR.u.f.bf.gz | bin/wiggle -I BF -O BV | tail -n +4 | gawk '{printf("3\t%d\t%d\n",$1,$2);}' | bgzip > tata.gz
tabix -s 1 -b 2 -e 2 tata.gz
tabix tata.gz 3:40668-40700

mkdir TabX
foreach chrom ($chromSetAll)
  echo $chrom
  # gunzip -c $chrom/LIF_S.UHR.u.f.bf.gz | bin/wiggle -I BF -O BV | tail -n +4 | gawk '{printf("%s\t%d\t%d\n",chrom,$1,$2);}' chrom=$chrom >> TabX/$chrom.tmp
  gunzip -c $chrom/Mixed.gonly.f.bf.gz | bin/wiggle -I BF -O BV | tail -n +4 | gawk '{printf("%s\t%d\t%d\n",chrom,$1,$2);}' chrom=$chrom >> TabX/Mixed.gonly.f.tmp
end
mkdir TABX
cat TabX/*.tmp | bgzip > TABX/Mixed.gonly.f.gz
tabix -s 1 -b 2 -e 2 TABX/Mixed.gonly.f.gz

tabix TABX/Mixed.gonly.f.gz X:900668-1095700 | wc
tabix TABX/Mixed.gonly.f.gz II:90668-195700 | wc


######################################################################
######################################################################

phaseWait:
  scripts/submit wait

goto phaseLoop

######################################################################

phaseLoop:
echo -n "phase $phase done : "
date
cd $CaliRootDir 

# for parasol launch now the registered jobs
scripts/submit run

end
echo "MAGIC $MAGIC done "


exit 0

######################################################################
######################################################################
######################################################################
## clean all, very dangerous

# insure we do not randombly fall on this line of code
exit 1  
phaseClean:
    echo "DANGER"
    echo "DANGER"
    echo "DANGER"
  echo -n "Are you sure you want to clean all previous results generated by the program, please reply yes_I_do/no "
  set reply=`gawk '{print $1; exit;}'`
  if ($reply == yes_I_do) then
    echo cleaning up
    \rm -rf tmp GeneIndexDB *List RESULTS Runs.ace TestData _* tmp/SNP_DB GeneIndexDB toto* ZZZZZ* bin scripts MAGIC

    echo "EVEN MORE DANGEROUS"
    echo "EVEN MORE DANGEROUS"
    echo "EVEN MORE DANGEROUS"
    echo "Do you also want to destroy the MetaDB and the Fastc files ?"
    echo "These may contain manual annotations"
    echo -n "Please reply yes_I_also_do/no "
    set reply=`gawk '{print $1; exit;}'`
    if ($reply == yes_I_also_do) then
      echo cleaning up
      \rm -rf tmp MetaDB Fastc LIMITS
    else
      echo "Sorry, I skip since you did not reply yes_I_also_do"
    endif

  else
    echo "Sorry, I do nothing since you did not reply yes_I_do"
  endif

exit 0

######################################################################
## clean all, very dangerous

# insure we do not randombly fall on this line of code
exit 1  
phaseCleanRunList:
    echo "DANGER"
    echo "DANGER"
    echo "DANGER"
  echo -n "Are you sure you want to clean all previous results for these runs\n$phaseSet\n.....please reply yes_I_do/no "
  set reply=`gawk '{print $1; exit;}'`
  if ($reply == yes_I_do) then
    echo cleaning up
    foreach run ($phaseSet)
       if ($run == cleanRunList) continuet
       echo $run
       \rm -rf tmp/*/$un tmp/*INDEX/$un
    end
 else
    echo "Sorry, I do nothing since you did not reply yes_I_do"
  endif

exit 0

###############################################################
###############################################################


##############

# analyse de la mito chez les 120 sujets
# histo de la couverture

gnuplot -bg white

 plot 'tmp/WIGGLE/mito/Amish_Exome_120indiv.u.ns.BV_no_header' with lines title 'u' , 'tmp/WIGGLE/mito/Amish_Exome_120indiv.nu.ns.BV_no_header' title 'Mitochondria global coverage accross the 120 samples nu' with lines
cat mito.variants.55loci.txt | cut -f 1,7,8,10,11,12 | head -4

# select 55 loci tel que cover >= 10 and cover < mutant + 25, cela elimine les points sauvages
# exporte la table des variants

cat mito.variants.55loci.txt | cut -f 1,7,8,10,11,12 | head -4
#Variant identifier                            Position                        Type                            Experiment          Mutation count                  Coverage  

# pour chaque sujet on cree une table a 55 lignes et 120 colonnes au format R
# la ligne Ghs56 et les lignes de zeros empechent heatmap de marcher, sans doute parce que le vecteur a une norme nulle
cat mito.variants.55loci.txt  | cut -f 1,7,8,10,11,12 | gawk -F '\t' '/Ghs56/{next}/Coverage/{next}{x=$2 ":" $3 ;x=0+$2;p=$4;if(0+$6<1)next;xx[x]=1;pp[p]=1;zz[x,p]=100*$5/$6; ww[p]+=x*$5/$6;}END{n=asort(ww,wws);for (p in pp )if(ww[p]>0)printf("\t%s",p);for (x in xx){printf("\n%s",x);for (p in pp)if(ww[p]>0)printf("\t%.1f",zz[x,p]);}printf("\n");}' | $tab_sort -k 1n >  mito.55loci2run.txt

R
genes = read.table("mito.55loci2run.txt")
gg=as.matrix(genes)
cc=cor(gg)

heatmap(cc)

pdf ("heatmap.Y.pdf")
quit()


###
# grab the hits at a given position
# 

if (0) then
  foreach run (Ghs14 Ghs131)
     gunzip -c tmp/$MAGIC_COUNT_DIR/$run/f.*.hits.gz | gawk -F '\t' '{c=$11;a1=$12;a2=$13;if(a1>a2){a0=a1;a1=a2;a2=a0;}if(c=="22" && a1<=x && a2 >=x)print;}' x=19028712 > my.$run.hits 
  end
  foreach run (Ghs14 Ghs131)
    gunzip -c Fastc/$run/*.fastc.gz | bin/dna2dna -I fastc -O fastc -select my.$run.hits -o my.$run &
  end
  foreach run (Ghs14 Ghs131)
    cat my.$run.fastc | bin/dna2dna -I ccfa -O csfasta | gawk '/^>/{printf("%s\t",substr($1,2));next;}{print}' > ~/RESULTS/my.$run.csfastc.txt
  end
endif

##
# check who is doing what on the sge farm
# qstat -u '*' | gawk '{if($5=="r")n[$4]++}END{for(k in n )print n[k],k;}' | $tab_sort -k 1n
##


###### Ovary reconstruction

exit 0 

set bb=13
# on ace 
pushd B$bb/tmp.$bb
mkdir Batch$bb
cd  Batch$bb

# on ftp archive
bin/rsync -avh --whole-file Batch$bb/* /panfs/pan1.be-md.ncbi.nlm.nih.gov/aceview4/zoo/human/Exome/Ovary/B$bb/tmp.$bb/Batch$bb
# on ace verify
pushd B$bb/tmp.$bb
mkdir Batch$bb

cat batch9.md5 | sed -e 's/Batchs\/Batch9\///' > batch9_fastc_count.md5_short
md5sum -c batch9_fastc_count.md5_short | tee batch9_fastc_count.md5_short.out
cat batch9_fastc_count.md5_short.out | grep -v OK

# create project

ls Fastc | gawk '/^Ghs/{printf("Run %s\nProject B%d\nWiggle\n\n",$1,bb);}' bb=$bb > runList.B$bb.ace
ls Fastc/Ghs*/f2.1.fastc.gz | gawk '{split($1,aa,"/");printf("Run %s\nPaired_end\nIllumina\n\n",aa[2]);}' >> runList.B$bb.ace

popd
bin/tacembly MetaDB <<EOF
  parse B$bb/tmp.$bb/Batch$bb/runList.B$bb.ace
  save
  quit
EOF

cd B$bb
setenv MAGIC B$bb
MAGIC a0C aoD

# verify that all reads have strandedness, platform, paired end, etc

# create the tar file
tar cvf ~/ftp-SEQC/tmp/Laure/SNPH/B$ii.SNPH.2013_0610.tar tmp/SNPH/*/*.sorted
gzip  ~/ftp-SEQC/tmp/Laure/SNPH/B$ii.SNPH.2013_0610.tar



# verify that we have the fastq file for all runs
cat toto2_1 ZZZZZ toto2_2 ZZZZZ toto1 | gawk '/ZZZZZ/{zz++;next;}{if(zz<2){n=length($1);a=substr($1,1,n-8);ff[zz+1,a]=$1;fff[a]=1;next;}printf("%s\t%s\t%s\n",$1,ff[1,$1],ff[2,$1]);fff[$1]=0;}END{for ( a in fff )if(fff[a]!=0) printf ( "\t%s\t%s\n",ff[1,a],ff[2,a] ) ; }' > toto3


####################
## hack june 10

cat toto2_1 ZZZZZ toto2_2 ZZZZZ titi6.txt ZZZZZ RESULTS/RatToDeposit.txt | gawk -F '\t' '/ZZZZZ/{zz++ ; next ; }{if ( zz < 2 ) {n=length ( $1 ) ; a=substr ( $1,1,n-8 ) ; ff[zz+1,a]=$1 ; fff[a]=1 ; next ; }if ( zz < 3 ) {gsub ( /\"/,"",$0 ) ; data["COH_WANG_" $2]=$0 ; next;}printf ( "%s\t%s\t%s\t%s\t",data[$2],$2,ff[1,$2],ff[2,$2] ) ; print ; }' > RESULTS/RatToDeposit.bigger.txt


cat RESULTS/RatToDeposit.txt | sed -e 's/\r//g' | scripts/transpose | gawk -F '\t' 'function dd(x){printf("%s\t%s\t%s",$1,$2,$3);for(i=4;i<=NF;i++){x1=x;if(x==-1)x1=ali[i]/100;printf("\t%.2f",$i/x1);}printf("\n");}{if(index($3,"Read multiplicity")==1){dd(100);next;}}{if(index($3,"Number of mismatches per megabase aligned")==1){dd(1000);next;}}{if(index($3,"Per thousand GC in the reads")==1){dd(10);next;}}{if(index($1,"transform")==1){dd(-1);next;}}{if(index($3,"Reads aligned on any target")==1){for(i=4;i<=NF;i++)ali[i]=$i;}}{print}' | scripts/transpose >  RESULTS/RatToDeposit.modified.txt 

# rat submission consolidation with Charles
cat RESULTS/Charles_details.txt | sed -e 's/\r//g' | gawk -F '\t' '{n++;if(n<16){next;}cell=$12;split(cell,aa,"_");print $12,aa[4],$15;}' | head

cat r2date.txt ZZZZZ RESULTS/RatToDeposit.modified.txt  |  gawk -F '\t' '/^ZZZZZ/{zz++;next;}{gsub(/\"/,"",$0);if(zz<1){dd["COH_WANG_" $2]=$3;next;}printf("%s\t%s\n",$2,dd[$2]);}'

cat RESULTS/Rat_no_title.txt | sed -e 's/\r//g' | gawk -F '\t' '{printf("%s\tLiver of Sprague Dawley rat treated with %s for %d days", $1,$5,$9);}' > RESULTS/Rat_to_title.txt

## hack provisoire 2019_09_14
echo ' ' > toto.partials.ace
foreach run (`cat MetaDB/$MAGIC/RunList`)
  set p5a=0
  set p3a=0
  set p5b=0
  set p3b=0
  foreach lane (`cat Fastc/$run/LaneList`)
    if (-e tmp/COUNT/$lane.hits.gz) then
      set p5a=`zcat tmp/COUNT/$lane.prefix.[012].gz | gawk '{k=length($1);if(k>=15)p5++;}END{print 0+p5;}' p5=$p5a`
      set p3a=`zcat tmp/COUNT/$lane.suffix.[012].gz | gawk '{k=length($1);if(k>=15)p3++;}END{print 0+p3;}' p3=$p3a`
      set p5b=`zcat tmp/COUNT/$lane.prefix.[012].gz | gawk '{k=length($1);if(k>=25)p5++;}END{print 0+p5;}' p5=$p5b`
      set p3b=`zcat tmp/COUNT/$lane.suffix.[012].gz | gawk '{k=length($1);if(k>=25)p3++;}END{print 0+p3;}' p3=$p3b`
    endif
  end
  echo "Ali $run\nPartial_5p $p5a $p5b\nPartial_3p $p3a $p3b\n\n" >> toto.partials.ace
  echo $run
end
echo "parse toto.partials.ace" | bin/tace MetaDB -noprompt 



#  LocalWords:  endif
